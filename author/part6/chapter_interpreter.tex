\chapter{Универсальная модель интерпретации логико-семантических моделей ostis-систем}
\chapauthortoc{Шункевич Д.В.}
\label{chapter_interpreter}

\vspace{-7\baselineskip}

\begin{SCn}
\begin{scnrelfromlist}{автор}
	\scnitem{Шункевич Д.В.}
\end{scnrelfromlist}

\bigskip

\scntext{аннотация}{В главе рассматривается подход к решению проблемы платформенной независимости компьютерных систем, предполагающий унификацию принципов реализации таких систем и обеспечения их семантической совместимости на основе Технологии OSTIS. Приводится формализованная система понятий, определяющая принципы реализации данного подхода}

\bigskip

\begin{scnrelfromlist}{подраздел}
	\scnitem{\ref{sec_interpreter_analysis}~\nameref{sec_interpreter_analysis}}
	\scnitem{\ref{sec_interpreter_ostis_impl}~\nameref{sec_interpreter_ostis_impl}}
	\scnitem{\ref{sec_interpreter_ostis_platform}~\nameref{sec_interpreter_ostis_platform}}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{ключевое понятие}
	\scnitem{sc-машина}
	\scnitem{ostis-платформа}
	\scnitem{базовая ostis-платформа}
	\scnitem{расширенная ostis-платформа}
	\scnitem{специализированная ostis-платформа}
	\scnitem{минимальная конфигурация ostis-системы}
	\scnitem{программный вариант ostis-платформы}
	\scnitem{ассоциативный семантический компьютер}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{библиографическая ссылка}
	\scnitem{\scncite{Kolesnikov2001}}
	\scnitem{\scncite{Komarcova2004}}
	\scnitem{\scncite{TuringMachine}}
	\scnitem{\scncite{NeumanMachine}}
	\scnitem{\scncite{USB_Accelerator}}
\end{scnrelfromlist}

\end{SCn}

%\section{Методы и средства реализации ostis-систем}
\section{Уточнение понятия платформенной независимости и анализ современных подходов к ее обеспечению}
\label{sec_interpreter_analysis}

В общем случае разработка любой искусственной системы, в частности, \textit{интеллектуальной компьютерной системы}, предполагает выполнение двух этапов:
\begin{textitemize}
	\item этапа проектирования, то есть построения формальной модели системы, достаточной для понимания принципов ее устройства и выполнения последующего этапа ее реализации;
	\item этапа реализации, то есть непосредственно воплощения разработанной модели с использованием конкретных средств (инструментов, материалов, комплектующих и т.д.). В случае компьютерных систем выполнение данного этапа обычно предполагает выбор конкретных языков программирования, библиотек, сторонних средств, таких как с.у.б.д. и различные сервисы и т.д., а также собственно программирование и отладку системы с использованием выбранных средств.
\end{textitemize}

Для каждого из указанных этапов могут существовать свои методики, а также средства автоматизации соответствующих процессов.

Если этап проектирования компьютерной системы как правило требует участия высококвалифицированных специалистов и экспертов в предметных областях, в которых осуществляется автоматизация, то этап реализации, с одной стороны, как правило является более простым (при условии качественного выполнения этапа проектирования), а с другой стороны требует значительных ресурсов. Одной из причин этого является необходимость работы компьютерной системы на различных платформах (устройствах), каждое из которых в общем случае может иметь свои особенности и ограничения, которые необходимо учитывать на этапе реализации. Решением данной проблемы является обеспечение платформенной независимости (или кроссплатформенности) разрабатываемых компьютерных систем.

Сама по себе идея обеспечения платформенной независимости давно и широко используется в современных компьютерных системах. Данная проблема, как правило, рассматривается на двух уровнях:
\begin{textitemize}
	\item проблема обеспечения возможности работы \uline{программной} системы в разных операционных системах;
	\item проблема обеспечения совместимости операционной системы с различными аппаратными архитектурами. Для решения этой проблемы могут существовать разные сборки ядра операционной системы для разных аппаратных архитектур, как это делается для операционных систем семейства Linux. При этом следует отметить, что речь в подавляющем большинстве случаев идет не о принципиально разных архитектурах, а о вариантах реализации базовой архитектуры фон Неймана.
\end{textitemize}

В случае, когда разрабатываемая компьютерная система проектируется на более низком уровне, чем операционная система как таковая (например, при программировании контроллеров управления различными устройствами), проблема обеспечения платформенной независимости значительно усугубляется и чаще всего может быть решена только для набора аппаратных средств определенного класса, для которого стандартизируется интерфейс доступа, то есть, по сути, набор низкоуровневых команд обработки информации.

Таким образом, можно сказать, что большее внимание при проектировании современных компьютерных систем на данный момент уделяется первому из перечисленных уровней платформенной независимости, то есть обеспечению работы программной системы на разных операционных системах. Это может достигаться разными путями:
\begin{textitemize}
	\item Использование кроссплатформенных языков программирования, которые, в свою очередь, можно разделить на "полностью"{} интерпретируемые языки (Python, JavaScript и языки на его основе, PHP и другие) и языки, использующие компиляцию в сохраняющий независимость от платформы низкоуровневый байт-код, с его возможной последующей компиляцией в машинный код непосредственно в процессе исполнения (Just-in-time компиляция или JIT-компиляция). К языкам второго класса относятся, например, Java и C\#. Реализация такого подхода требует установки на целевой компьютер с операционной системой интерпретатора соответствующего языка программирования или байт-кода.
	
	Несмотря на популярность такой вариант имеет ряд ограничений:
	\begin{textitemize}
		\item в среднем производительность интерпретируемых программ ниже, чем компилируемых. Одним из подходов к решению данной проблемы и является JIT-компиляция;
		\item строго говоря, кроссплатформенность при таком варианте обеспечивается не для всех операционных систем, а для класса операционных систем и соответствующего класса устройств, например, операционных систем, предназначенных для персональных компьютеров. Так, например, приложение, написанное на языке Java для персонального компьютера не может быть напрямую перенесено на мобильное устройство, поскольку при разработке мобильных приложений учитываются другие принципы работы пользователя с интерфейсом системы, отсутствие многооконности и многое другое.
	\end{textitemize}
	\item Реализация системы в виде web-приложения, работа с которым осуществляется через web-браузер и интерфейс которого, таким образом, реализуется на базе общепринятых стандартов Всемирной паутины (HTML, CSS, JavaScript и языки и библиотеки на его основе). Такой вариант обеспечивает возможность работы с приложением с любого устройства, имеющего web-браузер, в том числе, мобильного. К недостаткам такого варианта относятся:
	\begin{textitemize}
		\item как правило, высокая требовательность к производительности конечного устройства. Современный web-браузер является одним из самых ресурсоемких приложений почти на любом устройстве;
		\item остается за кадром проблема обеспечения платформенной-независимости серверной части web-приложения, которая должна решаться каким-то другим способом;
		\item несмотря на стандартизацию, разработчикам часто приходится учитывать особенности конкретных web-браузеров и тестировать работоспособность приложений для каждого из них;
		\item потенциально одним и тем же web-приложением можно пользоваться на любом устройстве, однако для обеспечения удобства и наглядности как правило приходится разрабатывать отдельные версии web-приложения, адаптированные под разные устройства, имеющие, например разные размеры экрана.
	\end{textitemize}
	\item Виртуализация (контейнеризация, эмуляция). Перечисленные термины не являются полностью синонимичными, но в целом обозначают подход, при котором в рамках операционной системы создается некоторое изолированное локальное окружение (виртуальная машина, контейнер, среда эмуляции), содержащее все необходимые для работы приложения настройки и гарантирующее его работу на любых операционных системах и устройствах, где может интерпретироваться соответствующая виртуальная машина или контейнер. Соответственно, запуск таких окружений требует установки на конечное устройство соответствующего интерпретатора или эмулятора.
	
	Данный подход бурно развивается и набирает популярность в настоящее время, поскольку позволяет решить не только проблему кроссплатформенности, но и избавить потребителя от установки большого числа зависимостей и выполнении настройки приложения на конечном устройстве.
	
	Среди популярных средств реализующих данный подход можно указать средства виртуализации (VirtualBox, DosBox, VMWare Workstation), контейнеризации (Docker), эмуляции приложений Android для настольных операционных систем (Genymotion, Bluestacks, Anbox) и многие другие.
	
	К недостаткам такого подхода можно отнести его ресурсоемкость и снижение производительности, а также ограниченность применения (как правило, соответствующие интерпретаторы разрабатываются только для наиболее популярных и востребованных операционных систем). Кроме того, возникает проблема следующего уровня, связанная уже с зависимостью от выбранного средства виртуализации (контейнеризации).
\end{textitemize}

Важно также отметить, что даже для интерпретируемых языков программирования существует проблема зависимости приложения от используемого набора библиотек и фреймворков. Так, при разработке интерфейса web-приложения могут использоваться популярные фреймворки AngularJS и ReactJS, при этом после выбора одного из них быстрый перевод приложения на другой фреймворк невозможен.

Таким образом, можно сделать вывод о том, что проблеме обеспечения платформенной независимости в современных компьютерных системах уделяется достаточно много внимания, однако в полной мере она не решена. В то же время, существует большое количество успешных частных решений, которые, однако, обладают серьезными ограничениями, связанными, в первую очередь, с отсутствием унификации современных подходов к разработке компьютерных систем. 

Еще более актуальной проблема обеспечения платформенной независимости становится в контексте разработки \textit{\uline{интеллектуальных} компьютерных систем}. Это обусловлено следующими особенностями таких систем:
\begin{textitemize}
	\item значительно более сложная по сравнению с традиционными компьютерными системами структура представляемой информации и, соответственно, многообразие форм ее представления, хранение и обработка которых на разных платформах могут быть организованы совершенно по-разному;
	\item высокие требования к производительности для некоторых классов систем, в частности, систем, использующих машинное обучение, что приводит к созданию специализированных аппаратных архитектур, таких как, например, нейрокомпьютеры (\scncite{Komarcova2004}, \scncite{USB_Accelerator});
	\item многообразие моделей решения задач, которые в общем случае реализуются по-разному в разных системах;
	\item актуальность разработки гибридных интеллектуальных систем \scncite{Kolesnikov2001}, в рамках которых интегрируются различные виды знаний и различные модели решения задач. В виду отсутствия на настоящий момент общепринятой унифицированной основы для их интеграции такие системы создаются в основном с ориентацией на какую-то определенную платформу и трудно переносимы на другие платформы.
\end{textitemize}

Таким образом, можно сказать, что проблема обеспечения платформенной независимости для интеллектуальных систем обусловлена во многом отсутствием \uline{семантической совместимости} компонентов таких систем между собой, что, в свою очередь, создает препятствия даже для реализации подходов к обеспечению платформенной независимости, реализуемых в процессе разработки традиционных компьютерных систем. То есть, для решения проблемы обеспечения платформенной независимости интеллектуальных систем, требуется вначале обеспечить семантическую совместимость компонентов таких систем между собой, что, в свою очередь, предполагает:
\begin{textitemize}
	\item унификацию представления различного рода информации, хранимой в базах знаний таких систем;
	\item унификацию базовых моделей обработки информации, хранимой в базах знаний таких систем, то есть выделение универсального низкоуровневого языка программирования, позволяющего осуществлять обработку информации, хранимой в унифицированном виде;
	\item унификацию принципов реализации различных моделей решения задач и, как следствие, возможность их интеграции в рамках гибридных интеллектуальных систем;
	\item унификацию принципов разработки интерфейсов компьютерных систем, которая бы позволила реализовать в рамках одной интеллектуальной системы возможность взаимодействия с другими системами и пользователями таких систем на разных внешних языках, включая естественные языки.
\end{textitemize}

Указанные принципы реализуются в рамках \textit{Технологии OSTIS}), которая, таким образом, может стать основой для решения проблемы обеспечения семантической совместимости компонентов \textit{интеллектуальных компьютерных систем} в целом и обеспечения платформенной независимости таких систем.
С одной стороны, принципы, лежащие в основе \textit{Технологии OSTIS} (см. \textit{Глава \ref{chapter_ostis_tech} \nameref{chapter_ostis_tech}}) обеспечивают принципиальную возможность реализации платформенной независимости компьютерных систем, разрабатываемых на ее основе (\textit{ostis-систем}). С другой стороны, благодаря своей универсальности \textit{Технология OSTIS} позволяет преобразовать любую современную компьютерную систему в \textit{ostis-систему}, которая будет функционально эквивалентна исходной компьютерной системе, но при этом будет обладать всеми перечисленными выше свойствами, создающими предпосылки для решения проблемы платформенной независимости.

Для реализации данного подхода в рамках \textit{Технологии OSTIS} требуется разработать семейство \textit{онтологий}, обеспечивающих уточнение таких понятий, как \textit{ostis-система}, \textit{ostis-платформа}, их структуры, типологии и предъявляемых к ним требований. Рассмотрению указанных онтологий и посвящена данная глава.

Что касается обозначенной выше проблемы зависимости компьютерных систем от конкретных фрейморков, то аналогичная проблема может возникнуть и при дальнейшем развитии \textit{Технологии OSTIS}, в ситуации, когда соответствующие библиотеки будут содержать достаточно большое количество функционально эквивалентных компонентов. Однако, благодаря принципам, лежащим в основе \textit{Технологии OSTIS}, в частности, смысловому представлению информации и семантической совместимости компонентов, данная проблема будет значительно менее острой, поскольку:
\begin{textitemize}
	\item число функционально эквивалентных компонентов будет значительно ниже, чем в традиционных информационных технологиях, нет необходимости создавать синтаксически разные компоненты, отличия будут только на семантическом уровне;
	\item сами по себе компоненты будут являться более универсальными, то есть смогут быть использованы в значительно большем количестве систем;
	\item есть возможность автоматически выявить близкие компоненты, их сходства, различия, потенциальные конфликты и зависимости компонентов;
	\item есть возможность построения достаточно простых (по сравнению с традиционными технологиями) процедур перехода от одного фреймворка к другому, поскольку все компоненты и фреймворке имеют общую формальную смысловую основу, более высокоуровневую, чем в традиционных технологиях.
\end{textitemize}

\section{Методы и средства реализации ostis-систем}
\label{sec_interpreter_ostis_impl}

\begin{SCn}
\begin{scnrelfromlist}{ключевое понятие}
	\scnitem{sc-модель кибернетической системы}
	\scnitem{ostis-система}
	\scnitem{ostis-платформа}
	\scnitem{sc-память}
	\scnitem{sc-модель базы знаний}
	\scnitem{sc-модель решателя задач}
	\scnitem{sc-модель интерфейса кибернетической системы}
	\scnitem{sc-машина}
	\scnitem{scp-машина}
\end{scnrelfromlist}
\end{SCn}

Рассмотрим предлагаемый подход к организации реализации \textit{ostis-систем}. Одним из ключевых принципов \textit{Технологии OSTIS} является обеспечение платформенной независимости \textit{ostis-систем}, то есть строгое разделение логико-семантической модели кибернетической системы (\textit{sc-модели кибернетической системы}) и платформы интерпретации sc-моделей кибернетических системы (\textit{ostis-платформы}). Преимущества такого строгого разделения достаточно очевидны:
\begin{textitemize}
	\item Перенос \textit{ostis-системы} с одной платформы на другую (например более новую и эффективную или ориентированную на определенный класс устройств) выполняется с минимальными накладными расходами (в идеальном случае -- вообще сводится просто к загрузке \textit{sc-модели кибернетической системы} на платформу);
	\item Компоненты \textit{ostis-систем} становятся универсальными, то есть могут использоваться в любых ostis-системах, где их использование является целесообразным;
	\item Развитие платформы и развитие sc-моделей систем может осуществляться параллельно и независимо друг от друга, в общем случае отдельными независимыми коллективами разработчиков по своим собственным правилам и методикам.
\end{textitemize}

Рассмотрим более детально понятие \textit{логико-семантической модели кибернетической системы}.

\begin{SCn}
\scnheader{логико-семантическая модель кибернетической системы}
\scnidtf{формальная модель (формальное описание) функционирования кибернетической системы, состоящая из (1) формальной модели информации, хранимой в памяти кибернетической системы и (2) формальной модели коллектива агентов, осуществляющих обработку указанной информации.}
\scnsuperset{sc-модель кибернетической системы}
\begin{scnindent}
	\scnidtf{логико-семантическая модель кибернетической системы, представленная в SC-коде}
	\scnidtf{логико-семантическая модель ostis-системы, которая, в частности, может быть функционально эквивалентной моделью какой-либо кибернетической системы, не являющейся ostis-системой}
\end{scnindent}

\scnheader{кибернетическая система}
\scnsuperset{компьютерная система}
\begin{scnindent}
	\scnidtf{искусственная кибернетическая система}
	\scnsuperset{ostis-система}
	\begin{scnindent}
		\scnidtf{компьютерная система, построенная по Технологии OSTIS на основе интерпретации спроектированной логико-семантической sc-модели этой системы}
	\end{scnindent}
\end{scnindent}

\scnheader{ostis-система}
\scnsubset{субъект}
\begin{scnrelfromset}{обобщенная декомпозиция}
	\scnitem{sc-модель кибернетической системы}
	\scnitem{ostis-платформа}
\end{scnrelfromset}

\scnheader{sc-модель кибернетической системы}
\begin{scnrelfromset}{обобщенная декомпозиция}
	\scnitem{sc-память}
	\scnitem{sc-модель базы знаний}
	\scnitem{sc-модель решателя задач}
	\scnitem{sc-модель интерфейса кибернетической системы}
\end{scnrelfromset}

\scnheader{sc-память}
\scnidtf{абстрактная sc-память}
\scnidtf{sc-хранилище}
\scnidtf{семантическая память, хранящая конструкции SC-кода}
\scnidtf{хранилище конструкций SC-кода}

\end{SCn}

\textbf{\textit{sc-память}} представляет собой с одной стороны общую среду для хранения \textit{базы знаний}, а с другой стороны -- среду для взаимодействия \textit{sc-агентов}. При этом каждый \textit{sc-агент} опирается при работе на некоторые известные ему \textit{sc-элементы}, хранящиеся в \textit{sc-памяти} (\textit{ключевые sc-элементы} данного \textit{sc-агента}).

В общем случае \textit{sc-память} реализует следующие функции:
\begin{textitemize}
	\item хранение конструкций \textit{SC-кода};
	\item хранение внешних по отношению к \textit{SC-коду} информационных конструкций (файлов). В общем случае хранение файлов может быть реализовано отличным от хранения \textit{sc-конструкций} образом;	
	\item доступ (чтение, создание, удаление) к конструкциям \textit{SC-кода}, реализуемый через соответствующий программный или аппаратный интерфейс. Такой интерфейс по сути представляет собой язык микропрограммирования, позволяющий реализовывать на его основе более сложные процедуры обработки хранимых конструкций, в том числе -- операторы \textit{Языка SCP}, набор которых по сути определяет перечень команд такого языка микропрограммирования. Сама \textit{sc-память} в этом плане является пассивной и просто выполняет команды, инициируемые извне какими-либо субъектами.
\end{textitemize}	

Отметим, что разделение функции хранения и доступа является достаточно условным, поскольку реализовать функцию хранения конструкций без возможности доступа к ним хотя бы на самом низком уровне представляется нецелесообразным, ведь пользоваться таким хранилищем будет невозможно.

Термины ``\textit{sc-память}'' и ``абстрактная sc-память'' являются синонимами в том смысле, что говоря об \textit{sc-памяти} мы подразумеваем некоторую абстракцию, для которой не уточняется ее максимальный объем (максимальное количество \textit{sc-элементов}, которые могут одновременно храниться в такой памяти), конкретный способ хранения \textit{sc-элементов}, средства обеспечения надежности хранения и т.д. Все указанные особенности уточняются на уровне \textit{реализации sc-памяти} в аппаратном варианте или варианте программной модели на базе какой-либо другой архитектуры.

Явное выделение \textit{sc-модели базы знаний}, \textit{sc-модели решателя задач} и \textit{sc-модели интерфейса кибернетической системы} в рамках \textit{sc-модели кибернетической системы} является в известной мере условным, поскольку для обеспечения платформенной независимости \textit{sc-модели кибернетической системы} и \textit{решатель задач}, и \textit{интерфейс системы} описываются средствами \textit{SC-кода} и, таким образом, тоже являются частью \textit{базы знаний}. Такое явное выделение указанных компонентов обусловлено удобством проектирования и сопровождения системы.

Таким образом, при условии строгого разделения \textit{sc-модели кибернетической системы} и \textit{ostis-платформы}, а также обеспечении универсальности \textit{ostis-платформы}, то есть возможности интерпретировать \uline{любую} \textit{sc-модель кибернетической системы} на любом варианте \textit{ostis-платформы}, этап \uline{реализации} \textit{ostis-системы} фактически сводится к загрузке \textit{sc-модели кибернетической системы} на выбранный вариант \textit{ostis-платформы}.

Важно отметить, что универсальность конкретного варианта реализации \textit{ostis-платформы} очевидно ограничивается физической (аппаратной) частью этой реализации. Например, если аппаратная часть выбранного варианта платформы представляет собой обычный персональный компьютер, то без добавления дополнительных аппаратных компонентов система не сможет решать задачи, связанные с физическим перемещением себя и других объектов в пространстве, даже если программная часть системы способна выполнить необходимые расчеты. Говоря другими словами, любая \textit{ostis-платформа} всегда будет ограничена в решении \textit{поведенческих задач} каких-либо классов, какими бы мощными физическими ресурсами она не обладала. Таким образом, корректнее говорить об \uline{универсальности \textit{ostis-платформы} в контексте решения \textit{информационных задач}}, то есть возможности интерпретировать любые \textit{sc-модели кибернетических систем} независимо от того, какого рода \textit{информационные задачи} рещают эти системы. 

Исходя из этого можно сформулировать ключевое требование, предъявляемое к \textit{sc-модели кибернетической системы} -- ни на одном из этапов решения любой \textit{информационной задачи} в данной системе не должны учитываться особенности той платформы, на которой в дальнейшем будет интерпретироваться указанная \textit{sc-модель}. Аналогично ключевым требованием к \textit{ostis-платформе} является обеспечение интерфейса доступа (поиска и преобразования) к хранимой в \textit{sc-памяти} информации некоторым универсальным способом, не зависящим от особенностей реализации конкретной платформы. Таким образом, важнейшей задачей для обеспечения платформенной независимости \textit{ostis-систем} является четкая спецификация требований, предъявляемых к каждой реализации \textit{ostis-платформы}, то есть \uline{стандартизация} \textit{ostis-платформ}. Важно отметить, что такая стандартизация не должна зависеть от того, в каком виде реализуется \textit{ostis-платформа}, и, соответственно, подходить и для аппаратного варианта реализации.

Для уточнения требований, предъявляемых к \textit{ostis-платформе}, введем понятие \textit{sc-машины}, которое является аналогом таких моделей как Машина Поста и Машина Тьюринга (\scncite{TuringMachine}), Машина фон Неймана (\scncite{NeumanMachine}).

\begin{SCn}

\scnheader{sc-машина}
\scnidtf{абстрактная sc-машина}
\scnidtf{обобщение всевозможных реализаций ostis-платформ, для которого задаются общие функциональные требования}
\scnidtf{обобщенная модель, описывающая функционирование любой ostis-платформы независимо от способа ее реализации}
\scnidtf{обобщенная модель, определяющая общие закономерности любой ostis-платформы независимо от способа ее реализации}
\scnidtf{обобщенный информационный образ ostis-платформы}
\scnrelto{обобщенная модель}{ostis-платформа}
\begin{scnrelfromset}{обобщенная декомпозиция}
	\scnitem{sc-память}
	\begin{scnindent}
		\scnrelto{обобщенная модель}{реализация sc-памяти}
	\end{scnindent}
	\scnitem{абстрактная машина обработки знаний}
	\begin{scnindent}
		\scnsubset{абстрактный sc-агент}
	\end{scnindent}
\end{scnrelfromset}
\scnsuperset{scp-машина}
\begin{scnindent}
	\scnrelto{обобщенная модель}{scp-интерпретатор}
	\scnidtf{sc-машина, обеспечивающая интерпретацию базового языка программирования ostis-систем}
	\scnidtf{обобщенная модель интерпретатора базового языка программирования ostis-систем}
	\scnidtf{обобщенная модель, определяющая общие принципы интерпретации базового языка программирования ostis-систем}
	\scnidtf{обобщенная модель операционной семантики базового языка программирования ostis-систем}
\end{scnindent}

\end{SCn}

Потенциально можно говорить о нескольких возможных функционально эквивалентных вариантах \textit{scp-машины}, которые будут соответствовать разным вариантам базового языка программирования.
В рамках текущей версии \textit{Технологии OSTIS} фиксируется как денотационная семантика \textit{Языка SCP}, так и его операционная семантика, реализуемая в виде \textit{Абстрактной scp-машины}. Более подробно об этом говорится в \textit{Главе \ref{chapter_situation_management}~\nameref{chapter_situation_management}}.

Важно подчеркнуть, что несмотря на преимущества платформенно-независимой реализации \textit{ostis-систем} иногда оказывается целесообразным реализовывать некоторые компоненты \textit{ostis-систем} (например, конкретные \textit{sc-агенты} или компоненты пользовательского интерфейса) на уровне \textit{ostis-платформы}. В случае подобной реализации программ \textit{sc-агентов} можно провести аналогию с реализацией каких-либо подпрограмм на уровне языков микропрограммирования для современных компьютеров. Чаще всего целесообразность такого решения обусловлена повышением производительности таких компонентов и системы в целом, поскольку реализация компонента с учетом особенностей платформы в общем случае является более производительной. В то же время заметим, что последнее утверждение не всегда верно, поскольку при реализации компонента на уровне логико-семантической модели может быть реализованы, например, модели параллельной обработки информации, не всегда легко и понятно реализуемые на уровне платформы.

Таким образом, при проектировании каждой конкретной \textit{ostis-системы} разработчику необходимо принимать решение о реализации тех или иных компонентов на платформенно-независимом уровне или уровне платформы. При этом очевидно, что с точки зрения развития технологии и накопления проектного опыта более приоритетной является реализация компонентов \textit{ostis-систем} на платформенно-независимом уровне.

Исходя из сказанного, можно предположить существование \textit{ostis-систем}, в которых все \textit{sc-агенты} реализованы на уровне платформы, которая в таком случае по сути "заточена"{} под конкретную \textit{ostis-систему} и может рассматриваться как аналог специализированного компьютера, ориентированного на решение задач только определенного ограниченного класса. Назовем такой вариант реализации \textit{ostis-систем} \textit{минимальной конфигурацией ostis-системы}. Для того, чтобы \textit{минимальная конфигурация ostis-системы} вообще могла считаться \textit{ostis-системой}, то есть системой, построенной в соответствии с принципами \textit{Технологии OSTIS}, она должна удовлетворять следующему минимальному набору требований:
\begin{textitemize}
	\item использование \textit{SC-кода} как базового языка кодирования информации в базе знаний, и, соответственно, наличие памяти, хранящей конструкции \textit{SC-кода};
	\item наличие \textit{базы знаний}, определяющей денотационную семантику понятий, используемых системой;
	\item наличие хотя бы одного \textit{внутреннего sc-агента}, осуществляющего обработку знаний в памяти \textit{ostis-системы}. Этот \textit{sc-агент} может быть реализован на уровне платформы, соответственно \textit{база знаний} такой системы может не содержать процедурных знаний (методов);
\end{textitemize}

Такой вариант \textit{минимальной конфигурации ostis-системы} обладает только \textit{внутренним sc-агентом} и, соответственно, не имеет возможности общаться с внешним миром (можно сказать, что такая \textit{ostis-система} не обладает "органами чувств"). Для того, чтобы система имела возможность общаться с внешним миром, необходимо добавить к \textit{минимальной конфигурации ostis-системы} хотя бы один \textit{рецепторный sc-агент} и хотя бы один \textit{эффекторный sc-агент}.

Важно отметить, что, как видно из представленного описания \textit{минимальной конфигурации ostis-системы}, в общем случае \textit{ostis-система} не обязана по умолчанию быть \textit{интеллектуальной системой}. Применение \textit{Технологии OSTIS} для разработки компьютерных систем не делает их автоматически интеллектуальными, оно позволяет обеспечить возможность последующей \uline{неограниченной интеллектуализации} таких систем с минимальными накладными расходами при условии соблюдения при их разработке всех принципов \textit{Технологии OSTIS}.

\section{Уточнение понятия ostis-платформы}
\label{sec_interpreter_ostis_platform}

\begin{SCn}
\begin{scnrelfromlist}{ключевое понятие}
	\scnitem{ostis-платформа}
	\scnitem{базовая ostis-платформа}
	\scnitem{расширенная ostis-платформа}
	\scnitem{специализированная ostis-платформа}
	\scnitem{реализация sc-памяти}
	\scnitem{реализация файловой памяти sc-машины}
	\scnitem{scp-интерпретатор}
	\scnitem{базовая подсистема взаимодействия ostis-системы с внешней средой}
	\scnitem{подсистема обеспечения жизнедеятельности ostis-системы}
	\scnitem{специализированная платформенно-зависимая машина обработки знаний}
	\scnitem{минимальная конфигурация ostis-системы}
	\scnitem{однопользовательская ostis-платформа}
	\scnitem{многопользовательская ostis-платформа}
	\scnitem{программный вариант ostis-платформы}
	\scnitem{ассоциативный семантический компьютер}
\end{scnrelfromlist}
\end{SCn}

\begin{SCn}
\scnheader{ostis-платформа}
\scnidtf{платформа интерпретации sc-моделей компьютерных систем}
\scnidtf{интерпретатор sc-моделей кибернетических систем}
\scnidtf{интерпретатор унифицированных логико-семантических моделей компьютерных систем}
\scnidtf{Семейство платформ интерпретации sc-моделей компьютерных систем}
\scnidtf{платформа реализации sc-моделей компьютерных систем}
\scnidtf{встроенная пустая ostis-система}
\scnidtf{реализация sc-машины}
\scnsubset{встроенная ostis-система}
\scnsubset{платформенно-зависимый многократно используемый компонент ostis-систем}
\end{SCn}

Реализация \textit{ostis-платформы} (интерпретатора sc-моделей кибернетических систем) может иметь большое число вариантов -- как программно, так и аппаратно реализованных. При необходимости, в \textbf{\textit{ostis-платформу}} могут быть заранее на платформенно-зависимом уровне включены какие-либо компоненты решателей задач или баз знаний, например, с целью упрощения создания первой версии \textit{прикладной ostis-системы}. Реализация \textit{ostis-платформы} может осуществляться на основе произвольного набора существующих технологий, включая аппаратную реализацию каких-либо ее частей. С точки зрения компонентного подхода любая \textbf{\textit{ostis-платформа}} является \textbf{\textit{платформенно-зависимым многократно используемым компонентом ostis-систем}}.

\begin{SCn}
\scnheader{ostis-платформа}
\begin{scnrelfromset}{разбиение}
	\scnitem{базовая ostis-платформа}
	\begin{scnindent}
		\scnidtf{базовый интерпретатор логико-семантических моделей ostis-систем}
		\scnidtf{минимальная универсальная ostis-платформа, обеспечивающая интерпретацию sc-модели любой \textit{ostis-системы} и включающая интерпретатор базового языка программирования \textit{ostis-систем} (Языка SCP)}
		\scnidtf{универсальный интерпретатор sc-моделей ostis-систем}
		\scnidtf{универсальная базовая ostis-система, обеспечивающая имитацию любой \textit{ostis-системы} путем интерпретации sc-модели имитируемой ostis-системы}
	\end{scnindent}
	\scnitem{расширенная ostis-платформа}
	\begin{scnindent}
		\scnidtf{ostis-платформа, содержащая дополнительные компоненты, реализованные на уровне платформы}
		\scnidtf{базовая ostis-платформа и множество компонентов, реализованных на уровне платформы}
	\end{scnindent}
	\scnitem{специализированная ostis-платформа}
	\begin{scnindent}
		\scnidtf{ostis-платформа, не содержащая реализацию интерпретатора языка SCP}
		\scnidtf{неуниверсальная ostis-платформа}
	\end{scnindent}
\end{scnrelfromset}
\end{SCn}

Понятие \textit{базовой ostis-платформы} является ключевым с точки зрения обеспечения платформенной независимости \textit{ostis-систем}. Универсальность \textit{базовой ostis-платформы} подразумевает возможность интерпретации на ее основе любой \textit{sc-модели кибернетической системы}. Это достигается за счет наличия в рамках \textit{Технологии OSTIS} средств, позволяющих описывать на уровне sc-модели \textit{базу знаний}, \textit{решатель задач} и \textit{интерфейс кибернетической системы}, а также наличия Базового универсального языка программирования для \textit{ostis-систем} (\textit{Языка SCP}). \textit{Язык SCP} в таком случае выступает в роли базового низкоуровневого стандарта (ассемблера) обработки конструкций \textit{SC-кода}, гарантирующего полноту с точки зрения обработки, то есть, обеспечивающего возможность осуществить любое преобразование любого фрагмента \textit{SC-кода} при условии сохранения синтаксической корректности этого фрагмента. Следует отметить, что в общем случае таких функционально эквивалентных ассемблеров может быть несколько (и, как следствие, соответствующих им \textit{scp-машин}), но для обеспечения совместимости в рамках \textit{Технологии OSTIS} один из таких вариантов выбирается в качестве стандарта и описывается в главе \ref{chapter_situation_management}~\nameref{chapter_situation_management}. 

Таким образом, основным и \uline{единственным требованием}, предъявляемым ко всем \textit{базовым ostis-платформам} для обеспечения их универсальности, является необходимость обеспечения интерпретации \textit{Языка SCP}, стандартизированного в рамках \textit{Технологии OSTIS}. При этом важно отметить, что все \textit{базовые ostis-платформы} обязаны быть \uline{функционально эквивалентными}, поскольку интерпретируют один и тот же стандарт \textit{Языка SCP}.

Каждая \textit{базовая ostis-платформа} включает в себя:
\begin{textitemize}
	\item реализацию средств хранения конструкций \textit{SC-кода} (sc-памяти), включая реализацию файловой памяти;
	\item реализацию средств обработки конструкций \textit{SC-кода} -- \textit{scp-интерпретатора};
	\item реализацию базового набора \textit{рецепторных sc-агентов} и \textit{эффекторных sc-агентов}, обеспечивающих минимально необходимый обмен информацией между \textit{ostis-системой} и внешней средой. Конкретный перечень таких агентов требует уточнения, однако можно сказать, что в общем случае они могут быть реализованы как в составе \textit{scp-интерпретатора} (в этом случае им будут соответствовать определенные классы \textit{scp-операторов}), так и отдельно от него в составе платформы.
	\item реализацию набора sc-агентов, обеспечивающих базовые функции \textit{ostis-системы}, связанные с обеспечением ее жизнедеятельности, которые принципиально не могут быть реализованы на платформенно-независимом уровне. К таким функциям относятся, например, запуск системы, загрузка базы знаний в память системы, запуск \textit{scp-интерпретатора} и т.д.
\end{textitemize}

Более формально модель \textit{базовой ostis-платформы} можно записать следующим образом:

\begin{SCn}
\scnheader{базовая ostis-платформа}
\begin{scnrelfromset}{обобщенная декомпозиция}
	\scnitem{реализация sc-памяти}
	\begin{scnindent}
		\scnrelfrom{обобщенная часть}{реализация файловой памяти sc-машины}
	\end{scnindent}
	\scnitem{scp-интерпретатор}
	\scnitem{базовая подсистема взаимодействия \textit{ostis-системы} с внешней средой}
	\scnitem{подсистема обеспечения жизнедеятельности ostis-системы}
\end{scnrelfromset}
\end{SCn}

\textit{расширенная ostis-платформа} представляет собой \textit{базовую ostis-платформу}, дополненную каким-либо множеством компонентов (хотя бы одним), реализованных на уровне платформы, при условии сохранения при этом всех возможностей \textit{базовой ostis-платформы}. Таким образом, \textit{расширенная ostis-платформа} по сути представляет собой \textit{базовую ostis-платформу}, адаптированную для более эффективного решения задач определенных классов в рамках конкретного класса \textit{ostis-систем}. Компонент, реализуемый на уровне платформы, становится частью этой платформы и, таким образом,  преобразует \textit{базовую ostis-платформу} в \textit{расширенную ostis-платформу}. 

Введение понятия \textit{расширенной ostis-платформы} позволяет сформулировать ряд дополнительных принципов реализации \textit{ostis-систем}:
\begin{textitemize}
	\item Может существовать произвольное количество ostis-систем, каждая из которых будет иметь свою уникальную \textit{расширенную ostis-платформу}, но при этом все они будут основаны на одном и том же варианте \textit{базовой ostis-платформы}.
	\item Для каждого варианта \textit{базовой ostis-платформы} может существовать своя \textit{библиотека многократно используемых компонентов ostis-платформ}, совместимых с данным вариантом \textit{базовой ostis-платформы}, и позволяющая компоновать различные варианты \textit{расширенной ostis-платформы} на основе \textit{базовой ostis-платформы}.
\end{textitemize} 

\textbf{\textit{специализированная ostis-платформа}} представляет собой ограниченный вариант реализации \textit{ostis-платформы}, не содержащий \textit{scp-интерпретатора}. Таким образом, \uline{все} \textit{sc-агенты}, в рамках \textit{ostis-системы}, основанной на \textit{специализированной ostis-платформе} должны быть реализованы на платформенно-зависимом уровне. Такая  \textit{специализированная ostis-платформа} является аналогом специализированного компьютера, реализованного для конкретной компьютерной системы. Таким образом, в общем случае каждая \textit{ostis-система}, реализуемая на \textit{специализированной ostis-платформе} будет иметь свою \uline{уникальную} \textit{специализированную ostis-платформу}.

\textbf{\textit{специализированная ostis-платформа}} может быть получена из \textit{базовой ostis-платформы} путем исключения из нее реализации  \textit{scp-интерпретатора} и реализации всех необходимых \textit{sc-агентов} на уровне платформы (или заимствования всех или части агентов из соответствующей данному варианту \textit{базовой ostis-платформы} \textit{библиотеки многократно используемых компонентов ostis-платформ}).

\begin{SCn}
\scnheader{специализированная ostis-платформа}
\begin{scnrelfromset}{обобщенная декомпозиция}
	\scnitem{реализация sc-памяти}
	\begin{scnindent}
		\scnrelfrom{обобщенная часть}{реализация файловой памяти sc-машины}
	\end{scnindent}
	\scnitem{базовая подсистема взаимодействия ostis-системы с внешней средой}
	\scnitem{подсистема обеспечения жизнедеятельности ostis-системы}
	\scnitem{специализированная платформенно-зависимая машина обработки знаний}
	\begin{scnindent}
		\scnidtf{sc-агент, как правило неатомарный, обеспечивающий выполнение всех функций некоторой специализированной ostis-платформы, связанных с обработкой знаний}
		\scnsubset{платформенно-зависимый sc-агент}
	\end{scnindent}
\end{scnrelfromset}
\end{SCn}

Введенное ранее понятие \textit{минимальной конфигурации ostis-системы} может быть уточнено с учетом понятия \textit{специализированной ostis-платформы}.

\begin{SCn}
\scnheader{минимальная конфигурация ostis-системы}
\begin{scnrelfromset}{обобщенная декомпозиция}
	\scnitem{sc-модель базы знаний}
	\scnitem{специализированная ostis-платформа}
\end{scnrelfromset}
\end{SCn}

Применение \textit{специализированных ostis-платформ} может быть целесообразным на стартовом этапе развития \textit{Технологии OSTIS}, а также с целью повышения производительности конкретных наиболее высоконагруженных \textit{ostis-систем}, однако активное развитие таких \textit{специализированных ostis-платформ} и их компонентов с точки зрения \textit{Технологии OSTIS} является нецелесообразным, поскольку:
\begin{textitemize}
	\item если какой-либо компонент разработан с ориентацией на конкретную платформу, то нет гарантий возможности его повторного использования в других вариантах реализации \textit{ostis-платформы} (как минимум, компоненты, разработанные для \textit{программного варианта реализации ostis-платформы} не смогут быть использованы в рамках \textit{ассоциативного семантического компьютера});
	\item наличие большого числа платформенно-зависимых компонентов требует развития и сопровождения отдельной инфраструктуры библиотек для хранения и повторного использования таких компонентов. Чем больше будет вариантов \textit{ostis-платформ} и чем больше будет число платформенно-зависимых компонентов, тем более сложной и громоздкой будет такая инфраструктура. Как минимум, необходимо будет отслеживать совместимость компонентов с разными версиями разных вариантов реализации \textit{ostis-платформ};
	\item изменения в \textit{специализированной ostis-платформе}, например, связанные с переходом на более новую и эффективную версию \textit{базовой ostis-платформы}, на основе которой построена данная \textit{специализированная ostis-платформа} в общем случае могут привести к необходимости внесения изменений в компоненты, зависящие от данного варианта реализации \textit{ostis-платформы}. Чем больше таких платформенно-зависимых компонентов, тем больше потенциальных изменений может потребоваться и, соответственно, тем сложнее будет осуществляться эволюция платформы при условии сохранения работоспособности \textit{ostis-систем}, в которых она используется.
\end{textitemize} 

Перечисленные тезисы справедливы и для \textit{расширенных ostis-платформ}, однако в случае \textit{расширенной ostis-платформы} проблемы, связанные с переходом на более новую версию платформы и изменениями в соответствующих компонентах всегда могут быть решены путем временной замены платформенно-зависимых компонентов на их платформенно-независимые версии с соответствующим снижением производительности, но зато сохранением функциональной целостности системы.

\begin{SCn}
\scnheader{ostis-платформа}
\begin{scnrelfromset}{разбиение}
	\scnitem{однопользовательская ostis-платформа}
	\begin{scnindent}
		\scnidtf{вариант реализации платформы интерпретации sc-моделей компьютерных систем, рассчитанный на то, что с конкретной \textit{ostis-системой} взаимодействует только один пользователь (владелец)}
	\end{scnindent}
	\scnitem{многопользовательская ostis-платформа}
	\begin{scnindent}
		\scnidtf{вариант реализации платформы интерпретации sc-моделей компьютерных систем, рассчитанный на то, что с конкретной \textit{ostis-системой} одновременно или в разное время могут взаимодействовать разные пользователи, в общем случае обладающие разными правами, сферами ответственности, уровнем опыта, и имеющие свою конфиденциальную часть хранимой в базе знаний информации}
	\end{scnindent}
\end{scnrelfromset}
\end{SCn}

При однопользовательском варианте реализации платформы оказывается невозможным реализовать некоторые важные принципы \textit{Технологии OSTIS}, например, коллективную согласованную разработку базы знаний системы в процессе ее эксплуатации. При этом могут использоваться различные сторонние средства, например для разработки базы знаний на уровне исходных текстов.

\begin{SCn}
\scnheader{ostis-платформа}
\begin{scnrelfromset}{разбиение}
	\scnitem{программный вариант ostis-платформы}
	\begin{scnindent}
		\scnidtf{платформа интерпретации sc-моделей ostis-систем, реализованная в виде программной системы на базе традиционной компьютерной архитектуры}
		\scnidtf{программная платформа интерпретации sc-моделей ostis-систем}
		\scnidtf{программный интерпретатор sc-моделей ostis-систем}
	\end{scnindent}
	\scnitem{ассоциативный семантический компьютер}
	\begin{scnindent}
		\scnidtf{аппаратная платформа интерпретации sc-моделей ostis-систем}
		\scnidtf{аппаратно реализованный базовый интерпретатор sc-моделей ostis-систем}
	\end{scnindent}
\end{scnrelfromset}
\end{SCn}

Важно отметить, что в любом варианте реализации \textit{ostis-платформы} всегда присутствует как программная, так и аппаратная часть. Так, любой \textit{программный вариант ostis-платформы} предполагает его последующую интерпретацию на какой-либо аппаратной основе, например, на персональном компьютере с традиционной архитектурой. В то же время, разработка \textit{ostis-платформы} в виде \textit{ассоциативного семантического компьютера} предполагает разработку набора микропрограмм, реализующих базовые операции поиска и преобразования sc-конструкций, хранящихся в \textit{sc-памяти}. 

Таким образом, разделение множества возможных реализаций \textit{ostis-платформы} на программный и аппаратный варианты скорее отражает вариант аппаратной архитектуры, на которую в конечном итоге ориентирован тот или иной вариант реализации платформы -- либо на традиционную фон-неймановскую архитектуру, либо на специализированную архитектуру \textit{ассоциативного семантического компьютера} со структурно-перестраиваемой (графодинамической) памятью. \textit{Программный вариант ostis-платформы} по сути является моделью (виртуальной машиной) \textit{ассоциативного семантического компьютера}, построенной на базе традиционной фон-неймановской архитектуры, а \textit{Язык SCP} выступает в роли ассемблера для \textit{ассоциативного семантического компьютера} и также может интерпретироваться как в рамках аппаратной реализации такого компьютера, так и в рамках его программной модели. 

Целесообразность разработки \textit{программных вариантов ostis-платформы} на настоящий момент обусловлена очевидной распространенностью фон-неймановской архитектуры и, соответственно, необходимостью реализации \textit{ostis-систем} на современных компьютерах различного вида. В то же время очевидно, что разработка специализированных \textit{ассоциативных семантических компьютеров} позволит существенно повысить эффективность работы \textit{ostis-систем}, а четкое разделение \textit{sc-модели кибернетической системы} и платформы ее интерпретации позволит осуществить перевод уже работающих \textit{ostis-систем} с традиционных архитектур на \textit{ассоциативные семантические компьютеры} с минимальными накладными расходами.

Каждой конкретной \textit{ostis-системе} однозначно соответствует конкретная \textit{ostis-платформа}, которая может относиться к разному набору классов \textit{ostis-платформ}. В тоже время очевидно, что на этапе разработки платформы проектируется и реализуется некоторый вариант \textit{ostis-платформы}, который затем тиражируется в разные \textit{ostis-системы}. Впоследствии в каждой \textit{ostis-системе} в этот вариант \textit{ostis-платформы} могут быть внесены изменения, но в общем случае в большом количестве \textit{ostis-систем} могут использоваться полностью эквивалентные \textit{ostis-платформы}. Таким образом, целесообразно говорить о \textit{типовых ostis-платформах}, которые:
\begin{textitemize}
	\item являются объектом разработки для разработчиков \textit{ostis-платформ};
	\item \textit{являются многократно используемым компонентом ostis-систем} и специфицируются в рамках соответствующих библиотек;
	\item являются образцом для тиражирования (копирования) при создании новых \textit{ostis-систем}.
\end{textitemize}
		
\section*{Заключение к Главе~\ref{chapter_interpreter}}
		
В данной главе рассмотрены современные проблемы в области обеспечения платформенной независимости \textit{компьютерных систем} в целом, а также особенности обеспечения платформенной независимости \textit{интеллектуальных компьютерных систем}. Предложен подход к решения указанных проблем путем преобразования современных компьютерных систем в \textit{ostis-системы}, для которых решение данной проблемы значительно упрощается благодаря принципам, лежащим в основе \textit{Технологии OSTIS}.

Детально рассмотрены принципы обеспечения платформенной независимости ostis-систем, уточнено понятие ostis-платформы, их классификация и архитектура.
		
%\input{author/references}