\chapauthor{Шункевич Д.В.}
\chapter{Универсальная модель интерпретатора внутренних агентов решателя задач интеллектуальной компьютерной системы нового поколения}
\chapauthortoc{Шункевич Д.В.}
\label{chapter_interpreter}

\abstract{Аннотация к главе.}

\section{Методы и средства реализации ostis-систем}

В общем случае разработка любой искусственной системы, в частности, \textit{интеллектуальной компьютерной системы}, предполагает выполнение:
\begin{itemize}
\item этапа проектирования, то есть построения формальной модели системы, достаточной для понимания принципов ее устройства и выполнения последующего этапа ее реализации. Результатом данного этапа является некоторая формальная модель системы, иначе называемая \textit{проектом};
\item этапа реализации, то есть непосредственно воплощения разработанной модели с использованием конкретных средств (инструментов, материалов, комплектующих и т.д.). В случае компьютерных систем выполнение данного этапа обычно предполагает выбор конкретных языков программирования, библиотек, сторонних средств, таких как СУБД и различные сервисы и т.д., а также собственно программирование и отладку системы с использованием выбранных средств.
\end{itemize}

Для каждого из указанных этапов могут существовать свои методики, а также средства автоматизации соответствующих процессов.

Рассмотрим предлагаемый подход к организации реализации ostis-систем. Одним из ключевых принципов предлагаемой нами Технологии OSTIS является обеспечение платформенной независимости ostis-систем, то есть строгое разделение логико-семантическая модели кибернетической системы (\textit{sc-модели кибернетической системы}) и платформы интерпретации sc-моделей кибернетических системы (\textit{платформы OSTIS}). 

%TODO сказать зачем это надо, что дает

Рассмотрим более детально понятие \textit{логико-семантической модели кибернетической системы}.

\begin{SCn}
\scnheader{логико-семантическая модель кибернетической системы}
\scnidtf{формальная модель (формальное описание) функционирования кибернетической системы, состоящая из (1) формальной модели информации, хранимой в памяти кибернетической системы и (2) формальной модели коллектива агентов, осуществляющих обработку указанной информации.}
\scnsuperset{sc-модель кибернетической системы}
\begin{scnindent}
	\scnidtf{логико-семантическая модель кибернетической системы, представленная в SC-коде}
	\scnidtf{логико-семантическая модель ostis-системы, которая, в частности, может быть функционально эквивалентной моделью какой-либо кибернетической системы, не являющейся ostis-системой}
\end{scnindent}

\scnheader{кибернетическая система}
\scnsuperset{компьютерная система}
\begin{scnindent}
	\scnidtf{искусственная кибернетическая система}
	\scnsuperset{ostis-система}
	\begin{scnindent}
		\scnidtf{компьютерная система, построенная по Технологии OSTIS на основе интерпретации спроектированной логико-семантической sc-модели этой системы}
	\end{scnindent}
\end{scnindent}

\scnheader{ostis-система}
\begin{scnrelfromset}{базовая декомпозиция}
	\scnitem{sc-модель кибернетической системы}
	\scnitem{платформа OSTIS}
\end{scnrelfromset}

\scnheader{sc-модель кибернетической системы}
\begin{scnrelfromset}{базовая декомпозиция}
	\scnitem{sc-память}
	\scnitem{sc-модель базы знаний}
	\scnitem{sc-модель решателя задач}
	\scnitem{sc-модель интерфейса кибернетической системы}
\end{scnrelfromset}

\scnheader{sc-память}
\scnidtf{абстрактная sc-память}
\scnidtf{семантическая память, хранящая конструкции SC-кода}

\end{SCn}

Sc-память представляет собой с одной стороны общую среду для хранения знаний из базы знаний, а с другой стороны -- среду для взаимодействия sc-агентов. При этом каждый sc-агент опирается при работе на некоторые известные ему sc-элементы, хранящиеся в этой памяти (\textit{ключевые sc-элементы} данного sc-агента).

Явное выделение в рамках \textit{sc-модели кибернетической системы} \textit{sc-модели базы знаний}, \textit{sc-модели решателя задач} и \textit{sc-модели интерфейса кибернетической системы} является в известной мере условным, поскольку для обеспечения платформенной независимости \textit{sc-модели кибернетической системы} и решатель задач и интерфейс системы описываются средствами SC-кода и, таким образом, тоже являются частью базы знаний. Такое явное выделение указанных компонентов обусловлено исключительно удобством проектирования и сопровождения системы.

При условии строгого разделения \textit{sc-модели кибернетической системы} и \textit{платформы OSTIS}, а также обеспечении универсальности \textit{платформы OSTIS}, то есть возможности интерпретировать любую \textit{sc-модель кибернетической системы} на любом варианте \textit{платформы OSTIS}, этап реализации ostis-системы фактически сводится к загрузке \textit{sc-модели кибернетической системы} на выбранный вариант \textit{платформы OSTIS}.

Важно отметить, что универсальность конкретного варианта реализации \textit{платформы OSTIS} очевидно ограничивается физической (аппаратной) частью этой реализации. Например, если аппаратная часть выбранного варианта платформы представляет собой обычный персональный компьютер, то без добавления дополнительных аппаратных компонентов система не сможет решать задачи, связанные с физическим перемещением себя и других объектов в пространстве, даже если программная часть систем способна выполнить необходимые расчеты. Говоря другими словами, любая \textit{платформа OSTIS} всегда будет ограничена в решении \textit{поведенческих задач} каких-либо классов, какими бы мощными физическими ресурсами она не обладала. Таким образом, корректнее говорить об \uline{универсальности \textit{платформы OSTIS} в контексте решения \textit{информационных задач}}, то есть возможности интерпретировать любые \textit{sc-модели кибернетических систем} независимо от того, какого рода \textit{информационные задачи} рещают эти системы. 

Исходя из этого можно сформулировать ключевое требование, предъявляемое к \textit{sc-модели кибернетической системы} -- ни на одном из этапов решения любой \textit{информационной задачи} в данной системе не должны учитываться особенности той платформы, на которой в дальнейшем будет интерпретироваться указанная sc-модель. Аналогично ключевым требованием к \textit{платформе OSTIS} является обеспечение интерфейса доступа (поиска и преобразования) к хранимой в sc-памяти информации некоторым универсальным способом, не зависящим от особенностей реализации конкретной платформы.

Таким образом, важнейшей задачей для обеспечения платформенной независимости ostis-систем является разработка достаточно детального и четкого набора требований, предъявляемых к каждой реализации \textit{платформы OSTIS}.

\section{Базовые интерпретаторы логико-семантических моделей ostis-систем}

%TODO Обоснование из доктороской Голенкова и докторской Шункевича

%TODO сказать, что всегда есть аппаратная часть и программная часть.

\begin{SCn}
\scnheader{платформа OSTIS}
\scnidtf{платформа интерпретации sc-моделей компьютерных систем}
\scnidtf{базовый интерпретатор логико-семантических моделей ostis-систем}
\scnidtf{Семейство платформ интерпретации sc-моделей компьютерных систем}
\scnidtf{платформа реализации sc-моделей компьютерных систем}
\scnidtftext{часто используемый sc-идентификатор}{универсальный интерпретатор sc-моделей компьютерных систем}
\scnidtf{универсальный интерпретатор унифицированных логико-семантических моделей компьютерных систем}
\scnsubset{встроенная ostis-система}
\scnidtf{встроенная пустая ostis-система}
\scnidtf{универсальный интерпретатор sc-моделей ostis-систем}
\scnidtf{универсальная базовая ostis-система, обеспечивающая имитацию любой ostis-системы путем интерпретации sc-модели имитируемой ostis-системы}
\end{SCn}

Реализация \textit{платформы интерпретации sc-моделей компьютерных систем} (\textit{универсального интерпретатора sc-моделей компьютерных систем}) может иметь большое число вариантов -- как программно, так и аппаратно реализованных. Логическая архитектура \textit{платформы интерпретации sc-моделей компьютерных систем} обеспечивает независимость проектируемых компьютерных систем от многообразия вариантов реализации интерпретатора их моделей и в общем случае включает в себя:

\begin{itemize}
	\item хранилище \textit{sc-текстов} (\textit{sc-хранилище}, хранилище знаковых конструкций, представленных SC-коде);
	\item файловую память \textit{sc-машины};
	\item средства, обеспечивающие взаимодействие \textit{sc-агентов} над общей памятью (sc-памятью);
	\item базовые средства интерфейса для взаимодействия системы с внешним миром (пользователем или другими системами). Указанные средства включают в себя, как минимум, редактор, транслятор (в sc-память и из нее) и визуализатор для одного из базовых универсальных вариантов представления \textit{SC-кода} (\textit{SCg-код}, \textit{SCs-код}, \textit{SCn-код}), средства, позволяющие задавать системе вопросы из некоторого универсального класса (например, запрос семантической окрестности некоторого объекта);
	\item реализацию \textit{Абстрактной scp-машины}, то есть интерпретатор \textit{scp-программ} (программ Языка SCP).
\end{itemize}

При необходимости, в \textbf{\textit{платформу интерпретации sc-моделей компьютерных систем}} могут быть заранее на платформенно-зависимом уровне включены какие-либо компоненты машин обработки знаний или баз знаний, например, с целью упрощения создания первой версии \textit{прикладной ostis-системы}.

Реализация платформы может осуществляться на основе произвольного набора существующих технологий, включая аппаратную реализацию каких-либо ее частей. С точки зрения компонентного подхода любая \textbf{\textit{платформа интерпретации sc-моделей компьютерных систем}} является \textbf{\textit{платформенно-зависимым многократно используемым компонентом}}.

\begin{SCn}
\scnheader{платформа интерпретации sc-моделей компьютерных систем}
\begin{scnrelfromset}{разбиение}
\scnitem{однопользовательский вариант реализации платформы интерпретации sc-моделей компьютерных систем}
\begin{scnindent}
\scnidtf{вариант реализации платформы интерпретации sc-моделей компьютерных систем, рассчитанный на то, что с конкретной ostis-системой взаимодействует только один пользователь (владелец)}
\end{scnindent}
\scnitem{многопользовательский вариант реализации платформы интерпретации sc-моделей компьютерных систем}
\begin{scnindent}
\scnidtf{вариант реализации платформы интерпретации sc-моделей компьютерных систем, рассчитанный на то, что с конкретной ostis-системой одновременно или в разное время могут взаимодействовать разные пользователи, в общем случае обладающие разными правами, сферами ответственности, уровнем опыта, и имеющие свою конфиденциальную часть хранимой в базе знаний информации}
\end{scnindent}
\end{scnrelfromset}
\end{SCn}

При однопользовательском варианте реализации платформы оказывается невозможным реализовать некоторые важные принципы \textit{Технологии OSTIS}, например, коллективную согласованную разработку базы знаний системы в процессе ее эксплуатации. При этом могут использоваться различные сторонние средства, например для разработки базы знаний на уровне исходных текстов.

\begin{SCn}
\scnheader{платформа интерпретации sc-моделей компьютерных систем}
\begin{scnrelfromset}{разбиение}
	\scnitem{программный вариант реализации платформы интерпретации sc-моделей компьютерных систем}
	\begin{scnindent}
		\scnidtf{программная платформа интерпретации sc-моделей ostis-систем}
		\scnidtf{программный базовый интерпретатор sc-моделей ostis-систем}
	\end{scnindent}
	\scnitem{семантический ассоциативный компьютер}
	\begin{scnindent}
		\scnidtf{аппаратная платформа интерпретации sc-моделей ostis-систем}
		\scnidtf{аппаратно реализованный базовый интерпретатор sc-моделей ostis-систем}
	\end{scnindent}
\end{scnrelfromset}
\end{SCn}

\section{Ассоциативные семантические компьютеры для ostis-систем}

Основной целью создания семантических ассоциативных компьютеров
является повышение производительности компьютерных систем, основанных на знаниях, представленных в виде семантических сетей.

\begin{SCn}
\scnheader{семантический ассоциативный компьютер}
\scnidtf{аппаратно реализованный интерпретатор семантических моделей (sc-моделей) компьютерных систем}
\scnidtf{семантический ассоциативный компьютер, управляемый знаниями}
\scnidtf{компьютер с нелинейной структурно перестраиваемой (графодинамической) ассоциативной памятью, переработка информации в которой сводится не к изменению состояния элементов памяти, а к изменению конфигурации связей между ними}
\scnidtf{sc-компьютер}
\scnidtf{scp-компьютер}
\scnidtf{универсальный компьютер нового поколения, специально предназначенный для реализации семантически совместимых гибридных интеллектуальных компьютерных систем}
\scnidtf{универсальный компьютер нового поколения, ориентированный на аппаратную интерпретацию логико-семантических моделей интеллектуальных компьютерных систем}
\scnidtf{универсальный компьютер нового поколения, ориентированный на аппаратную интерпретацию ostis-систем}
\scnidtf{ostis-компьютер}
\scnidtf{компьютер для реализации ostis-систем}
\scnidtf{компьютер, управляемый знаниями, представленными в SC-коде}
\scnidtf{компьютер, ориентированный на обработку текстов SC-кода}
\end{SCn}

Рассмотрим принципы, лежащие в основе реализации семантических ассоциативных компьютеров:
\begin{itemize}
	\item нелинейная память -- каждый элементарный фрагмент хранимого в памяти текста может быть инцидентен неограниченному числу других элементарных фрагментов этого текста;
	\item структурно перестраиваемая (реконфигурируемая) память -- процесс отработки хранимой в памяти информации сводится не только к изменению состояния элементов, но и к реконфигурации связей между ними;
	\item в качестве внутреннего способа кодирования знаний, хранимых в памяти семантического ассоциативного компьютера, используется универсальный (!) способ нелинейного (графоподобного) смыслового представления знаний, названный нами SC-кодом (семантическим, смысловым компьютерным кодом);
	\item обработка информации осуществляется коллективом агентов, работающих над общей памятью. Каждый из них реагирует на соответствующую ему ситуацию или событие в памяти (компьютер, управляемый хранимыми знаниями);
	\item есть программно реализуемые агенты, поведение которых описывается хранимыми в памяти агентно-ориентированными программами, которые интерпретируются соответствующими коллективами агентов;
	\item есть базовые агенты, которые не могут быть реализованы программно (в частности, это агенты интерпретации агентных программ, базовые рецепторные агенты-датчики, базовые эффекторные агенты);
	\item все агенты работают над общей памятью одновременно. Более того, если для какого-либо агента в некоторый момент времени в различных частях памяти возникает сразу несколько условий его применения, разные акты указанного агента в разных частях памяти могут выполняться одновременно (акт агента -- это неделимый, целостный процесс деятельности агента);
	\item для того, чтобы акты агентов, параллельно выполняемые в общей памяти не "мешали"{} друг другу, для каждого акта в памяти фиксируется и постоянно актуализируется его текущее состояние. То есть каждый акт сообщает всем остальным о своих намерениях и пожеланиях, которым остальные агенты не должны препятствовать (например, это различного рода блокировки используемых элементов семантической памяти);
	\item кроме того, агенты (точнее, выполняемые ими акты) должны соблюдать "этику"{}, стараясь не в ущерб себе создавать максимально благоприятные условия для других агентов (актов), например, не жадничать, быстрее возвращать, не захватывать (не блокировать) лишние элементы памяти, как можно скорее освобождать (деблокировать) заблокированные элементы памяти;
	\item процессор и память семантического ассоциативного компьютера глубоко интегрированы и составляют единую процессоро-память. Процессор семантического ассоциативного компьютера равномерно "распределен"{} по его памяти так, что процессорные элементы одновременно являются и элементами памяти компьютера. Обработка информации в семантическом ассоциативном компьютере сводится к реконфигурации каналов связи между процессорными элементами,  следовательно память такого компьютера есть не что иное, как \uline{коммутатор} (!) указанных каналов связи. Таким образом, текущее состояние конфигурации этих каналов связи и есть текущее состояние обрабатываемой информации.
\end{itemize}

Традиционная архитектура компьютерных систем не позволяет эффективно использовать сложно-структурированные знания в реальном масштабе времени.
	
Решение проблемы функционирования компьютерных систем обработки знаний в реальном масштабе времени трудно достижимо без использования принципов параллельной обработки и ассоциативного доступа к структурам данных. Разработка подобных систем чрезвычайно трудоемка, поэтому для обеспечения ее экономической целесообразности жизненный цикл функционирования подобных систем должен быть достаточно продолжительным (от десятка лет и более). Сменяемость аппаратных и программных средств вычислительной техники в настоящее время достигает от нескольких лет до нескольких месяцев. Это обуславливает необходимость наличия у \textit{интеллектуальных компьютерных систем} таких качеств, как:
\begin{itemize}
	\item открытость (в плане модифицируемости и добавления новых методов представления и переработки знаний);
	\item интегрируемость (в смысле возможности функционирования в составе комплексов различных вычислительных и исполнительных средств).
\end{itemize}	   
Анализ современных систем обработки знаний показывает, что ни одна из архитектур, на базе которых они реализованы, не обладает в совокупности всеми указанными выше свойствами.
	
Особенности логической организации вычислительных систем, которые существенно затрудняют создание машин переработки знаний на основе традиционных ЭВМ:
\begin{itemize}
	\item последовательная обработка, ограничивающая эффективность ЭВМ физическими возможностями элементной базы;
	\item низкий уровень доступа к памяти, т.е. сложность и громоздкость выполнения процедуры ассоциативного поиска нужного фрагмента знаний. 
	\item линейная организация памяти и чрезвычайно простой вид конструктивных объектов, непосредственно хранимых в памяти. Это приводит к тому, что в интеллектуальных системах, построенных на базе современных ЭВМ, манипулирование знаниями осуществляется с большим трудом. Во-первых, приходится оперировать не самими структурами, а их громоздкими линейными представлениями (списками, матрицами смежности, матрицами инцидентности); во-вторых, линеаризация сложных структур разрушает локальность их преобразований;
	\item представление информации в памяти современных ЭВМ имеет уровень весьма далекий от семантического, что делает переработку знаний довольно громоздкой, требующей учета большого количества деталей, касающейся не смысла перерабатываемой информации, а способа ее представления в памяти;
	\item в современных ЭВМ имеет место весьма низкий уровень аппаратно реализуемых операций над нечисловыми данными и полностью отсутствует аппаратная поддержка логических операций над фрагментами знаний, имеющих сложную структуру, что делает манипулирование такими фрагментами весьма сложным.
\end{itemize}
	
Основным проявлением перечисленных недостатков традиционных ЭВМ является гипертрофированное развитие программного обеспечения, сложность его создания и невысокая надежность.

Трудности, связанные с использованием универсальных многопроцессорных ЭВМ, послужили толчком к развитию теоретических исследований в области параллельного программирования.
	
\textit{SC-код} изначально разрабатывался как язык кодирования информации в памяти \textit{семантических ассоциативных компьютеров}, таким образом в нем изначально заложены такие принципы, как универсальность (возможность представить знания любого рода) и унификация (единообразие) представления, а также минимизацию \textit{Алфавита SC-кода}, которая, в свою очередь, позволяет облегчить создание аппаратной платформы, позволяющей хранить и обрабатывать тексты \textit{SC-кода}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{SCn}
\scnheader{информационно-логическая задача}
\scnidtf{информационно-логическая или комбинаторная задачи по переработке сложноструктурированных баз данных}
\scnidtf{класс задач, предполагающих переработку нечисловой сложноструктурированной информации и допускающих при этом отсутствие точного алгоритма их решения}
\end{SCn}

Понятие \textit{информационно-логических задач} фактически совпадает по смыслу с широко используемым в последнее время понятием задач искусственного интеллекта (\textit{интеллектуальных задач}), что позволяет использовать оба эти термина.

Разработка средств решения задач того или иного класса в настоящее время обычно осуществляется путем создания \textit{языка программирования высокого уровня}, ориентированного на этот класс задач, и путем реализации такого языка на современных компьютерах, т.е. путем создания транслятора. Поскольку логика решения задач искусственного интеллекта плохо согласуется с современными языками программирования, более целесообразной является разработка принципиально новых языков, отражающих на уровне их элементарных операций основные логические механизмы решения задач рассматриваемого класса. Такие языки программирования обычно называют языками сверх-высокого уровня или непроцедурными языками. Реализация языков сверх-высокого уровня на современных компьютерах представляется весьма сложной в силу большого разрыва между языками этого класса и внутренними языками современных компьютеров, для преодоления которого создание эффективного транслятора оказывается практически невозможным.

Таким образом, состояние проблемы автоматизации решения задач искусственного интеллекта (информационно-логических задач) в настоящее время можно охарактеризовать тем, что эта проблема входит в противоречие c принципами логической организации современных компьютеров и, в первую очередь, с используемыми в современных компьютерах внутренними языками. 
	
Причины плохой приспособленности современных компьютеров к решению информационно-логических задач:
\begin{itemize}
	\item в современных компьютерах при работе со сложноструктурированными базами данных время, затрачиваемое на информационный поиск, на 2-3 порядка превышает время, затрачиваемое на собственно переработку;
	\item в современных компьютерах имеет место весьма низкий уровень аппаратно реализуемых операций над нечисловыми данными;
	\item представление информации в памяти современных компьютеров имеет уровень весьма далекий от семантического, что делает переработку информации довольно громоздкой, требующей учета большого количества деталей, касающихся не смысла перерабатываемой информации, a способа ее представления в памяти;
	\item в современных компьютерах громоздко реализуются даже простейшие процедуры логического вывода.
\end{itemize}
	
Перечисленные причины, по существу, не устраняются также и в развиваемых в настоящее время подходах к построению нетрадиционных высокопроизводительных компьтеров, ибо, в основном, все эти подходы (даже если они достаточно далеко отходят от предложенных фон Нейманом принципов организации вычислительных машин) неявно сохраняют точку зрения на компьютер как на большой арифмометр и тем самым сохраняют ее ориентацию на задачи числового характера. Очевидно, что эффективность этих машин будет прежде всего определяться степенью близости их внутреннего языка к языкам непроцецурного типа (к языкам сверх-высокого уровня). Учитывая указанное назначение таких машин, их естественно назвать не вычислительными машинами, a математическими машинами или даже "мыслящими"{} машинами.

\begin{SCn}
\scnheader{машина, ориентированная на решение информационно-логических задач}
\scnrelfrom{класс решаемых задач}{информационно-логическая задача}
\scnidtf{машина, реализующая стремление так организовать процесс переработки информации, чтобы он был наиболее близок к семантическому (содержательному) уровню}
\end{SCn}

Задачи разработки машин, ориентированных на решение информационно-логических задач:

\begin{itemize}
	\item разработка семантического способа представления перерабатываемой информации в памяти машины;
	\item разработка такого внутреннего языка, запись программ на котором была бы максимально близка к тому, что называют записью алгоритма на содержательном уровне;
	\item разработка и исследование способов семантического представления информации различного вида;
	\item разработка и исследование принципов организации развитой ассоциативной памяти для непосредственного хранения семантического представления информации;
	\item разработка и исследование языка программирования высокого уровня, который (I) ориентирован на решение информационно-логических задач; (2) обеспечивает непосредственную реализацию простых процедур логического вывода. (3) согласован c выбранным способом семантического представления перерабатываемой информации, (4) приспособлен к использованию в качестве внутреннего языкё параллельной однородной структуры, имеющей распределенную ассоциативную память для хранения сложноструктурированных данных;
	\item разработка и исследование принципов построения и принципов параллельного взаимодействия функциональных средств, обеспечивающих непосредственную переработку семантического представления информации в распределенной ассоциативной памяти и реализующих управление потоком словноструктурированных данных;
	\item экспериментальная проверка полученных результатов
\end{itemize}

Исследования по системам искусственного интеллекта убедительно показали, что способ представления знаний в их памяти, точнее степень его близости к семантическому, является фактором, во многом определяющим эффективность таких систем.

Принципы построения машин, ориентированных на решение информационно-логических задач:
\begin{itemize}
	\item такие машины целесообразно строить как машины, манипулирующие графовыми структурами непосредственно на физическом уровне. Предполагается создание структурно-перестраиваемой ("графовой") памяти. Такая память состоит из ячеек, однозначно соответствующих вершинам хранимого в памяти графа, но, в отличие от обычной памяти, эти ячейки связываются не фиксированными условными связями, задающими фиксированную последовательность (порядок) ячеек в памяти, a реально (физически) проводимыми связями произвольной конфигурации. Эти связи соответствуют дугам, ребрам, гиперребрам записанного в памяти графа. Очевидно, что в ходе переработки информации в структурно-перестраиваемой памяти меняются на только и даже не столько состояния ячеек памяти, как это имеет место в обычной памяти, сколько конфигурация связей между этими ячейками. Т.е. в структурно-перестраиваемой памяти в ходе переработки информации не только перераспределяются метки на вершинах записанного в памяти графа, но и меняется структура самого этого графа.;
	\item в качестве внутреннего языка таких машин целесообразно использовать язык типа PROLOG. Разработка языка типа PROLOG, предназначенного к использованию в качестве внутреннего языка программирования для машин co структурно-перестраиваемой памятью требует решения нетривиальной задачи согласования графового способа представления данных в структурно-перестраиваемой памяти и способа записи в этой же памяти самих программ, описывающих переработку этих данных. Переход на "графовый" способ кодирования программ и данных в структурно-перестраиваемой памяти обеспечивает компактность их представления и существенно упрощает аппаратурную реализацию операций над сложными структурами. Говоря об аппаратурной интерпретации языка типа PROLOG, необходимо подчеркнуть следующее. На уровне любого языка типа PROLOG, т.е. на уровне абстрактной PROLOG -- машины, естественным образом реализуется эффективное распараллеливание процесса переработки сложных структур, организованное по принципу управления потоком запросов или управления потоком перерабатываемых сложноструктурированных данных. Управление потоком сложноструктурированных данных при этом основывается на использовании развитой формы ассоциативного доступа, a именно, доступа к произвольному фрагменту перерабатываемых данных (фрагменту, имеющему произвольный размер и произвольную структуру). Из вышесказанного следует, что создание машины, аппаратурно интерпретирующей язык типа PROLOG, есть не что иное, как создание параллельной машины, управляемой потоком сложноструктурированных данных и имеющей развитую ассоциативную память.
	\item принцип организации переработки информации непосредственно в памяти. Этот принцип обеспечивает значительное ускорение переработки информации благодаря исключению этапов передачи информации из памяти в процессор и обратно, но оплачивается ценой большой избыточности функциональных (процессорных; средств, равномерно распределяемых по памяти. При распределении функциональных средств по структурно-перестраиваемой памяти каждая ячейка дополняется функциональным (процессорным) элементом, a перестраиваемые связи между ячейками становятся коммутируемыми каналами связи между функциональными элементами. Каждый функциональный элемент при этом имеет свою специальную внутреннюю регистровую память, отражающую важные для данного функционального элемента аспекты текущего состояния процесса выполнения элементарных операций внутреннего языка.
\end{itemize}

Ключевой задачей построения машин, ориентированных на решение информационно-логических задач является исследование путей построения параллельных машин, управляемых потоком сложноструктурированных данных. В качестве памяти таких машин рассмотреть структурно-перестраиваемые запоминающие среды, обеспечивающие непосредственное хранение графовых структур и манипулирование ими, a также обеспечивающие ассоциативный доступ к произвольным фрагментам перерабатываемых графовых структур (фрагментам, имеющим произвольный вид и произвольный размер). Исследовать пути и принципы аппаратной интерпретации непроцецурных языков программирования типа PROLOG. B качестве интерпретируемого (внутреннего) языка исследовать язык программирования графового типа, являющийся способом записи программ в виде однородных семантических сетей.

Разработка \textit{машин, ориентированных на решение информационно-логических задач} позволит:
\begin{itemize}
	\item существенно расширить класс аппаратурно интерпретируемых (непосредственно перарабатываемых) структур данных;
	\item обеспечить высокую скорость переработки сложноструктурированных данных, благодаря (1) "укрупнению" аппаратно реализуемых операций преобразования структур данных, (2) глубокому распараллеливанию процесса переработки сложных структур как на программном, так и на микропрограммном уровне, (3) организации переработки информации непосредственно в памяти;
	\item существенно расширить логические возможности компьютеров благодаря использованию логического языка в качестве основы внутреннего языка программирования;
	\item обеспечить достаточно высокую технологичность компьютеров рассматриваемого класса благодаря их организации как однородных структур.
\end{itemize}

%\input{author/references}