\usepackage{scn}\chapauthor{Зотов Н.В.\\Шункевич Д.В.}
\chapter{Программная платформа интеллектуальных компьютерных систем нового поколения}
\chapauthortoc{Зотов Н.В.\\Шункевич Д.В.}
\label{chapter_soft_platform}

\abstract{В данной главе формально описывается и обосновывается необходимость создания, цели и задачи, а также
спецификация одного из вариантов реализации программной платформы массовой коллективной разработки и эксплуатации
интеллектуальных компьютерных систем нового поколения. В данной части монографии детально и ярко иллюстрируется
онтологический подход к разработке и спецификации подкласса компьютерных систем, называемых САПРами других
ostis-систем.}

% ST: добавить в главу стандарта

Современные компьютерные системы, в том числе средства автоматизации проектирования таких систем, обладают рядом
значительных недостатков:
\begin{scnitemize}
    \item Проектируемые системы в большей мере остаются зависимыми от реализации конкретных платформ, на которых они
    проектируются, что, в свою очередь, приводит к существенным затратам на корректировку и обновление методов и
    средств проектирования систем в случае их перехода на новые платформы;
    \item Место спецификации программных систем отводится на второй план, а иногда и вовсе не предусматривается
    проектом разработки самой системы, следовательно, увеличиваются затраты на поддержание процесса перманентного
    реинжиниринга таких систем;
    \item При разработке современных систем отсутствует понимание необходимости разработки и описания методов
    проектирования этих систем, в т. ч. описания процесса реализации, направлений эксплуатации и т. д. В результате
    разрабочики таких систем не используют накопленный опыт, а изобретают одни и те же либо похожие решения;
    \item Отсутствуют единые универсальные инструментальные средства разработки и реинжиниринга других систем,
    позволяющие не только автоматизировать их проектирование, но и свести к минимуму саму разработку за счёт
    унификации моделей представления этих систем и наличия комплексной библиотеки многократно используемых компонентов.
    \item Для эффективной реализации даже существующих моделей представления знаний и моделей решения трудно
    формализуемых задач современные компьютеры оказываются плохо приспособленными, что требует разработки принципиально
    новых компьютеров, обеспечивающих унификацию представления этих знаний.
\end{scnitemize}

Для решения и устранения всех перечисленных проблем необходимо проектировать компьютерные системы совершенно нового
класса, а именно компьютерные системы, на которых можно разрабатывать, развивать и использовать другие компьютерные
системы. В первую очередь, имеется ввиду разработка универсальной формальной спецификации класса всевозможных таких
платформ, по которой можно разрабатывать конкретные экземпляры этого класса и задействовать знания и опыт разработки
функционально схожих систем. Проектирование таких платформ разработки других систем должно обеспечиваться благодаря:
\begin{scnitemize}
    \item наличию языковых средств формального описания проектируемых компонентов на разных уровнях детализации,
    \item четкому разделению процесса разработки формальных описаний компонентов и процесса их реализации по заданным
    формальным описаниям,
    \item созданию мощных и доступных библиотек формальных описаний типовых (многократно используемых) компонентов
    таких систем.
\end{scnitemize}

При разработке спецификации таких систем важной задачей является задача выбора средств и методов проектирования
будущей платформы разработки ostis-систем. Она должна обеспечивать:
\begin{scnitemize}
    \item Функциональную полноту для создания логико-семантических моделей ostis-систем за счёт наличия формальной
    методологии проектирования её реализации;
    \item Однозначность интерпретации и представления логико-семантических моделей ostis-систем, обеспечиваемые
    используемым унифицированным языком представления знаний и онтологии проектирования платформ ostis-систем;
    \item Семантическую совместимость логико-семантических моделей ostis-систем и их компонентов между собой;
    \item Платформенную независимость реализуемых и интерпретируемых на ней логико-семантических моделей ostis-систем;
    \item Простоту и гибкость расширения своих функциональный возможностей и круга решаемых задач;
    \item Разделение обязанностей между компонентами (машинами) платформы.
\end{scnitemize}

Необходимость наличия таких свойств у реализуемых платформ обосновывается их назначением. Компьютерные комлексы,
позволяющие разрабатывать другие системы, должны быть реализованы и описаны так, чтобы любая реализуемая на ней
интеллектуальная компьютерная система была совместима с другой такой же системой, при этом так, чтобы будущая
интерпретация её логико-семантической модели оставалась корректной, однозначной и независимой от тех средств и
решений, с помощью которых реализуется сама платформа. С этой точки зрения, реализуемая платформа является лишь средством
массового создания других систем и может быть без особых усилий заменена на свой функционально эквивалетный аналог,
удовлетворящий всем требованиям, предъявлемым к платформам ostis-систем.

Будущая платформа разработки интеллектуальных компьютерных систем нового поколения должна удовлетворять следующим
общим требованиям:
\begin{scnitemize}
    \item Разные варианты реализации универсального интерпретатора логико-семантических моделей ostis-систем никоим
    образом не должен влиять на процесс и результат проектирования ostis-систем, то есть на процесс и результат
    построения логико-семантических моделей разрабатываемых ostis-систем. Проектируемые ostis-системы не должны зависеть
    от конкретной платформы их интерпретации.
    \item Каждый вариант реализации универсального интерпретатора логико-семантических моделей ostis-систем должен быть
    строго специфицирован в терминах и понятиях, предлагаемых Технологией OSTIS, при помощи языка унифицированного
    представления знаний SC-кода.
\end{scnitemize}

Если проектируемая платформа интерпретации sc-моделей других компьютерных систем не удовлетворяет данным требованиям,
тогда такой вариант реализации платформы не считается корректным и не имеет являться частью Технологии OSTIS. Каждый
компонент платформы должен быть спроектирован по принципам, заложенных в онтологическую модель проектирования таких
платформ.

Принципы представления и структуризации логико-семантических моделей ostis-систем и архитектура универсального
интерпретатора этих моделей должны чётко стратифицироваться и, следовательно, могут эволюционировать в достаточной
степени независимо друг от друга. Тем не менее некоторая зависимость всё же есть – согласованная трактовка понятия
универсальной sc-машины и согласованная форма передачи логико-семантической модели разрабатываемой ostis-системы из
Метасистемы OSTIS в \scnqq{пустую} ostis-систему.

% MONO: описать основные машины платформы

Одним из путей, позволяющих осуществлять апробацию, развитие, а в ряде случаев и внедрение новых моделей и технологий
вне зависимости от наличия соответствующих аппаратных средств является разработка программных моделей этих аппаратных
средств, которые были бы функционально эквивалентны этим аппаратным средствам, но при этом интерпретировались на базе
традиционной аппаратной архитектуры (в данной работе традиционной архитектурой будем считать архитектуру фон Неймана,
как доминирующую в настоящее время). Очевидно, что производительность таких программных моделей в общем случае будет
ниже, чем самих аппаратных решений, однако в большинстве случаев она оказывается достаточной для того, чтобы развивать
соответствующую технологию параллельно с разработкой аппаратных средств и осуществления постепенного перевода уже
работающих систем с программной модели на аппаратные средства.

% ST: уточнена в соответствие с библиотекой OSTIS

\begin{SCn}
\scnheader{Программный вариант реализации платформы интерпретации sc-моделей компьютерных систем}
\scniselement{web-ориентированный вариант реализации платформы интерпретации sc-моделей компьютерных систем}
\begin{scnindent}
    \scnidtf{вариант реализации платформы интерпретации sc-моделей компьютерных систем предполагающий взаимодействие
    пользователей с системой посредством сети Интернет}
\end{scnindent}
\scniselement{многопользовательский вариант реализации платформы интерпретации sc-моделей компьютерных систем}
\scniselement{встроенная ostis-система}
\scniselement{многократно используемый компонент ostis-систем}
\scniselement{неатомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\begin{scnrelfromlist}{автор}
    \scnitem{Корончик Д. Н.}
    \scnitem{Шункевич Д. В.}
	\scnitem{Зотов Н. В.}
\end{scnrelfromlist}
\end{SCn}

В основе проектируемой по Технологии OSTIS платформы интерпретации логико-семантических моделей ostis-систем лежат
базовые принципы:
\begin{scnitemize}
    \item Все тексты, представляемые на SC-коде являются графовыми конструкциями. Поэтому задача разработки
    программного варианта реализации платформы интерпретации sc-моделей интеллектуальных ostis-систем сводится к разработке средств
    хранения и обработки таких графовых конструкций. Другими словами, будущая платформа должна обеспечивать хранение графовых
    конструкций их функционально полную и однозначную интерпретацию.
    \item Реализация платформы интерпретации sc-моделей компьютерных систем может иметь большое число вариантов – как
    программно, так и аппаратно реализованных. В любом случае, логическая архитектура платформы интерпретации sc-моделей
    компьютерных систем должна обеспечивать независимость проектируемых компьютерных систем от многообразия вариантов
    реализации интерпретатора их моделей.
    \item Реализация платформы может осуществляться на основе произвольного набора существующих технологий, включая
    аппаратную реализацию каких-либо ее частей. С точки зрения компонентного подхода любая платформа интерпретации
    sc-моделей компьютерных систем является платформенно-зависимым многократно используемым компонентом ostis-систем.
    В то же время sc-модели этих ostis-систем должны быть платформенно-независимыми многократно-используемыми компонентами
    ostis-систем.
    \item Проектирование платформы интерпретации sc-моделей компьютерных систем, в том числе её компонентов, должно
    чётко специфицироваться и формулироваться в рамках моделей, методов и средств описания сложных систем, предлагаемых
    Технологией OSTIS. Именно онтологический подход к проектированию, эксплуатации и реинжиниринга такого подкласса
    компьютерных систем позволит эффективно и универсально разрабатывать другие ostis-системы самого различного
    назначения.
\end{scnitemize}

При необходимости, в платформу интерпретации sc-моделей компьютерных систем могут быть заранее на платформенно-зависимом
уровне включены какие-либо компоненты машин обработки знаний или баз знаний, например, с целью упрощения создания первой
версии прикладной ostis-системы.

К настоящему времени разработано большое количество простейших моделей представления графовых конструкций в линейной
памяти, таких как матрицы смежности, списки смежности и другие (\scncite{Diskrete_Math}). Однако, при разработке сложных
систем как правило приходится использовать более эффективные модели, как с точки зрения объема информации, требуемого
для представления, так и с точки зрения эффективности обработки графовых конструкций, хранимых в той или иной форме.

К наиболее распространенным программным средствам, ориентированным на хранение и обработку графовых конструкций относятся
графовые СУБД (Neo4j \scncite{Neo4j}, ArangoDB \scncite{ArangoDB}, OrientDB \scncite{OrientDB}, Grakn \scncite{Grakn} и др.),
а также так называемые rdf-хранилища (Virtuoso \scncite{Virtuoso}, Sesame \scncite{Sesame} и др.), предназначенные для
хранения конструкций, представленных в модели RDF. Для доступа к информации, хранимой в рамках таких средств, могут
использоваться как языки, реализуемые в рамках конкретного средства (например, язык Cypher в Neo4j), так и языки,
являющиеся стандартами для большого числа систем такого класса (например, SPARQL для rdf-хранилищ).

% MONO: добавить в обоснование сравнение с субз

Популярность и развитость такого рода средств приводит к тому, что на первый взгляд целесообразным и эффективным
кажется вариант реализации \textit{программного варианта реализации платформы интерпретации sc-моделей} на базе
одного из таких средств. Однако, существует ряд причин, по которым было принято решение о реализации
\textit{программного варианта реализации платформы интерпретации sc-моделей} с нуля. К ним относятся следующие:
\begin{scnitemize}
    \item для обеспечения эффективности хранения и обработки информационных конструкций определенного вида (в данном
    случае -- конструкций SC-кода, sc-конструкций), должна учитываться специфика этих конструкций. В частности,
    описанные в работе \scncite{Koronchik2013} эксперименты показали значительный прирост эффективности собственного
    решения по сравнению с существующими на тот момент;
    \item в отличие от классических графовых конструкций, где дуга или ребро могут быть инцидентны только вершине графа
    (это справедливо и для rdf-графов) в SC-коде вполне типичной является ситуация, когда sc-коннектор инцидентен
    другому sc-коннектору или даже двум sc-коннекторам. В связи с этим существующие средства хранения графовых
    конструкций не позволяют в явном виде хранить sc-конструкции (sc-графы). Возможным решением данной проблемы является
    переход от sc-графа к орграфу инцидентности, пример которого описан в работе \scncite{Ivashenko2015}, однако такой
    вариант приводит к увеличению числа хранимых элементов в несколько раз и значительно снижает эффективность алгоритмов
    поиска из-за необходимости делать большое количество дополнительных итераций;
    \item в основе обработки информации в рамках Технологии OSTIS лежит многоагентный подход, в рамках которого агенты
    обработки информации, хранимой в sc-памяти (sc-агенты) реагируют на события, происходящие в sc-памяти и обмениваются
    информацией посредством спецификации выполняемых ими действий в sc-памяти \scncite{Shunkevich2018}. В связи с этим
    одной из важнейших задач является реализация в рамках \textit{программного варианта реализации платформы
    интерпретации sc-моделей} возможности подписки на события, происходящие в программной модели sc-памяти, которая на
    данный момент практически не поддерживается в рамках современных средств хранения и обработки графовых конструкций;
    \item SC-код позволяет описывать также внешние информационные конструкции любого рода (изображения, текстовые файла,
    аудио- и видеофайлы и т.д.), которые формально трактуются как содержимое \textit{sc-элементов}, являющихся знаками
    \textit{внешних файлов ostis-системы}. Таким образом, компонентом \textit{программного варианта реализации платформы
    интерпретации sc-моделей} должна быть реализация файловой памяти, которая позволяет хранить указанные конструкции в
    каких-либо общепринятых форматах. Реализация такого компонента в рамках современных средств хранения и обработки
    графовых конструкций также не всегда представляется возможной.
\end{scnitemize}

По совокупности перечисленных причин было принято решение о реализации \textit{программного варианта реализации
платформы интерпретации sc-моделей} \scnqq{с нуля} с учетом особенностей хранения и обработки информации в рамках
Технологии OSTIS.

Текущий \textit{Программный вариант реализации платформы интерпретации sc-моделей компьютерных систем} является
web-ориентированным, то есть с точки зрения современной архитектуры каждая \mbox{ostis-система} представляет собой
web-сайт доступный онлайн посредством обычного браузера. Такой вариант реализации обладает очевидным преимуществом --
доступ к системе возможен из любой точки мира, где есть Интернет, при этом для работы с системой не требуется никакого
специализированного программного обеспечения. С другой стороны, такой вариант реализации обеспечивает возможность
параллельной работы с системой нескольких пользователей. Реализация является кроссплатформенной и может быть собрана
из исходных текстов в различных операционных системах.

В то же время, взаимодействие клиентской и серверной части организовано таким образом, что \mbox{web-интерфейс} может
быть легко заменен на настольный или мобильный интерфейс, как универсальный, так и специализированный.

Данный вариант реализации распространяется под open-source лицензией, для хранения исходных текстов используется
хостинг Github и коллективная учетная запись ostis-ai.

% ST: изменены названия сущностей, Реализация scp-интерпретатора стала компонентом платформы, а не памяти

\begin{SCn}
\scnheader{Программный вариант реализации платформы интерпретации sc-моделей компьютерных систем}
\begin{scnrelfromset}{декомпозиция программной системы}
    \scnitem{Реализация sc-памяти}
    \scnitem{Реализация scp-интерпретатора}
    \scnitem{Реализация интерпретатора sc-моделей пользовательских интерфейсов}
\end{scnrelfromset}
\scnrelfrom{архитектура}{\scnfileimage{author/part6/images/platform\_arch.pdf}}
\end{SCn}

% MONO: обновить описание архитектуры платформы

На приведенной иллюстрации видно, что ядром платформы является \textit{Реализация sc-памяти},
которая одновременно может взаимодействовать как с \textit{Реализацией интерпретатора интерпретатора sc-моделей
пользовательских интерфейсов}, так и с любыми сторонними приложениями по соответствующим сетевым протоколам.
С точки зрения общей архитектуры \textit{Реализация интерпретатора sc-моделей пользовательских интерфейсов} выступает
как один из множества возможных внешних компонентов, взаимодействующих с \textit{Программной моделью sc-памяти} по сети.

В рамках текущей \textit{Реализации sc-памяти} под \textit{sc-хранилищем} понимается компонент программной
модели, осуществляющий хранение sc-конструкций и доступ к ним через программный интерфейс. В общем случае
\textit{sc-хранилище} может быть реализовано по-разному. Кроме собственно \textit{sc-хранилища}
\textit{Реализация sc-памяти} включает также \textit{Реализацию файловой памяти ostis-системы},
предназначенную для хранения содержимого \textit{внутренних файлов ostis-систем}. Стоит отметить, что при переходе с
\textit{Реализации sc-памяти} на её аппаратную реализацию файловую память ostis-системы целесообразно будет
реализовывать на основе традиционной линейной памяти (во всяком случае, на первых этапах развития
\textit{семантического компьютера}).

% ST: пересмотрена иерархия, привести в соотвествие часть в стандарте
% ST: базовые агенты рассматриваются ниже, сначала память и программные интерфейсы к ней, потом средства, затем агенты
% ST: уточнена в соответствие с библиотекой OSTIS

\begin{SCn}
\scnheader{Реализация sc-памяти}
\scnidtf{Реализация sc-машины}
\scnrelto{программная модель}{sc-память}
\scniselement{программная модель sc-памяти на основе линейной памяти}
\scniselement{неатомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\begin{scnrelfromlist}{компонент программной системы}
    \scnitem{Реализация sc-хранилища и средств доступа к нему}
    \begin{scnrelfromlist}{компонент программной системы}
        \scnitem{Реализация sc-хранилища}
        \scnitem{Реализация файлового хранилища ostis-системы}
    \end{scnrelfromlist}
    \scnitem{Реализация подсистемы взаимодействия с внешней средой с использованием сетевых протоколов}
    \scnitem{Реализация вспомогательных инструментальных средств для работы с sc-памятью}
    \scnitem{Реализация базового набора платформенно-зависимых sc-агентов и их общих компонентов}
\end{scnrelfromlist}
\end{SCn}

В рамках данной реализации \textit{sc-хранилища} \textit{sc-память} моделируется в виде набора \textit{сегментов},
каждый из которых представляет собой фиксированного размера упорядоченную последовательность \textit{элементов sc-хранилища},
каждый из которых соответствует конкретному sc-элементу. В настоящее время каждый сегмент состоит из $2^{16}-1=65535$
\textit{элементов sc-хранилища}. Каждый сегмент состоит из набора структур данных, описывающих конкретные
\textit{sc-элементы} (элементов sc-хранилища). Независимо от типа описываемого sc-элемента каждый \textit{элемент sc-хранилища}
имеет фиксированный размер (в текущий момент -- 36 байт), что обеспечивает удобство их хранения. Таким образом,
максимальный размер базы знаний в текущей программной модели sc-памяти может достигнуть 180 Гб (без учета содержимого
\textit{внутренних файлов ostis-системы}, хранимого на внешней файловой системе).

% ST: переписано на теор.-мн. отношения
% ST: уточнена в соответствие с библиотекой OSTIS

\begin{SCn}
\scnheader{Реализация sc-хранилища}
\scniselement{реализация sc-хранилища на основе линейной памяти}
\scniselement{атомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\scnrelfrom{иллюстрация}{\scnfileimage{author/part6/images/sc_storage.pdf}}
\scnrelto{программная модель}{sc-хранилище}
\begin{scnindent}
    \scnrelto{семейство подмножеств}{сегмент}
    \begin{scnindent}
        \scnidtf{страница sc-хранилища}
        \scnrelto{семейство подмножеств}{элемент sc-хранилища}
    \end{scnindent}
\end{scnindent}
\scnrelfrom{пример}{\scnfileimage[42em]{author/part6/images/sc_storage_example.png}}
\begin{scnrelfromlist}{используемый язык программирования}
    \scnitem{С}
    \scnitem{С++}
\end{scnrelfromlist}
\begin{scnrelfromlist}{автор}
    \scnitem{Корончик Д. Н.}
    \scnitem{Шункевич Д. В.}
	\scnitem{Зотов Н. В.}
\end{scnrelfromlist}
\end{SCn}

Выделение \textit{сегментов sc-хранилища} позволяет, с одной стороны, упростить адресный доступ к \textit{элементам
sc-хранилища}, с другой стороны -- реализовать возможность выгрузки части sc-памяти из оперативной памяти на файловую
систему при необходимости. Во втором случае сегмент sc-хранилища становится минимальной(атомарной) выгружаемой частью
sc-памяти. Механизм выгрузки сегментов реализуется в соответствии с существующими принципами организации виртуальной
памяти в современных операционных системах.

Максимально возможное число сегментов ограничивается настройками программной реализации sc-хранилища (в настоящее время
по умолчанию установлено количество $2^{16}-1=65535$ сегментов, но в общем случае оно может быть другим). Таким
образом, технически максимальное количество хранимых sc-элементов в текущей реализации составляет около $4.3 \times
10^{9}$ sc-элементов. По умолчанию все сегменты физически располагаются в оперативной памяти, если объема памяти не
хватает, то предусмотрен механизм выгрузки части сегментов на жесткий диск (механизм виртуальной памяти).

Текущий вариант \textit{Программной модели sc-памяти} предполагает возможность сохранения состояния (слепка) памяти
на жесткий диск и последующей загрузки из ранее сохраненного состояния. Такая возможность необходима для перезапуска
системы, в случае возможных сбоев, а также при работе с исходными текстами базы знаний, когда сборка из исходных текстов
сводится к формированию слепка состояния памяти, который затем помещается в \textit{Программную модель sc-памяти}.

Каждый элемент sc-хранилища в текущей реализации может быть однозначно задан его адресом (sc-адресом), состоящим из
номера сегмента и номера \textit{элемента sc-хранилища} в рамках сегмента. Таким образом, \textit{sc-адрес} служит
уникальными координатами \textit{элемента sc-хранилища} в рамках \textit{Реализации sc-хранилища}.

Для каждого sc-адреса можно взаимно однозначно поставить в соответствие некоторый хэш, полученный в результате применения
специальной хэш-функции над этим sc-адресом. Хэш является неотрицательным целым числом и является результатом
преобразования номера сегмента sc-хранилища si, в котором располагается sc-элемент, и номера этого sc-элемента
sc-хранилища ei в рамках этого сегмента si. В рамках sc-хранилища используется единственная хеш-функция для
получения хеша sc-адреса sc-элемента и задаётся как $f(si, ei) = si << 16 \vee ei \wedge 0xffff$, где операция $<<$ -
операция логического битового сдвига влево левого аргумента на количество единиц, заданное правым аргументом, относительно
этой операции, операция $\vee$ - операция логического ИЛИ, операция $\wedge$ - операция логического И, число $0xffff$ -
число 65535, представленное в шестнадцатеричном виде и обозначающее максимальное количество sc-элементов в одном сегменте
sc-хранилища.

% ST: переписано на теор.-мн. отношения

\begin{SCn}
\scnheader{sc-адрес}
\scnidtf{адрес элемента sc-хранилища, соответствующего заданному sc-элементу, в рамках текущего состояния реализации
sc-хранилища в составе программной модели sc-памяти}
\begin{scnreltovector}{композиция}
    \scnitem{номер сегмента sc-хранилища*}
    \begin{scnindent}
        \scnrelfrom{второй домен}{целое 4-байтовое число}
    \end{scnindent}
    \scnnonamednode
    \begin{scnindent}
        \scnrelto{инверсия}{номер элемента sc-хранилища в рамках сегмента*}
        \begin{scnindent}
            \scnrelfrom{второй домен}{целое 4-байтовое число}
        \end{scnindent}
    \end{scnindent}
\end{scnreltovector}
\end{SCn}

Sc-адрес никак не учитывается при обработке базы знаний на семантическом уровне и необходим только для обеспечения
доступа к соответствующей структуре данных, хранящейся в линейной памяти на уровне \textit{Реализации sc-хранилища}.
В общем случае sc-адрес элемента sc-хранилища, соответствующего заданному sc-элементу, может меняться, например, при
пересборке базы знаний из исходных текстов и последующем перезапуске системы. При этом sc-адрес элемента sc-хранилища,
соответствующего заданному sc-элементу, непосредственно в процессе работы системы в текущей реализации меняться не может.
Для простоты будем говорить \scnqq{sc-адрес sc-элемента}, имея в виду \textit{sc-адрес} \textit{элемента sc-хранилища},
однозначно соответствующего данному \textit{sc-элементу}.

Каждый элемент sc-хранилища, соответствующий некоторому sc-элементу, описывается его синтаксическим типом (меткой), а
также независимо от типа указывается sc-адрес первой входящей в данный sc-элемент sc-дуги и первой выходящей из данного
sc-элемента sc-дуги (могут быть пустыми, если таких sc-дуг нет). Оставшиеся байты в зависимости от типа соответствующего
sc-элемента (sc-узел или sc-дуга) могут использоваться для хранения спецификации sc-дуги. Также \textit{sc-адрес первой
sc-дуги, выходящей из данного sc-элемента*} и \textit{sc-адрес первой sc-дуги, входящей в данный sc-элемент*} в общем
случае могут отсутствовать (быть нулевыми,\scnqq{пустыми}), но размер sc-элемента в байтах останется тем же.

В текущий момент sc-ребра хранятся так же, как sc-дуги, то есть имеют начальный и конечный sc-элементы, отличие
заключается только в \textit{метке синтаксического типа sc-элемента}. Это приводит к ряду неудобств при обработке,
но sc-ребра используются в настоящее время достаточно редко.

\begin{SCn}
\scnheader{элемент sc-хранилища}
\scnidtf{ячейка sc-хранилища}
\scnidtf{элемент sc-хранилища, соответствующий sc-элементу}
\scnidtf{образ sc-элемента в рамках sc-хранилища}
\scnidtf{структура данных, каждый экземпляр которой соответствует одному sc-элементу в рамках sc-хранилища}
\begin{scnrelfromset}{разбиение}
    \scnitem{элемент sc-хранилища, соответствующий sc-узлу}
    \begin{scnindent}
        \begin{scnrelfromset}{семейство отношений, однозначно задающих структуру заданной сущности}
            \scnitem{метка синтаксического типа sc-элемента*}
            \scnitem{метка уровня доступа sc-элемента*}
            \scnitem{sc-адрес первой sc-дуги, выходящей из данного sc-элемента*}
            \scnitem{sc-адрес первой sc-дуги, входящей в данный sc-элемент*}
        \end{scnrelfromset}
    \end{scnindent}
    \scnitem{элемент sc-хранилища, соответствующий sc-дуге}
    \begin{scnindent}
        \begin{scnrelfromset}{семейство отношений, однозначно задающих структуру заданной сущности}
            \scnitem{метка синтаксического типа sc-элемента*}
            \scnitem{метка уровня доступа sc-элемента*}
            \scnitem{sc-адрес первой sc-дуги, выходящей из данного sc-элемента*}
            \scnitem{sc-адрес первой sc-дуги, входящей в данный sc-элемент*}
            \scnitem{спецификация sc-дуги в рамках sc-хранилища*}
            \begin{scnindent}
                \scnrelfrom{второй домен}{спецификация sc-дуги в рамках sc-хранилища}
                \begin{scnindent}
                    \begin{scnrelfromset}{семейство отношений, однозначно задающих структуру заданной сущности}
                        \scnitem{sc-адрес начального sc-элемента sc-дуги*}
                        \scnitem{sc-адрес конечного sc-элемента sc-дуги*}
                        \scnitem{sc-адрес следующей sc-дуги, выходящей из того же sc-элемента*}
                        \scnitem{sc-адрес следующей sc-дуги, входящей в тот же sc-элемент*}
                        \scnitem{sc-адрес предыдущей sc-дуги, выходящей из того же sc-элемента*}
                        \scnitem{sc-адрес предыдущей sc-дуги, входящей в тот же sc-элемент*}
                    \end{scnrelfromset}
                \end{scnindent}
            \end{scnindent}
        \end{scnrelfromset}
    \end{scnindent}
\end{scnrelfromset}
\end{SCn}

С точки зрения программной реализации структура данных для хранения sc-узла и sc-дуги остается остается та же, но в
ней меняется список полей (компонентов).
Кроме того, как можно заметить каждый элемент sc-хранилища (в том числе, \textit{элемент sc-хранилища, соответствующий
sc-дуге}) не хранит список sc-адресов связанных с ним sc-элементов, а хранит sc-адреса одной выходящей и одной
входящей дуги, каждая из которых в свою очередь хранит sc-адреса следующей и предыдущей дуг в списке исходящих и
входящих sc-дуг для соответствующих элементов. Всё перечисленное позволяет:
\begin{scnitemize}
    \item сделать размер такой структуры фиксированным (в настоящее время 36 байт) и не зависящим от синтаксического
    типа хранимого sc-элемента;
    \item обеспечить возможность работы с sc-элементами без учета их синтаксического типа в случаях, когда это необходимо
    (например, при реализации поисковых запросов вида \scnqqi{Какие sc-элементы являются элементами данного множества},
    \scnqqi{Какие sc-элементы непосредственно связаны с данным sc-элементом} и т.д.);
    \item обеспечить возможность доступа к \textit{элементу sc-хранилища} за константное время;
    \item обеспечить возможность помещения \textit{элемента sc-хранилища} в процессорный кэш, что в свою очередь,
    позволяет ускорить обработку sc-конструкций;
\end{scnitemize}

Текущая \textit{Программная модель sc-памяти} предполагает, что вся sc-память физически расположена на одном компьютере.
Для реализации распределенного варианта \textit{Программной модели sc-памяти} предполагается расширить \textit{sc-адрес}
указанием адреса того физического устройства, где хранится соответствующий \textit{элемент sc-хранилища}.

Тип (класс, вид) sc-элемента в sc-памяти может быть задан путем явного указания принадлежности данного sc-элемента
соответствующему классу (sc-узел, sc-дуга и т.д.).

Однако, в рамках \textit{платформы интерпретации sc-моделей компьютерных систем} должен существовать какой-либо набор
\textit{меток синтаксического типа sc-элемента}, которые задают тип элемента на уровне платформы и не имеют соответствующей
sc-дуги принадлежности (а точнее -- базовой sc-дуги), явно хранимой в рамках sc-памяти (ее наличие подразумевается,
однако она не хранится явно, поскольку это приведет к бесконечному увеличению числа sc-элементов, которые необходимо
хранить в sc-памяти). Как минимум, должна существовать метка, соответствующая классу \textit{базовая sc-дуга}, поскольку
явное указание принадлежности sc-дуги данному классу порождает еще одну \textit{базовую sc-дугу}.

\begin{SCn}
\scnheader{метка синтаксического типа sc-элемента}
\scnidtf{уникальный числовой идентификатор, однозначно соответствующий заданному типу sc-элементов и приписываемый
соответствующему элементу sc-хранилища на уровне реализации}
\scnrelto{второй домен}{метка синтаксического типа sc-элемента*}
\scnsuperset{метка sc-узла}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x1}
\end{scnindent}
\scnsuperset{метка внутреннего файла ostis-системы}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x2}
\end{scnindent}
\scnsuperset{метка sc-ребра общего вида}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x4}
\end{scnindent}
\scnsuperset{метка sc-дуги общего вида}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x8}
\end{scnindent}
\scnsuperset{метка sc-дуги принадлежности}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x10}
\end{scnindent}
\scnsuperset{метка sc-константы}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x20}
\end{scnindent}
\scnsuperset{метка sc-переменной}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x40}
\end{scnindent}
\scnsuperset{метка позитивной sc-дуги принадлежности}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x80}
\end{scnindent}
\scnsuperset{метка негативной sc-дуги принадлежности}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x100}
\end{scnindent}
\scnsuperset{метка нечеткой sc-дуги принадлежности}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x200}
\end{scnindent}
\scnsuperset{метка постоянной sc-дуги}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x400}
\end{scnindent}
\scnsuperset{метка временной sc-дуги}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x800}
\end{scnindent}
\scnsuperset{метка небинарной sc-связки}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x80}
\end{scnindent}
\scnsuperset{метка sc-структуры}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x100}
\end{scnindent}
\scnsuperset{метка ролевого отношения}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x200}
\end{scnindent}
\scnsuperset{метка неролевого отношения}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x400}
\end{scnindent}
\scnsuperset{метка sc-класса}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x800}
\end{scnindent}
\scnsuperset{метка абстрактной сущности}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x1000}
\end{scnindent}
\scnsuperset{метка материальной сущности}
\begin{scnindent}
    \scntext{числовое выражение в шестнадцатеричной системе}{0x2000}
\end{scnindent}
\scnsuperset{метка константной позитивной постоянной sc-дуги принадлежности}
\begin{scnindent}
    \scnidtf{метка базовой sc-дуги}
    \scnidtf{метка sc-дуги основного вида}
    \begin{scnreltoset}{пересечение}
        \scnitem{метка sc-дуги принадлежности}
        \scnitem{метка sc-константы}
        \scnitem{метка позитивной sc-дуги принадлежности}
        \scnitem{метка постоянной sc-дуги}
    \end{scnreltoset}
\end{scnindent}
\scnsuperset{метка переменной позитивной постоянной sc-дуги принадлежности}
\begin{scnindent}
    \begin{scnreltoset}{пересечение}
        \scnitem{метка sc-дуги принадлежности}
        \scnitem{метка sc-переменной}
        \scnitem{метка позитивной sc-дуги принадлежности}
        \scnitem{метка постоянной sc-дуги}
    \end{scnreltoset}
\end{scnindent}
\end{SCn}

Данная модель представления в памяти системы синтаксических типов sc-элементов обладает рядом преимуществ:
\begin{scnitemize}
    \item \textit{Метки синтаксических типов sc-элементов} могут комбинироваться между собой для получения более
    частных классов меток. С точки зрения программной реализации такая комбинация выражается операцией побитового
    сложения значений соответствующих меток.
    \item Числовые выражения некоторых классов меток могут совпадать. Это сделано для уменьшения размера элемента
    sc-хранилища за счет уменьшения максимального размера метки. Конфликт в данном случае не возникает, поскольку такие
    классы меток не могут комбинироваться, например \textit{метка ролевого отношения} и
    \textit{метка нечеткой sc-дуги принадлежности}.
    \item Важно отметить, что каждому из выделенных классов меток (кроме классов, получаемых путем комбинации других
    классов) однозначно соответствует порядковый номер бита в линейной памяти, что можно заметить, глядя на
    соответствующие числовые выражения классов меток. Это означает, что классы меток не включаются друг в друга, например,
    указание \textit{метки позитивной sc-дуги принадлежности} не означает автоматическое указание \textit{метки sc-дуги
    принадлежности}. Это позволяет сделать операции комбинирования и сравнения меток более эффективными.
\end{scnitemize}

Не смотря на этом полностью отказаться от \textit{меток синтаксического типа sc-элементов} невозможно, однако увеличение
их числа хоть и повышает производительность платформы за счет упрощений некоторых операций по проверке типов sc-элемента,
но приводит к увеличению числа ситуаций, в которых необходимо учитывать явное и неявное представление sc-дуг, что,
в свою очередь, усложняет развитие платформы и разработку программного кода для обработки хранимых sc-конструкций.
Данная модель не позволяет достаточно представлять синтаксические типы sc-элементов, поскольку имеет следующие важные
недостатки:
\begin{scnitemize}
    \item На данный момент число \textit{меток синтаксического типа sc-элемента} достаточно велико, что приводит к
    возникновению достаточно большого числа ситуаций, в которых нужно учитывать явное и неявное хранение sc-дуг
    принадлежности соответствующим классам. С другой стороны, изменение набора меток с какой-либо целью в текущем
    варианте реализации представляет собой достаточно трудоемкую задачу (с точки зрения объема изменений в программном
    коде платформы и sc-агентов, реализованных на уровне платформы), а расширение набора меток без увеличения объема
    элемента sc-хранилища в байтах оказывается и вовсе невозможным. Решением данной проблемы является максимально
    возможная минимизация числа меток, например, до числа меток, соответствующих \textit{Алфавиту SC-кода}. В таком
    случае принадлежность sc-элементов любым другим классам будет записываться явно, а число ситуаций, в которых
    необходимо будет учитывать неявное хранение sc-дуг, будет минимальным.
    \item Некоторые метки из текущего набора \textit{меток синтаксического типа sc-элемента} используются достаточно
    редко (например, \textit{метка sc-ребра общего вида} или \textit{метка негативной sc-дуги принадлежности}), в
    свою очередь, в sc-памяти могут существовать классы, имеющие достаточно много элементов (например, \textit{бинарное
    отношение*} или \textit{число}). Данный факт не позволяет в полной мере использовать эффективность наличия меток.
    Решением данной проблемы является отказ от заранее известного набора меток и переход к динамическому набору
    меток (при этом их число может оставаться фиксированным). В этом случае набор классов, выражаемых в виде меток
    будет формироваться на основании каких-либо критериев, например, числа элементов данного класса или частоты обращений
    к нему.
    \item \textit{базовые sc-дуги}, обозначающие принадлежность sc-элементов некоторому известному ограниченному
    набору классов представлены неявно. Этот факт необходимо учитывать в ряде случаев, например, при проверке принадлежности
    sc-элемента некоторому классу, при поиске всех выходящих sc-дуг из заданного sc-элемента и т.д.
    При необходимости некоторые из таких неявно хранимых sc-дуг могут быть представлены явно, например, в случае, когда
    такую sc-дугу необходимо включить в какое-либо множество, то есть провести в нее другую sc-дугу. В этом случае возникает
    необходимость синхронизации изменений, связанных с данной sc-дугой (например, ее удалении), в явном и неявном ее
    представлении. В текущей \textit{Реализации sc-хранилища} данный механизм не реализован. Эта проблема решается
    одним из предыдущих вариантов решения проблем данной модели.
\end{scnitemize}

В текущей \textit{Реализации sc-хранилища} \textit{метки уровня доступа} используются для того, чтобы обеспечить
возможность ограничения доутспа некоторых процессов в sc-памяти к некоторым sc-элементам, хранимым в sc-памяти.
Каждому элементу sc-хранилища соответствует \textit{метка уровня доступа sc-элемента на чтение} и \textit{метка уровня
доступа sc-элемента на запись}, каждая из которых выражается числом от 0 до 255.

В свою очередь, каждому процессу (чаще всего, соответствующему некоторому sc-агенту), который пытается получить доступ к
данному элементу sc-хранилища (прочитать или изменить его) соответствует уровень доступа на чтение и запись, выраженный
в том же числовом диапазоне. Указанный уровень доступа для процесса является частью \textit{контекста процесса}. Доступ
на чтение или запись к элементу sc-хранилища не разрешается, если уровень доступа соответственно на чтение или запись
у процесса ниже, чем у элемента sc-хранилища, к которому осуществляется доступ.

Таким образом нулевое значение \textit{метки уровня доступа sc-элемента на чтение} и \textit{метки уровня доступа
sc-элемента на запись} означает, что любой процесс может получить неограниченный доступ к данному элементу sc-хранилища.

\begin{SCn}
\scnheader{метка уровня доступа sc-элемента}
\scnrelto{второй домен}{метка уровня доступа sc-элемента*}
\begin{scnrelfromset}{обобщенная структура}
    \scnitem{метка уровня доступа sc-элемента на чтение}
    \scnitem{метка уровня доступа sc-элемента на запись}
\end{scnrelfromset}
\end{SCn}

% MONO: описать преимущества и недостатки реализации хранилища
% MONO: описать файловое хранилище на основе префиксного дерева

Для хранения содержимого внутренних файлов ostis-систем, размер которого превышает 36 байт, используются файлы, явно
хранимые на файловой системе, доступ к которой осуществляется средствами операционной системы, на которой работает
\textit{Программный вариант реализации платформы интерпретации sc-моделей компьютерных систем}. В общем случае множество
различных внутренних файлов ostis-системы могут иметь одинаковое содержимое. Было бы разумно не хранить содержимое
одинаковых файлов дважды. Для этого при создании соответствуюещго sc-узла и указании файла на файловой системе, который
является содержимым данного sc-узла, вычисляется hash-сумма содержимого с помощью алгоритма SHA256. В результате получается
строка из 32 символов, которая и выступает в качестве \textit{содержимого элемента sc-хранилища*}. Само же содержимое
копируется в файл на файловой системе, путь к которому строится на основании hash-суммы. Рядом с этим файлом
создается файл, в котором хранятся sc-адреса всех sc-узлов, имеющих одно и то же ранее указанное содержимое.
Таким образом, для того, чтобы найти все sc-узлы, имеющие указанное содержимое, необходимо вычислить hash-сумму
искомого содержимого-образца и проверить наличие файла на файловой системе по пути, вычисляемому из hash-суммы и если
он существует, то вернуть список хранящихся sc-адресов. Кроме того, для реализации быстрого поиска
sc-элементов по их строковым sc-идентификаторам или их фрагментам (подстрокам) используется дополнительное
хранилище вида ключ-значение, которое ставит в соответствие \textit{строковому sc-идентификатору} \textit{sc-адрес}
того \textit{sc-элемента}, идентификатором которого является данная строка (в случае основного и системного sc-идентификатора)
или \textit{sc-элемента}, который является знаком \textit{внутреннего файла ostis-системы} (в случае неосновного
sc-идентификатора).

\begin{SCn}
\scnheader{Реализация файлового хранилища ostis-системы}
\scniselement{реализация файлового хранилища на основе префиксного дерева}
\scniselement{неатомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\begin{scnrelfromlist}{используемый язык программирования}
    \scnitem{С}
\end{scnrelfromlist}
\begin{scnrelfromlist}{автор}
	\scnitem{Зотов Н. В.}
\end{scnrelfromlist}
\end{SCn}

Взаимодействие программной модели sc-памяти с внешними ресурсами может осуществляться посредством специализированного
программного интерфейса (API), однако этот вариант неудобен в большинстве случае, поскольку:
    \begin{scnitemize}
        \item поддерживается только для очень ограниченного набора языков программирования (С, С++);
        \item требует того, чтобы клиентское приложение, обращающееся к программной модели sc-памяти, фактически
        составляло с ней единое целое, таким образом исключается возможность построения распределенного коллектива
        ostis-систем;
        \item как следствие предыдущего пункта, исключается возможность параллельной работы с sc-памятью нескольких
        клиентских приложений.
    \end{scnitemize}
Для того, чтобы обеспечить возможность удаленного доступа к sc-памяти не учитывая при этом языки программирования, с
помощью которых реализовано конкретное клиентское приложение, было принято решение о реализации возможности доступа к
sc-памяти с использованием универсального языка, не зависящего от средств реализации того или иного компонента или
системы. В качестве такого языка был разработан строковый язык на базе языка JSON.

\begin{SCn}
\scnheader{Реализация подсистемы взаимодействия с внешней средой с использованием сетевых языков}
\begin{scnrelfromlist}{компонент программной системы}
    \scnitem{Реализация подсистемы взаимодействия с внешней средой с использованием сетевых языков на основе языка JSON}
\end{scnrelfromlist}
\end{SCn}

% MONO: добавить описание и обоснование из записки

Реализация подсистемы взаимодействия c sc-памятью на основе языка JSON позволяет ostis-системам
взаимодействовать с системами из внешней среды на основе общепринятого транспортного формата передачи данных JSON и
предоставляет API для доступа к sc-памяти платформы интерпретации sc-моделей.

\begin{SCn}
\scnheader{Реализация подсистемы взаимодействия c sc-памятью на основе языка JSON}
\scnidtf{Подсистема взаимодействия с sc-памятью на основе формата JSON}
\scniselement{многократно используемый компонент ostis-систем}
\scniselement{неатомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\begin{scnrelfromlist}{используемый язык программирования}
    \scnitem{C}
    \scnitem{C++}
    \scnitem{Python}
    \scnitem{TypeScript}
    \scnitem{C\#}
    \scnitem{Java}
\end{scnrelfromlist}
\begin{scnrelfromlist}{используемый язык}
    \scnitem{SC-JSON-код}
\end{scnrelfromlist}
\scnrelfrom{архитектура}{Клиент-серверная архитектура}
\begin{scnrelfromlist}{автор}
    \scnitem{Корончик Д. Н.}
    \scnitem{Шункевич Д. В.}
    \scnitem{Зотов Н. В.}
    \scnitem{Загорский А. Г.}
\end{scnrelfromlist}
\begin{scnrelfromset}{декомпозиция программной системы}
    \scnitem{Серверная система на основе Websocket и JSON, обеспечивающая сетевой доступ к sc-памяти}
    \scnnonamednode
    \begin{scneqtoset}
        \scnitem{Клиентская система, реализованная на языке программирования Python}
        \scnitem{Клиентская система, реализованная на языке программирования TypeScript}
        \scnitem{Клиентская система, реализованная на языке программирования C\#}
        \scnitem{Клиентская система, реализованная на языке программирования Java}
    \end{scneqtoset}
\end{scnrelfromset}
\end{SCn}

Взаимодействие c sc-памятью обеспечивается с помощью передачи информации на \textit{\textbf{SC-JSON-коде}} и ведётся,
с одной стороны, между сервером, являющегося частью ostis-системы, написанным на том же языке реализации этой ostis-
системы и имеющим доступ к её sc-памяти, и с другой стороны множеством клиентом, которым известно о наличии сервера
в пределах сети их использования. С помощью подсистемы взаимодействия с sc-памятью на основе языка JSON можно
взаимодействовать с ostis-системой на таком же множестве возможных операций, как и в случае, если бы взаимодействие
происходило (непосредственно) напрямую, на том же языке реализации платформы интерпретации sc-моделей компьютерных
систем. При этом результат работы отличается только скоростью обработки информации.

\begin{SCn}
\scnheader{SC-JSON-код}
\scnidtf{Semantic JSON-code}
\scnidtf{Semantic JavaScript Object Notation code}
\scnidtf{Язык внешнего смыслового представления знаний на основе языка JSON}
\scntext{часто используемый неосновной внешний идентификатор sc-элемента}{sc-json-текст}
\begin{scnindent}
    \scniselement{имя нарицательное}
\end{scnindent}
\scniselement{абстрактный язык}
\scniselement{линейный язык}
\scnsubset{JSON}
\begin{scnrelfromlist}{автор}
	\scnitem{Зотов Н. В.}
	\scnitem{Корончик Д. Н.}
\end{scnrelfromlist}
\end{SCn}

\textit{Синтаксис SC-JSON-кода} задается: (1) \textit{Алфавитом SC-JSON-кода}, (2) Грамматикой SC-JSON-кода. В
алфавите SC-JSON-кода выделяется базовая синтаксическая классификация его элементов.

\begin{SCn}
\scnstructheader{SC-JSON-код}
\scnrelto{семейство подмножеств}{sc-json-предложение}
\begin{scnindent}
	\scnsubset{json-список json-пар}
	\scnrelto{семейство подмножеств}{sc-json-пара*}
	\begin{scnindent}
		\begin{scnreltovector}{декартово произведение}
		    \scnitem{sc-json-строка}
			\scnitem{sc-json-объект}
			\begin{scnindent}
				\begin{scnrelfromset}{разбиение}
					\scnitem{sc-json-cписок}
					\scnitem{sc-json-пара}
					\scnitem{sc-json-литерал}
					\begin{scnindent}
						\begin{scnrelfromset}{разбиение}
							\scnitem{sc-json-строка}
							\scnitem{sc-json-число}
					    \end{scnrelfromset}
					\end{scnindent}
				\end{scnrelfromset}
		    \end{scnindent}
		\end{scnreltovector}
	\end{scnindent}
	\begin{scnrelfromset}{разбиение}
		\scnitem{команда на SC-JSON-коде}
		\scnitem{ответ на команду на SC-JSON-коде}
	\end{scnrelfromset}
\end{scnindent}
\end{SCn}

\textit{Алфавит SC-JSON-кода\scnsupergroupsign} представляет собой множество всех возможных символов в SC-JSON-коде.
Поскольку \textit{SC-JSON-код} является линейным строковым языком представления знаний, то его алфавит включает
объединение алфавитов всех языков, тексты на которых могут представлять внешние идентификаторы и/или содержимое файлов ostis-системы,
множество всех цифр и множество всех других специальных символов. Последовательности знаков алфавита могут образовывать
sc-json ключевые слова, \textit{sc-json-пары}, \textit{sc-json-предложения} из \textit{sc-json-пар} и
\textit{sc-json-тексты} из \textit{sc-json-предложений}. При этом конструкции на SC-JSON-коде строятся по следующим
синтаксическим правилам:
\begin{scnitemize}
    \item Каждое правило \textit{Грамматики SC-JSON-кода} описывает корректный с точки зрения \textit{Синтаксиса
    SC-JSON-кода} порядок sc-json-объектов в sc-json-предложении. Совокупность правил \textit{Грамматики SC-JSON-кода}
    описывает корректный с точки зрения \textit{Синтаксиса SC-JSON-кода} порядок sc-json-предложений в sc-json-тексте.
    Каждое sc-json-предложение является sc-json-списком, состоящим из sc-json-пар и представляет собой команду или ответ
    на эту команду.
    \item Каждое \textit{команда (ответ на команду) на SC-JSON-коде} состоит из заголовка, включающего sc-json-пары
    описания самой команды (ответа на команду), и сообщения, различного для каждого класса команд (ответов на команды).
    Сообщение \textit{команды (ответа на команду) на SC-JSON-коде} обычно представляет собой список sc-json-объектов и
    может не ограничиваться по мощности.
    \item Каждое \textit{команда (ответ на команду) на SC-JSON-коде} состоит из заголовка, включающего sc-json-пары
    описания самой команды (ответа на команду), и сообщения, различного для каждого класса команд (ответов на команды).
    Сообщение \textit{команды (ответа на команду) на SC-JSON-коде} обычно представляет собой список sc-json-объектов и
    может не ограничиваться по мощности.
    \item Каждая sc-json-пара состоит из двух элементов: ключевого слова и некоторого другого sc-json-объекта,
    ассоциируемого с этим ключевым словом. Набор ключевых слов в sc-json-парах определяется конкретным классом
    \textit{команд (ответов на команды) на SC-JSON-коде}. Sc-json-пара начинается знаком открывающейся фигурной скобки
    \scnqq{\{} и заканчивается знаком закрывающейся фигурной скобки \scnqq{\}}. Ключевое слово и sc-json-объект,
    ассоциируемый с ним, разделяются при помощи знака двоеточия \scnqq{:}.
    \item Sc-json-строки, записанные в sc-json-текстах, начинаются и заканчиваются знаком двух ковычек \textquotedblleft.
    \item Sc-json-списки, состоящие не из sc-json-пар, начинаются знаком открывающейся квадратной скобки \scnqq{[} и
    заканчиваются знаком закрывающейся квадратной скобки \scnqq{]}. Sc-json-объекты в sc-json-списках разделяются
    запятыми \scnqq{,}.
\end{scnitemize}

Грамматика SC-JSON-кода представляет собой множество всех возможных правил, используемых при построении команд и
ответов на них на SC-JSON-коде. Каждой команде \textit{SC-JSON-кода} однозначно соответствует правило грамматики
\textit{SC-JSON-кода}. Правила \textit{Грамматики SC-JSON-кода} позволяют правильно составить команду на SC-JSON-коде.
Каждое правило грамматики \textit{SC-JSON-кода} представляется в виде правила на \textit{Языке описания грамматик ANTLR}
и его интерпретации на естественном языке.

\scnheader{Грамматика SC-JSON-кода}
\scnhaselementrole{ключевой sc-элемент}{Правило, задающее синтаксис \textit{команд на SC-JSON-коде}}
\begin{scnindent}
	\scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{author/part6/images/command.png}}
	\begin{scnindent}
		\scniselement{Язык описания грамматики языков ANTLR}
		\end{scnindent}
	\scnrelto{синтаксическое правило}{команда на SC-JSON-коде}
\end{scnindent}

Правило, задающее синтаксис \textit{команд на SC-JSON-коде} означает следующее. Класс \textit{команд на SC-JSON-коде}
включает \textit{команду создания sc-элементов}, \textit{команду получения соответствующих типов sc-элементов},
\textit{команду удаления sc-элементов}, \textit{команду обработки ключевых sc-элементов}, \textit{команду обработки
содержимого файлов ostis-системы}, \textit{команду поиска sc-конструкций, изоморфных заданному sc-шаблону},
\textit{команду генерации sc-конструкции, изоморфной заданному sc-шаблону}, и \textit{команду обработки sc-событий}.
В \textit{команду на SC-JSON-коде} включаются идентификатор этой команды, тип и сообщение.

\scnhaselementrole{ключевой sc-элемент}{Правило, задающее синтаксис \textit{ответа на команду на SC-JSON-коде}}
\begin{scnindent}
	\scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{author/part6/images/command\_answer.png}}
	\begin{scnindent}
		\scniselement{Язык описания грамматики языков ANTLR}
    \end{scnindent}
	\scnrelto{синтаксическое правило}{ответ на команду на SC-JSON-коде}
\end{scnindent}

Правило, задающее синтаксис \textit{ответа на команду на SC-JSON-коде} описывает синтаксис ответов на команды,
описываемых предыдущим правилом. Класс \textit{ответов на команды на SC-JSON-коде} включает \textit{ответ на команду
создания sc-элементов}, \textit{ответ на команду получения соответствующих типов sc-элементов}, \textit{ответ на команду
удаления sc-элементов}, \textit{ответ на команду обработки ключевых sc-элементов}, \textit{ответ на команду обработки
содержимого файлов ostis-системы}, \textit{ответ на команду поиска sc-конструкций, изоморфных заданному sc-шаблону},
\textit{ответ на команду генерации sc-конструкции, изоморфной заданному sc-шаблону}, и \textit{ответ на команду
обработки sc-событий}. В \textit{ответ на команду на SC-JSON-коде} включаются идентификатор соответствующей команды,
статус обработки ответа и ответное сообщение.

\scnhaselement{Правило, задающее синтаксис \textit{команды создания sc-элементов}}
\begin{scnindent}
	\scnrelboth{семантическая эквивалентность}{\scnfileimage[50em]{author/part6/images/create\_elements\_command.pdf}}
	\begin{scnindent}
		\scniselement{Язык описания грамматики языков ANTLR}
    \end{scnindent}
	\scnrelto{синтаксическое правило}{команда создания sc-элементов}
\end{scnindent}

В сообщении \textit{команды создания sc-элементов} представляется список описаний создаваемых sc-элементов. Такими
sc-элементами могут быть sc-узел, sc-дуга, sc-ребро или файл ostis-системы. Тип sc-элемента указывается в паре с
ключевым словом \scnqq{el}: для sc-узла sc-json-тип элемент представляется как \scnqq{node}, для sc-дуги и sc-ребра -
\scnqq{edge}, для файла ostis-системы - \scnqq{link}. Метки типов sc-элементов уточняются в соответствующих им описаниях
в сообщении команды в паре с ключевым словом \scnqq{type}. Если создаваемым sc-элементом является файл ostis-системы, то
дополнительно указывается содержимое этого файла ostis-системы в паре с ключевым словом \scnqq{content}, если создаваемым
sc-элементом является sc-дуга или sc-ребро, то указываются описания sc-элементов, из которых они выходят, и sc-элементов,
в которые они входят. Описание таких sc-элементов состоят из двух пар: первая пара указывает на способ ассоциации с
sc-элементом и представляется как \scnqq{addr} или \scnqq{idtf} или \scnqq{ref} в паре с ключевым словом \scnqq{type},
вторая пара - то, по чему происходит ассоциация с этим sc-элементом: его хэшу, системному идентификатору или номеру
в массиве создаваемых sc-элементов - в паре с ключевым словом \scnqq{value}.

\scnhaselement{Правило, задающее синтаксис \textit{ответа на команду создания sc-элементов}}
\begin{scnindent}
	\scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{author/part6/images/create\_elements\_command\_answer.png}}
	\begin{scnindent}
		\scniselement{Язык описания грамматики языков ANTLR}
    \end{scnindent}
	\scnrelto{синтаксическое правило}{ответ на команду создания sc-элементов}
\end{scnindent}

Сообщением \textit{ответа на команду создания sc-элементов} является список хэшей созданных sc-элементов, соответствующих
описаниям \textit{команды создания sc-элементов} со статусом 1, в случае успешной обработки команды.

\scnheader{команда на SC-JSON-коде}
\scnidtf{sc-json-code command}
\scnsubset{SC-JSON-код}

Множество \textit{команд на SC-JSON-коде} легко расширяемо засчёт гибкости и функциональности языка JSON.

\scnheader{ответ на команду на SC-JSON-коде}
\scnidtf{sc-json-code command answer}
\scnsubset{SC-JSON-код}

Множество \textit{ответов на команды на SC-JSON-коде} легко расширяемо вместе с расширением \textit{команд на SC-JSON-коде}.

\scnheader{команда создания sc-элементов}
\scnidtf{create elements command}
\scnsubset{команда на SC-JSON-коде}
\scnrelfrom{пример}{Пример команды создания sc-элементов}
\begin{scnindent}
    \scneqimage[12em]{author/part6/images/create\_elements\_command\_example.png}
    \scniselement{команда создания sc-элементов}
    \scnrelfrom{ответ}{Пример ответа на команду создания sc-элементов}
\end{scnindent}
\scnrelfrom{класс команд}{ответ на команду создания sc-элементов}

Серверная система на основе Websocket и JSON, обеспечивающая сетевой доступ к sc-памяти, проинтепретирует Пример
команды создания sc-элементов как "Обработать команду создания sc-элементов: sc-узла с типом 1
(неуточняемого типа), файла ostis-системы с типом 2 (неуточняемого типа) и содержимым в виде числа с плавающей точкой
45.4 и sc-дуги типа 32 (константного типа)между sc-элементом, находящимся на нулевой позиции в массиве создаваемых
sc-элементов, и sc-элементом, находящимся на первой позиции в том же самом массиве.".

Стоит отметить, что на уровне интерфейса sc-памяти команда интерпретируется быстро за счёт того, что не используются
шаблоны создания изоморфных им конструкций. Также содержимое сообщения \textit{команды создания sc-элементов} может
быть пустым.

\scnheader{ответ на команду создания sc-элементов}
\scnidtf{create elements command answer}
\scnsubset{ответ на команду на SC-JSON-коде}
\scnrelfrom{пример}{Пример ответа на команду создания sc-элементов}
\begin{scnindent}
    \scneqimage[6em]{author/part6/images/create\_elements\_command\_answer\_example.png}
    \scniselement{ответ на команду создания sc-элементов}
\end{scnindent}

Пример ответа на команду создания sc-элементов является примером ответа на предыдущую команду, если эта команда была
проинтерпретирована и выполнена успешно. Формаьный текст Примера ответа на команду создания sc-элементов равнозначен
естественно-языковому тексту "Созданы sc-элементы с хэшами 323, 534 и 342 соответственно. Команда обработана успешно.".

\textit{Серверная система на основе Websocket и JSON, обеспечивающая сетевой доступ к sc-памяти}, представляет собой
интерпретатор команд и ответов на них \textit{SC-JSON-кода} на программное представление sc-конструкций в sc-памяти при
помощи Библиотеки программных компонентов для обработки и, задающее синтаксис json-текстов JSON for Modern C++ и
Библиотека кросс-платформенных программных компонентов для реализации серверных приложений на основе Websocket WebSocket++,
а также обеспечивается комплексным тестовым покрытием посредством программных фреймворков Google Tests и Google Benchmark Tests.
Библиотека программных компонентов для обработки и, задающее синтаксис json-текстов JSON for Modern C++ имеет богатый,
удобный и быстродействующий функционал, необходимый для реализации подобных компонентов ostis-систем, а Библиотеки
кросс-платформенных программных компонентов для реализации серверных приложений на основе Websocket WebSocket++
позволяет элегантно проектировать серверные системы без использовании избыточных зависимостей и решение. Настройка
программного компонента осуществляется с помощью \textit{Программного компонента настройки программных компонентов
ostis-систем} и скриптов языков CMake и Bash.

\scnheader{Серверная система на основе Websocket и JSON, обеспечивающая сетевой доступ к sc-памяти}
\scnidtf{Система, работающая по принципам Websocket и предоставляющая параллельно-асинхронный многоклиентский доступ к
sc-памяти платформы интерпретации sc-моделей при помощи SC-JSON-кода}
\scnidtf{sc-json-сервер}
\scntext{часто используемый неосновной внешний идентификатор sc-элемента}{sc-сервер}
\scniselement{многократно используемый компонент ostis-систем}
\scniselement{атомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\scnrelto{компонент системы}{Программный вариант реализации платформы интерпретации sc-моделей компьютерных систем}
\begin{scnrelfromlist}{автор}
	\scnitem{Зотов Н. В.}
\end{scnrelfromlist}
\begin{scnrelfromlist}{используемый язык программирования}
	\scnitem{С}
	\scnitem{C++}
\end{scnrelfromlist}
\begin{scnrelfromlist}{используемый язык}
	\scnitem{SC-JSON-код}
\end{scnrelfromlist}
\begin{scnrelfromlist}{зависимости компонента}
    \scnitem{Библиотека программных компонентов для обработки и, задающее синтаксис json-текстов JSON for Modern C++ версии 3.10.5}
    \begin{scnindent}
	    \scnrelto{версия компонента}{Библиотека программных компонентов для обработки и, задающее синтаксис json-текстов JSON for Modern C++}
	    \begin{scnindent}
		    \scniselement{многократно используемый компонент ostis-систем}
		    \scniselement{неатомарный многократно используемый компонент ostis-систем}
		    \scniselement{зависимый многократно используемый компонент ostis-систем}
		    \scntext{адрес хранилища}{https://github.com/nlohmann/json}
		    \begin{scnindent}
			    \scniselement{адрес хранилища на GitHub}
		    \end{scnindent}
	    \end{scnindent}
    \end{scnindent}
    \scnitem{Библиотека кросс-платформенных программных компонентов для реализации серверных приложений на основе
    Websocket WebSocket++. Версия 0.8.2}
    \begin{scnindent}
    	\scnrelto{версия компонента}{Библиотека кросс-платформенных программных компонентов для реализации серверных
        приложений на основе Websocket WebSocket++}
    	\begin{scnindent}
    		\scniselement{многократно используемый компонент ostis-систем}
    		\scniselement{неатомарный многократно используемый компонент ostis-систем}
    		\scniselement{зависимый многократно используемый компонент ostis-систем}
    		\scntext{адрес хранилища}{https://github.com/zaphoyd/websocketpp}
    		\begin{scnindent}
    			\scniselement{адрес хранилища на GitHub}
    		\end{scnindent}
    	\end{scnindent}
    \end{scnindent}
    \scnitem{Программный компонент настройки программных компонентов ostis-систем версия. Версия 0.1.0}
    \begin{scnindent}
    	\scnrelto{версия компонента}{Программный компонент настройки программных компонентов ostis-систем}
    	\begin{scnindent}
    		\scniselement{многократно используемый компонент ostis-систем}
    		\scniselement{неатомарный многократно используемый компонент ostis-систем}
    		\scniselement{зависимый многократно используемый компонент ostis-систем}
    		\begin{scnrelfromlist}{автор}
    		    \scnitem{Зотов Н. В.}
    		    \scnitem{Насевич П. Е.}
    		    \scnitem{Хорошавин В. Д.}
    		\end{scnrelfromlist}
    		\scntext{адрес хранилища}{https://github.com/ostis-ai/sc-machine/tree/main/sc-tools/sc-config-utils}
    		\begin{scnindent}
    			\scniselement{адрес хранилища на GitHub}
    		\end{scnindent}
    	\end{scnindent}
    \end{scnindent}
    \scnitem{Программная модель sc-памяти. Версия 0.7.0-Rebirth}
    \begin{scnindent}
    	\scnrelto{версия компонента}{Программная модель sc-памяти}
    \end{scnindent}
\end{scnrelfromlist}
\scntext{адрес хранилища}{https://github.com/ostis-ai/sc-machine/tree/main/sc-tools/sc-server}
\begin{scnindent}
	\scniselement{адрес хранилища на GitHub}
\end{scnindent}

Стоит отметить, что текущая реализация \textit{Серверная система на основе Websocket и JSON, обеспечивающая сетевой доступ
к sc-памяти} не является первой в своём роде и заменяет предыдущую её реализацию, написанную на языке Python. Причиной
такой замены состоит в следующем:
\begin{scnitemize}
    \item предыдущая реализация \textit{Серверной системы на основе Websocket, обеспечивающая доступ к sc-памяти
    платформы интерпретации sc-моделей при помощи команд SC-JSON-кода}, реализованная на языке программирования Python,
    зависит от библиотеки Boost Python, предоставляемой сообществом по развитию и коллаборации языков С++ и Python.
    Дело в том, что такое решение требует поддержки механизма интерпретации программного кода на языке Python на язык С++,
    что является избыточным и необоснованным, поскольку большая часть программного кода \textit{\textbf{Программного
    варианта реализации платформы интерпретации sc-моделей компьютерных систем}} реализована на языках С и С++. Новая
    реализация описываемой программной системы позволяет избавиться от использования ёмких и ресурсозатратных библиотек
    (например, boost-python-lib, llvm) и языка Python;
    \item при реализации распределённых подсистем важную роль играет скорость обработки знаний, то есть возможность
    быстро и срочно отвечать на запросы пользователя. Качество доступа к sc-памяти посредством реализованной
    \textit{Подсистемы взаимодействия с sc-памятью на основе языка JSON} должно быть соизмеримо с качеством доступа
    к sc-памяти при помощи специализированного программного интерфейса API, реализованного на том же языке
    программирования, что и сама система. Новая реализация позволяет повысить скорость обработки запросов
    \textit{Подсистемой взаимодействия с sc-памятью на основе языка JSON}, в том числе и обработка знаний, не менее
    чем в 1,5 раза по сравнению с предыдущим вариантом реализации этой подсистемы.
\end{scnitemize}

\textit{Серверная система на основе Websocket и JSON, обеспечивающая сетевой доступ к sc-памяти} обладает следующими
общими характеристиками:
\begin{scnitemize}
	\item \textit{Серверная система на основе Websocket, обеспечивающая доступ к sc-памяти платформы интерпретации
    sc-моделей при помощи команд SC-JSON-кода} обеспечивает многофункциональный доступ к sc-памяти ostis-системы и
    удовлетворяет требованиям своей модели. С точки зрения прагматики, программный компонент имеет такой же
    специализированный программный интерфейс, как и \textit{Программная модель sc-памяти}, однако взаимодействие с
    ним осуществляется посредством сети.
	\item Реализованный программный компонент позволяет многопользовательский асинхронный доступ к sc-памяти. В ходе
    тестирования sc-сервера выяснилось, что его реализация позволяет обрабатывать запросы 1000 клиентских систем.
    В связи с необходимостью обеспечения параллельного доступа к sc-памяти на уровне реализации программного
    компонента были добавлены блоки синхронизации. Среди таких можно заметить очередь команд на обработку системой - вне
    зависимости от того сколько клиентских систем и в каком количестве они отправляют команды на обработку, все команды
    добавляются в очередь - такое решение позволит обойти проблемы взаимодействия блоков синхронизации на уровне sc-памяти.
    При этом серверную систему невозможно отключить до тех пор, пока очередь команд имеет какие-нибудь элементы. Также
    серверная система продолжает работать, если в списке идентификаторов клиентских систем остались некоторые
    идентификаторы этих клиентских систем. Эти функции обуславливаются необходимостью поддержки атомарности запросов,
    обрабатываемых системой.
	\item В процессе тестирования реализации \textit{Серверной системы на основе Websocket, обеспечивающая доступ к
    sc-памяти платформы интерпретации sc-моделей при помощи команд SC-JSON-кода}, были получены оценки скорости
    обработки запросов этим компонентом. При нагрузочном тестировании использовалась тестовая клиентская система,
    написанная на С++ и не имеющая функционала обработки текстов SC-JSON-кода. В результате тестирования было выяснено,
    что при отправке серверной системы 1000 различных команд: команд создания sc-элементов, команд обработки содержимого
    файлов ostis-системы и команд удаления sc-элементов, время потраченное на их обработку не превышало 0,2 секунды.
    При этом в отдельных случаях на обработку 1000 команд создания sc-элементов уходило не более 0,14 секунды, команд
    удаления sc-элементов - не более 0,07 секунды, команд обработки содержимого файлов ostis-системы - не более 0,27 секунды,
    команд поиска sc-конструкций, изоморфных заданному sc-шаблону - не более 0,45 секунды.
\end{scnitemize}

\textit{Модель Серверной системы на основе Websocket, обеспечивающей доступ к sc-памяти платформы
интерпретации sc-моделей при помощи команд SC-JSON-кода} описывает необходимый и достаточный программный интерфейс для
взаимодействия c sc-памятью. В общем случае описывает функциональные возможности не только \textit{Серверной системы
на основе Websocket, обеспечивающая доступ к sc-памяти платформы интерпретации sc-моделей при помощи команд SC-JSON-кода},
но и клиентских систем взаимодействующих с ней, поскольку зачастую эти клиентские системы включают специализированный
программный интерфейс, схожий с интерфейсом серверной системы, но на другом языке программирования.

\begin{SCn}
\scnheader{Модель \textit{Серверной системы на основе Websocket и JSON, обеспечивающая сетевой доступ к sc-памяти}}
\begin{scnreltovector}{декартово произведение}
	\scnitem{\scnnonamednode}
	\begin{scnindent}
		\begin{scnreltovector}{декартово произведение}
			\scnitem{\scnnonamednode}
			\begin{scnindent}
				\begin{scnreltovector}{декартово произведение}
					\scnitem{\scnnonamednode}
					\begin{scnindent}
    					\begin{scnreltovector}{декартово произведение}
    						\scnitem{функция создания sc-элементов по их описаниям: типам и инцидентным sc-элементам*}
    						\scnitem{функция получения соответствующих синтаксических типов sc-элементов*}
    					\end{scnreltovector}
					\end{scnindent}
					\scnitem{\scnnonamednode}
					\begin{scnindent}
    				    \begin{scnreltovector}{декартово произведение}
    						\scnitem{функция проверки существования sc-элементов в sc-памяти*}
    						\scnitem{функция получения ключевого sc-элемента по системному идентификатору*}
    					\end{scnreltovector}
					\end{scnindent}
				\end{scnreltovector}
			\end{scnindent}
			\scnitem{\scnnonamednode}
			\begin{scnindent}
				\begin{scnreltovector}{декартово произведение}
					\scnitem{\scnnonamednode}
					\begin{scnindent}
    					\begin{scnreltovector}{декартово произведение}
    						\scnitem{функция разрешения ключевого sc-элемента по системному идентификатору*}
    						\scnitem{функция установки содержимого в файл ostis-системы*}
    					\end{scnreltovector}
					\end{scnindent}
					\scnitem{\scnnonamednode}
					\begin{scnindent}
    					\begin{scnreltovector}{декартово произведение}
    						\scnitem{функция получения содержимого из файлов ostis-системы*}
    						\scnitem{функция получения файлов ostis-системы по содержимому*}
    					\end{scnreltovector}
					\end{scnindent}
				\end{scnreltovector}
			\end{scnindent}
		\end{scnreltovector}
	\end{scnindent}
	\scnitem{\scnnonamednode}
	\begin{scnindent}
		\begin{scnreltovector}{декартово произведение}
			\scnitem{\scnnonamednode}
			\begin{scnindent}
				\begin{scnreltovector}{декартово произведение}
					\scnitem{функция поиска sc-конструкций, изоморфных заданному sc-шаблону, состоящего из троек,
                        специфицированных инцидентными sc-элементами и/или синтаксическими типами и/или идентификаторами
                        и/или псевдонимами их sc-элементов*}
					\scnitem{функция создания sc-конструкции, изоморфной заданному sc-шаблону, состоящего из троек,
                        специфицированных инцидентными sc-элементами и/или синтаксическими типами и/или идентификаторами
                        и/или псевдонимами их sc-элементов*}
				\end{scnreltovector}
			\end{scnindent}
			\scnitem{\scnnonamednode}
			\begin{scnindent}
				\begin{scnreltovector}{декартово произведение}
					\scnitem{функция подписки sc-события на sc-элемент*}
					\scnitem{функция отмены подписки sc-события на sc-элемент*}
				\end{scnreltovector}
			\end{scnindent}
		\end{scnreltovector}
	\end{scnindent}
\end{scnreltovector}
\begin{scneqtoset}
	\scnitem{функция создания sc-элементов по их описаниям: типам и инцидентным sc-элементам*}
	\begin{scnindent}
		\begin{scnreltovector}{декартово произведение}
			\scnitem{\scnnonamednode}
			\begin{scnindent}
			    \begin{scnreltovector}{декартово произведение}
				    \scnitem{Множество всех синтаксических типов sc-элементов}
				    \scnitem{Множество всех sc-элементов, имеющих инцидентные sc-элементы в sc-памяти}
			    \end{scnreltovector}
			\end{scnindent}
			\scnitem{Множество всех sc-элементов, хранящихся в sc-памяти}
		\end{scnreltovector}
		\scntext{примечание}{Создается sc-элемент заданного синтаксического типа из Множества всех синтаксических типов
        sc-элементов и имеющий заданные связи с заданными элементами из Множества всех sc-элементов, имеющих инцидентные
        sc-элементы в sc-памяти, дополняя Множество всех sc-элементов, хранящихся в sc-памяти.}
	\end{scnindent}
	\scnitem{функция получения соответствующих синтаксических типов sc-элементов*}
	\begin{scnindent}
		\begin{scnreltovector}{декартово произведение}
			\scnitem{Множество всех sc-элементов, хранящихся в sc-памяти}
			\scnitem{Множество всех синтаксических типов sc-элементов}
		\end{scnreltovector}
		\scntext{примечание}{У каждого sc-элемента из Множества всех sc-элементов, хранящихся в sc-памяти, можно получить
        соответствующий синтаксический тип из Множества всех синтаксических типов sc-элементов.}
	\end{scnindent}
	\scnitem{функция проверки существования sc-элементов в sc-памяти*}
	\begin{scnindent}
		\begin{scnreltovector}{декартово произведение}
			\scnitem{Множество всех sc-элементов, хранящихся в sc-памяти}
			\scnitem{Множество, состоящее из знаков истины и лжи}
		\end{scnreltovector}
		\scntext{примечание}{Каждый sc-элемент из Множества всех sc-элементов, хранящихся в sc-памяти, должен находиться
        в sc-памяти.}
	\end{scnindent}
	\scnitem{функция получения ключевого sc-элемента по системному идентификатору*}
	\begin{scnindent}
		\begin{scnreltovector}{разность множеств}
			\scnitem{\scnnonamednode}
			\begin{scnindent}
				\begin{scnreltoset}{объединение}
					\scnitem{\scnnonamednode}
					\begin{scnindent}
    					\begin{scnreltovector}{декартово произведение}
    						\scnitem{Множество всех sc-элементов, хранящихся в sc-памяти}
    						\scnitem{Множество всех ключевых sc-элементов, хранящихся в sc-памяти}
    					\end{scnreltovector}
					\end{scnindent}
				    \scnitem{\scnnonamednode}
					\begin{scnindent}
					    \begin{scnreltovector}{декартово произведение}
						    \scnitem{Множество всех системных идентификаторов sc-элементов, хранящихся в файловом хранилище}
						    \scnitem{Множество всех ключевых sc-элементов, хранящихся в sc-памяти}
					    \end{scnreltovector}
					\end{scnindent}
				\end{scnreltoset}
			\end{scnindent}
			\scnitem{функция разрешения ключевого sc-элемента по системному идентификатору*}
		\end{scnreltovector}
		\scntext{примечание}{Каждый ключевой sc-элемент из Множества всех ключевых sc-элементов, хранящихся в sc-памяти,
            является sc-элементом Множества всех sc-элементов, хранящихся в sc-памяти, и имеет, по крайней мере, системный
            идентификатор из Множества всех системных идентификаторов sc-элементов, хранящихся в файловом хранилищеs.}
	\end{scnindent}
	\scnitem{функция разрешения ключевого sc-элемента по системному идентификатору*}
	\begin{scnindent}
		\begin{scnreltovector}{разность множеств}
			\scnitem{\scnnonamednode}
			\begin{scnindent}
    			\begin{scnreltoset}{объединение}
    				\scnitem{\scnnonamednode}
    				\begin{scnindent}
        				\begin{scnreltovector}{декартово произведение}
        					\scnitem{Множество всех sc-элементов, хранящихся в sc-памяти}
        					\scnitem{Множество всех ключевых sc-элементов, хранящихся в sc-памяти}
        				\end{scnreltovector}
    				\end{scnindent}
    				\scnitem{\scnnonamednode}
    				\begin{scnindent}
        				\begin{scnreltovector}{декартово произведение}
        					\scnitem{Множество всех системных идентификаторов sc-элементов, хранящихся в файловом хранилище}
        					\scnitem{Множество всех ключевых sc-элементов, хранящихся в sc-памяти}
        				\end{scnreltovector}
    				\end{scnindent}
    			\end{scnreltoset}
			\end{scnindent}
			\scnitem{функция получения ключевого sc-элемента по системному идентификатору*}
		\end{scnreltovector}
		\scntext{примечание}{Из каждого sc-элемента Множества всех sc-элементов, хранящихся в sc-памяти, можно получить
        ключевой sc-элемент Множества всех ключевых sc-элементов, хранящихся в sc-памяти, зная, по крайней мере, его
        системный идентификатор из Множества всех системных идентификаторов sc-элементов, хранящихся в файловом хранилище.}
	\end{scnindent}
	\scnitem{функция установки содержимого в файл ostis-системы*}
	\begin{scnindent}
		\begin{scnreltovector}{декартово произведение}
			\scnitem{\scnnonamednode}
			\begin{scnindent}
    			\begin{scnreltovector}{декартово произведение}
    				\scnitem{Множество всех файлов ostis-системы, хранящихся в sc-памяти}
    				\scnitem{Множество внешних знаков, являющихся содержимым файлов ostis-системы, хранящиеся в
                    файловом хранилище}
    			\end{scnreltovector}
			\end{scnindent}
			\scnitem{Множество, состоящее из знаков истины и лжи}
		\end{scnreltovector}
		\scntext{примечание}{В каждый sc-элемент из Множества всех файлов ostis-системы, хранящихся в sc-памяти может
        быть установлено содержимое из Множества всего содержимого файлов ostis-системы, хранящегося в файловом хранилище.}
	\end{scnindent}
	\scnitem{функция получения содержимого из файлов ostis-системы*}
	\begin{scnindent}
		\begin{scnreltovector}{декартово произведение}
			\scnitem{Множество всех файлов ostis-системы, хранящихся в sc-памяти}
			\scnitem{Множество внешних знаков, являющихся содержимым файлов ostis-системы, хранящиеся в файловом хранилище}
		\end{scnreltovector}
		\scntext{примечание}{Из каждого файла ostis-системы Множества всех файлов ostis-системы, хранящихся в sc-памяти,
            можно получить содержимое, принадлежащее Множеству внешних знаков, являющихся содержимым файлов ostis-системы,
            хранящиеся в файловом хранилище.}
	\end{scnindent}
	\scnitem{функция получения файлов ostis-системы по содержимому*}
	\begin{scnindent}
		\begin{scnreltovector}{декартово произведение}
			\scnitem{Множество внешних знаков, являющихся содержимым файлов ostis-системы, хранящиеся в файловом хранилище}
			\scnitem{Множество всех файлов ostis-системы, хранящихся в sc-памяти}
		\end{scnreltovector}
		\scntext{примечание}{По содержимому из Множества внешних знаков, являющихся содержимым файлов ostis-системы,
            хранящиеся в файловом хранилище, можно получить подмножество файлов ostis-системы из Множества всех файлов
            ostis-системы, хранящихся в sc-памяти, в которые установлено это содержимое.}
	\end{scnindent}
	\scnitem{функция поиска sc-конструкций, изоморфных заданному sc-шаблону, состоящего из троек, специфицированных
    инцидентными sc-элементами и/или синтаксическими типами и/или идентификаторами и/или псевдонимами их sc-элементов*}
	\begin{scnindent}
		\begin{scnreltovector}{разность множеств}
			\scnitem{\scnnonamednode}
			\begin{scnindent}
				\begin{scnreltovector}{декартово произведение}
					\scnitem{\scnnonamednode}
					\begin{scnindent}
    					\begin{scnreltovector}{декартово произведение}
    						\scnitem{\scnnonamednode}
    						\begin{scnindent}
        						\begin{scnreltovector}{декартово произведение}
        							\scnitem{Множество всех sc-элементов, хранящихся в sc-памяти}
        							\scnitem{Множество всех синтаксических типов sc-элементов}
        						\end{scnreltovector}
    						\end{scnindent}
    						\scnitem{\scnnonamednode}
    						\begin{scnindent}
        						\begin{scnreltovector}{декартово произведение}
        							\scnitem{Множество всех sc-элементов, имеющих инцидентные sc-элементы в sc-памяти}
        							\scnitem{Множество всех идентификаторов sc-элементов, хранящихся в файловом хранилище}
    						    \end{scnreltovector}
    						\end{scnindent}
    					\end{scnreltovector}
					\end{scnindent}
					\scnitem{Множество всех sc-структур}
				\end{scnreltovector}
			\end{scnindent}
			\scnitem{функция создания sc-конструкции, изоморфной заданному sc-шаблону, состоящего из троек,
                специфицированных инцидентными sc-элементами и/или синтаксическими типами и/или идентификаторами и/или
                псевдонимами их sc-элементов*}
		\end{scnreltovector}
		\scntext{примечание}{По синтаксическим типам sc-элементов из Множества всех синтаксических типов sc-элементов
        и/или самим sc-элементам из Множества всех sc-элементов, хранящихся в sc-памяти, связанными с sc-элементами,
            у которых известны синтаксические типы из Множества всех синтаксических типов sc-элементов, в том числе
            инцидентным sc-элементами из Множества всех sc-элементов, имеющих инцидентные sc-элементы в sc-памяти,
            и/или идентификаторам (в том числе псевдонимам) sc-элементов Множества всех идентификаторов sc-элементов,
            хранящихся в файловом хранилище можно найти sc-структуры, принадлежащие Множеству всех sc-структур и состоящие
            из всех этих sc-элементов.}
	\end{scnindent}
	\scnitem{функция создания sc-конструкции, изоморфной заданному sc-шаблону, состоящего из троек, специфицированных
    инцидентными sc-элементами и/или синтаксическими типами и/или идентификаторами и/или псевдонимами их sc-элементов*}
	\begin{scnindent}
		\begin{scnreltovector}{разность множеств}
			\scnitem{\scnnonamednode}
			\begin{scnindent}
				\begin{scnreltovector}{декартово произведение}
					\scnitem{\scnnonamednode}
					\begin{scnindent}
    					\begin{scnreltovector}{декартово произведение}
    						\scnitem{\scnnonamednode}
    						\begin{scnindent}
        						\begin{scnreltovector}{декартово произведение}
        							\scnitem{Множество всех sc-элементов, хранящихся в sc-памяти}
        							\scnitem{Множество всех синтаксических типов sc-элементов}
        						\end{scnreltovector}
    						\end{scnindent}
    						\scnitem{\scnnonamednode}
    						\begin{scnindent}
    						    \begin{scnreltovector}{декартово произведение}
    							    \scnitem{Множество всех sc-элементов, имеющих инцидентные sc-элементы в sc-памяти}
    							    \scnitem{Множество всех идентификаторов sc-элементов, хранящихся в файловом хранилище}
    						    \end{scnreltovector}
    						\end{scnindent}
    					\end{scnreltovector}
					\end{scnindent}
					\scnitem{Множество всех sc-структур}
				\end{scnreltovector}
			\end{scnindent}
			\scnitem{функция поиска sc-конструкций, изоморфных заданному sc-шаблону, состоящего из троек, специфицированных
            инцидентными sc-элементами и/или синтаксическими типами и/или идентификаторами и/или псевдонимами их sc-элементов*}
		\end{scnreltovector}
		\scntext{примечание}{По синтаксическим типам sc-элементов из Множества всех синтаксических типов sc-элементов
        и/или самим sc-элементам из Множества всех sc-элементов, хранящихся в sc-памяти, связанными с sc-элементами, у
        которых известны синтаксические типы из Множества всех синтаксических типов sc-элементов, в том числе инцидентным
        sc-элементами из Множества всех sc-элементов, имеющих инцидентные sc-элементы в sc-памяти, и/или идентификаторам
        (в том числе псевдонимам) sc-элементов Множества всех идентификаторов sc-элементов, хранящихся в файловом
        хранилище всегда можно создать sc-структуру, дополняющую Множество всех sc-структур и состоящую из всех этих
        sc-элементов.}
	\end{scnindent}
	\scnitem{функция подписки sc-события на sc-элемент}
	\begin{scnindent}
		\begin{scnreltovector}{декартово произведение}
			\scnitem{\scnnonamednode}
			\begin{scnindent}
    			\begin{scnreltovector}{декартово произведение}
    				\scnitem{Множество всех sc-элементов, храняшихся в sc-памяти}
    				\scnitem{Множество всех возможных типов sc-событий в sc-памяти}
			    \end{scnreltovector}
			\end{scnindent}
			\scnitem{Множество всех sc-событий, зарегистрированных в sc-памяти}
		\end{scnreltovector}
		\scntext{примечание}{На каждый sc-элемент Множества всех sc-элементов, храняшихся в sc-памяти можно подписать
        sc-cобытие из Множества всех sc-событий, зарегистрированных в sc-памяти типа из Множества всех sc-событий,
        зарегистрированных в sc-памяти.}
	\end{scnindent}
	\scnitem{функция отмены подписки sc-события на sc-элемент}
	\begin{scnindent}
		\begin{scnreltovector}{декартово произведение}
			\scnitem{\scnnonamednode}
			\begin{scnindent}
    			\begin{scnreltovector}{декартово произведение}
    				\scnitem{Множество всех sc-событий, зарегистрированных в sc-памяти}
    				\scnitem{Множество всех sc-элементов, храняшихся в sc-памяти}
    			 \end{scnreltovector}
			\end{scnindent}
			\scnitem{Множество, состоящее из знаков истины и лжи}
		 \end{scnreltovector}
		\scntext{примечание}{На каждый sc-элемент Множества всех sc-элементов, храняшихся в sc-памяти можно отписать от
        sc-cобытия из Множества всех sc-событий, зарегистрированных в sc-памяти.}
	\end{scnindent}
\end{scneqtoset}
\end{SCn}

Сборщик базы знаний из исходных текстов позволяет осуществить сборку базы знаний из набора исходных текстов, записанных
в SCs-коде с ограничениями (см. \textit{Раздел **про исходные тексты**}) в бинарный формат, воспринимаемый
\textit{Программной моделью sc-памяти}. При этом возможна как сборка \scnqq{с нуля} (с уничтожением ранее созданного
слепка памяти), так и аддитивная сборка, когда информация, содержащаяся в заданном множестве файлов, добавляется к уже
имеющемуся слепку состояния памяти. В текущей реализации сборщик осуществляет \scnqq{склеивание} (\scnqq{слияние})
sc-элементов, имеющих на уровне исходных текстов одинаковые \textit{системные sc-идентификаторы}.

\begin{SCn}
\scnheader{Реализация вспомогательных инструментальных средств для работы с sc-памятью}
\scnrelfrom{компонент программной системы}{Реализация сборщика базы знаний из исходных текстов, записанных в SCs-коде}
\begin{scnindent}
    \scnidtf{sc-builder}
    \scnrelfrom{используемый язык}{SCs-код}
\end{scnindent}
\end{SCn}

\begin{SCn}
\scnheader{Реализация базового набора платформенно-зависимых sc-агентов и их общих компонентов}
\scniselement{многократно используемый компонент ostis-систем}
\scniselement{неатомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\begin{scnrelfromlist}{компонент программной системы}
    \scnitem{Реализация базового набора поисковых sc-агентов}
    \begin{scnindent}
        \begin{scnrelfromlist}{используемый язык программирования}
            \scnitem{С}
        \end{scnrelfromlist}
        \begin{scnrelfromlist}{компонент программной системы}
            \scnitem{Реализация Абстрактного sc-агента поиска семантической окрестности заданной сущности}
            \scnitem{Реализация Абстрактного sc-агента поиска всех сущностей, частных по отношению к заданной}
            \scnitem{Реализация Абстрактного sc-агента поиска всех сущностей, общих по отношению к заданной}
            \scnitem{Реализация Абстрактного sc-агента поиска всех sc-идентификаторов, соответствующих заданной сущности}
            \scnitem{Реализация Абстрактного sc-агента поиска базовых sc-дуг, инцидентных заданному sc-элементу}
            \begin{scnindent}
                \begin{scnrelfromlist}{компонент программной системы}
                    \scnitem{Реализация Абстрактного sc-агента поиска базовых sc-дуг, входящих в заданный sc-элемент}
                    \scnitem{Реализация Абстрактного sc-агента поиска базовых sc-дуг, выходящих из заданного sc-элемента}
                    \scnitem{Реализация Абстрактного sc-агента поиска базовых sc-дуг, входящих в заданный sc-элемент, с
                    указанием множеств, которым принадлежат эти sc-дуги}
                    \scnitem{Реализация Абстрактного sc-агента поиска базовых sc-дуг, выходящих из заданного sc-элемента,
                    с указанием множеств, которым принадлежат эти sc-дуги}
                \end{scnrelfromlist}
            \end{scnindent}
        \end{scnrelfromlist}
    \end{scnindent}
    \scnitem{Реализация базового механизма сборки информационного мусора}
    \scnitem{Реализация базового набора интерфейсных sc-агентов}
    \begin{scnindent}
        \begin{scnrelfromlist}{компонент программной системы}
            \scnitem{Реализация Абстрактного sc-агента обработки команд пользовательского интерфейса}
            \scnitem{Реализация Абстрактного sc-агента трансляции из внутреннего представления знаний во промежуточный транспортный формат}
        \end{scnrelfromlist}
    \end{scnindent}
\end{scnrelfromlist}
\end{SCn}

\begin{SCn}
\scnheader{Реализация scp-интерпретатора}
\scniselement{многократно используемый компонент ostis-систем}
\scniselement{неатомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\scnrelto{программная реализация}{Абстрактная scp-машина}
\begin{scnrelfromlist}{используемый язык программирования}
    \scnitem{C++}
\end{scnrelfromlist}
\begin{scnrelfromlist}{компонент программной системы}
    \scnitem{Реализация Абстрактного sc-агента создания scp-процессов;Реализация Абстрактного sc-агента интерпретации scp-операторов}
    \begin{scnindent}
        \begin{scnrelfromlist}{компонент программной системы}
            \scnitem{Реализация Абстрактного sc-агента интерпретации scp-операторов генерации конструкций}
            \scnitem{Реализация Абстрактного sc-агента интерпретации scp-операторов ассоциативного поиска конструкций}
            \scnitem{Реализация Абстрактного sc-агента интерпретации scp-операторов удаления конструкций}
            \scnitem{Реализация Абстрактного sc-агента интерпретации scp-операторов проверки условий}
            \scnitem{Реализация Абстрактного sc-агента интерпретации scp-операторов управления значениями операндов}
            \scnitem{Реализация Абстрактного sc-агента интерпретации scp-операторов управления scp-процессами}
            \scnitem{Реализация Абстрактного sc-агента интерпретации scp-операторов управления событиями}
            \scnitem{Реализация Абстрактного sc-агента интерпретации scp-операторов обработки содержимых числовых файлов}
            \scnitem{Реализация Абстрактного sc-агента интерпретации scp-операторов обработки содержимых строковых файлов}
        \end{scnrelfromlist}
    \end{scnindent}
    \scnitem{Реализация Абстрактного sc-агента синхронизации процесса интерпретации scp-программ}
    \scnitem{Реализация Абстрактного sc-агента уничтожения scp-процессов}
    \scnitem{Реализация Абстрактного sc-агента синхронизации событий в sc-памяти и ее реализации}
\end{scnrelfromlist}
\begin{scnrelfromlist}{автор}
    \scnitem{Шункевич Д. В.}
\end{scnrelfromlist}
\end{SCn}

Важнейшей особенностью Языка SCP является тот факт, что его программы записываются таким же образом, что и обрабатываемые
ими знания, то есть в SC-коде. Это, с одной стороны, дает возможность сделать ostis-системы платформенно-независимыми
(четко разделить \textit{sc-модель компьютерной системы} и платформу интерпретации таких моделей), а с другой стороны
требует наличия в рамках платформы \textit{Реализации scp-интерпретатора}, то есть интерпретатора программ Языка SCP.

Текущая \textit{Реализация scp-интерпретатора} не включает в себя специализированных средств для работы с блокировками,
поскольку механизм блокировок элементов sc-памяти реализован на более низком уровне в рамках \textit{Реализация
sc-хранилища и механизма доступа к нему}.

Наряду с реализацией \textit{Программной модели sc-памяти} важной частью \textit{Программного варианта реализации платформы
интерпретации sc-моделей компьютерных систем} является \textit{Реализация интерпретатора sc-моделей пользовательских
интерфейсов}, которая предоставляет базовые средства просмотра и редактирования базы знаний пользователем, средства для
навигации по базе знаний (задания вопросов к базе знаний) и может дополняться новыми компонентами в зависимости от задач,
решаемых каждой конкретной ostis-системой.

\begin{SCn}
\scnheader{Реализация интерпретатора sc-моделей пользовательских интерфейсов}
\scniselement{многократно используемый компонент ostis-систем}
\scniselement{неатомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\begin{scnrelfromlist}{используемый язык программирования}
    \scnitem{JavaScript}
    \scnitem{TypeScript}
    \scnitem{Python}
\end{scnrelfromlist}
\begin{scnrelfromlist}{автор}
    \scnitem{Корончик Д. Н.}
    \scnitem{Шункевич Д. В.}
	\scnitem{Зотов Н. В.}
\end{scnrelfromlist}
\scnrelfrom{иллюстрация}{\scnfileimage{author/part6/images/sc_web_new_arch}}
\end{SCn}

На данной иллюстрации показан планируемый вариант архитектуры \textit{Реализация интерпретатора sc-моделей пользовательских
интерфейсов}, важным принципом которой является простота и однотипность подключения любых компонентов пользовательского
интерфейса (редакторов, визуализаторов, переключателей, команд меню и т.д.). Для этого реализуется программная прослойка
Sandbox, в рамках которой реализуются низкоуровневые операции взаимодействия с серверной частью и которая обеспечивает
более удобный программный интерфейс для разработчиков компонентов.

Текущая реализация интерпретатора sc-моделей пользовательских интерфейсов имеет большое множество недостатки, а именно:
\begin{scnitemize}
    \item Протокол HTTP предполагает четкое разделение активного клиента и пассивного сервера, который отвечает
    на запросы клиентов. Таким образом, сервер (в данном случае -- sc-память) практически не имеет возможности по
    своей инициативе отправить сообщение клиенту, что повышает безопасность системы, но значительно снижает ее
    интерактивность. Кроме того, такой вариант реализации затрудняет реализацию принятого в Технологии OSTIS
    многоагентного подхода, в частности, затрудняет реализацию sc-агентов на стороне клиента. Указанные проблемы
    могут быть решены путем постоянного мониторинга определенных событий со стороны клиента, однако такой вариант
    неэффективен.
    \item Кроме того, часть интерфейса фактически работает напрямую с sc-памятью с использованием технологии
    WebSocket, а часть -- через прослойку на базе библиотеки tornado для языка программирования Python,
    что приводит к дополнительным зависимостям от сторонних библиотек.
    \item Часть компонентов (например, поле поиска по идентификатору) реализована сторонними средствами и практически
    никак не связана с sc-памятью. Это затрудняет развитие платформы.
    \item Текущая \textit{Реализация интерпретатора sc-моделей пользовательских интерфейсов} ориентирована только на
    ведение диалога с пользователем (в стиле вопрос пользователя -- ответ системы). Не поддерживаются такие очевидно
    необходимые ситуации, как выполнение команды, не предполагающей ответа\char59~возникновение ошибки или отсутствие
    ответа\char59~необходимость задания вопроса системой пользователю и т.д.
    \item Ограничена возможность взаимодействия пользователя с системой без использования специальных элементов
    управления. Например, можно задать вопрос системе, нарисовав его в SCg-коде, но ответ пользователь не увидит, хотя
    в памяти он будет сформирован соответствующим агентом. Большая часть технологий, использованных при реализации
    платформы, к настоящему моменту устарела, что затрудняет развитие платформы.
    \item Идея платформенной независимости пользовательского интерфейса (построения sc-модели пользовательского
    интерфейса) реализована не в полной мере. Полностью описать sc-модель пользовательского интерфейса (включая точное
    размещение, размеры, дизайн компонентов, их поведение и др.) в настоящее время скорее всего окажется затруднительно
    из-за ограничений производительности, однако вполне возможно реализовать возможность задания вопросов ко всем
    компонентам интерфейса, изменить их расположение и т.д., однако эти возможности нельзя реализовать в текущей
    версии реализации платформы.
    \item Интерфейсная часть работает медленно из-за некоторых недостатков реализации серверной части на языке Python.
    \item Не реализован механизм наследования при добавлении новых внешних языков. Например, добавление нового языка
    даже очень близкого к SCg-коду требует физического копирования кода компонента и внесение соответствующих изменений,
    при этом получаются два никак не связанных между собой компонента, которые начинают развиваться независимо друг от
    друга.
    \item Слабый уровень задокументированности текущей \textit{Реализации интерпретатора sc-моделей пользовательских
    интерфейсов}.
\end{scnitemize}

На основе описанных недостатко к будущей реализации прелъявляюьтся следующие требования:
\begin{scnitemize}
    \item Унифицировать принципы взаимодействия всех компонентов интерфейса с \textit{Программной моделью sc-памяти},
    независимо от того, к какому типу относится компонент. Например, список команд меню должен формироваться через тот
    же механизм, что и ответ на запрос пользователя, и команда редактирования, сформированная пользователем, и команда
    добавления нового фрагмента в базу знаний и т.д.
    \item Унифицировать принципы взаимодействия пользователей с системой независимо от способа взаимодействия и
    внешнего языка. Например, должна быть возможность задания вопросов и выполнения других команд прямо через SCg/SCn
    интерфейс. При этом необходимо учитывать принципы редактирования базы знаний, чтобы пользователя не мог под
    видом задания вопроса внести новую информацию в согласованную часть базы знаний.
    \item Унифицировать принципы обработки событий, происходящих при взаимодействии пользователя с компонентами
    интерфейса -- поведение кнопок и других интерактивных компонентов должно задаваться не статически сторонними
    средствами, а реализовываться в виде агента, который, тем не менее, может быть реализован произвольным образом
    (не обязательно на платформенно-независимом уровне). Любое действие, совершаемое пользователем, на логическом
    уровне должно трактоваться и обрабатываться как инициирование агента.
    \item Обеспечить возможность выполнять команды (в частности, задавать вопросы) с произвольным количеством
    аргументов, в том числе -- без аргументов.
    \item Обеспечить возможность отображения ответа на вопрос по частям, если ответ очень большой и для отображения
    требуется много времени.
    \item Каждый отображаемый компонент интерфейса должен трактоваться как изображение некоторого sc-узла, описанного в
    базе знаний. Таким образом, пользователь должен иметь возможность задания произвольных вопросов к любым компонентам
    интерфейса.
    \item Максимально упростить и задокументировать механизм добавления новых компонентов.
    \item Обеспечить возможность добавления новых компонентов на основе имеющихся без создания независимых копий.
    Например, должна быть возможность создать компонент для языка, расширяющего язык SCg новыми примитивами,
    переопределять принципы размещения sc-текстов и т.д.
    \item Свести к минимуму зависимость от сторонних библиотек.
    \item Свести к минимуму использование протокола HTTP (начальная загрузка общей структуры интерфейса), обеспечить
    возможность равноправного двустороннего взаимодействия серверной и клиентской части.
\end{scnitemize}

Очевидно, что реализация большинства из приведенных требований связана не только с собственно вариантом реализации
платформы, но и требует развития теории логико-семантических моделей пользовательских интерфейсов и уточнения в
рамках нее общих принципов организации пользовательских интерфейсов ostis-систем. Однако, принципиальная возможность
реализации таких моделей должна быть учтена в рамках реализации платформы.

\begin{SCn}
\scnheader{Реализация интерпретатора sc-моделей пользовательских интерфейсов}
\begin{scnrelfromlist}{компоненты программной системы}
    \scnitem{Панель меню команд пользовательского интерфейса}
    \scnitem{Компонент переключения языка идентификации отображаемых sc-элементов}
    \scnitem{Компонент переключения внешнего языка визуализации знаний}
    \scnitem{Поле поиска sc-элементов по идентификатору}
    \scnitem{Панель отображения диалога пользователя с ostis-системой}
    \scnitem{Панель визуализации и редактирования знаний}
    \begin{scnindent}
        \begin{scnrelfromlist}{компонент программной системы}
            \scnitem{Визуализатор sc.n-текстов}
            \scnitem{Визуализатор и редактор sc.g-текстов}
        \end{scnrelfromlist}
    \end{scnindent}
\end{scnrelfromlist}
\end{SCn}

\textit{Панель меню команд пользовательского интерфейса} содержит изображения классов команд (как атомарных, так и
неатомарных), имеющихся на данный момент в базе знаний и входящих в декомпозицию \textit{Главного меню пользовательского
интерфейса} (имеется в виду полная декомпозиция, которая в общем случае может включать несколько уровней неатомарных
классов команд). Взаимодействие с изображением неатомарного класса команд инициирует команду изображения классов
команд, входящих в декомпозицию данного неатомарного класса команд. Взаимодействие с изображением атомарного класса
команд инициирует генерацию команды данного класса с ранее выбранными аргументами на основе соответствующей
\textit{обобщенной формулировки класса команд} (шаблона класса команд).

\textit{Компонент переключения языка идентификации отображаемых sc-элементов} является изображением множества
имеющихся в системе естественных языков. Взаимодействие пользователя с данным компонентом переключает
пользовательский интерфейс в режим общения с конкретным пользователем с использованием \textit{основных sc-идентификаторов},
принадлежащих данному \textit{естественному языку}. Это значит, что при изображении sc-идентификаторов sc-элементов
на каком-либо языке, например, SCg-коде или SCn-коде будут использоваться \textit{основные sc-идентификаторы},
принадлежащие данному \textit{естественному языку}. Это касается как sc-элементов, отображаемых в рамках
\textit{Панели визуализации и редактирования знаний}, так и любых других sc-элементов, например, классов команд и
даже самих \textit{естественных языков}, изображаемых в рамках самого \textit{Компонента переключения языка идентификации
отображаемых sc-элементов}.

\textit{Компонент переключения внешнего языка визуализации знаний} служит для переключения языка визуализации знаний в
текущем окне, отображаемом на \textit{Панели визуализации и редактирования знаний}. В текущей реализации в качестве
таких языков по умолчанию поддерживаются SCg-код и SCn-код, а также любые другие языки, входящие во множество
\textit{внешних языков визуализации SC-кода}.

\textit{Поле поиска sc-элементов по идентификатору} позволяет осуществлять поиск \mbox{sc-идентификаторов}, содержащих
подстроку, введенную в данное поле (с учетом регистра). В результате поиска отображается список sc-идентификаторов,
содержащих указанную подстроку, при взаимодействии с которыми осуществляется автоматическое задание вопроса
\scnqqi{Что это такое?}, аргументом которого является либо для сам sc-элемент, имеющий данный sc-идентификатор (в случае,
если указанный sc-идентификатор является основным или системным, и, таким образом, указанный sc-элемент может быть
определен однозначно), либо для самого внутреннего файла ostis-системы, являющегося sc-идентификатором (в случае, если
данный sc-идентификатор является неосновным).

\textit{Панель отображения диалога пользователя с ostis-системой} отображает упорядоченный по времени список sc-элементов,
являющихся знаками действий, которые инициировал пользователь в рамках диалога с ostis-системой путем взаимодействия
с изображениями соответствующих классов команд (то есть, если действие было инициировано другим способом, например,
путем его явного инициирования через создание дуги принадлежности множеству \textit{инициированных действий} в
sc.g-редакторе, то на данной панели оно отображено не будет). При взаимодействии пользователя с любым из изображенных
знаков действий на \textit{Панели визуализации и редактирования знаний} отображается окно, содержащее результат выполнения
данного \textit{действия} на том языке визуализации, на котором он был отображен, когда пользователь просматривал его в
последний (предыдущий) раз. Таким образом, в текущей реализации данная панель может работать только в том случае, если
инициированное пользователем действие предполагает явно представленный в памяти результат данного действия. В свою очередь,
из этого следует, что в настоящее время данная панель, как и в целом \textit{Реализация интерпретатора sc-моделей
пользовательских интерфейсов}, позволяет работать с системой только в режиме диалога \scnqqi{вопрос-ответ}.

\textit{Панель визуализации и редактирования знаний} отображает окна, содержащие sc-текст, представленный на
некотором языке из множества \textit{внешних языков визуализации SC-кода} и, как правило, являющийся результатом
некоторого действия, инициированного пользователем. Если соответствующий визуализатор поддерживает возможность
редактирования текстов соответствующего естественного языка, то он одновременно является также и редактором.
При необходимости пользовательский интерфейс каждой конкретной ostis-системы может быть дополнен визуализаторами и
редакторами различных внешних языков, которые в текущей версии \textit{Реализации интерпретатора sc-моделей
пользовательских интерфейсов} будут также располагаться на \textit{Панели визуализации и редактирования знаний}.

%\input{author/references}