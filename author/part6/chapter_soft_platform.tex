\chapter{Программная платформа ostis-систем}
\chapauthortoc{Зотов Н.В.\\Шункевич Д.В.}
\label{chapter_soft_platform}

\vspace{-7\baselineskip}

\begin{SCn}
	
\begin{scnrelfromlist}{автор}
	\scnitem{Зотов Н.В.}
	\scnitem{Шункевич Д.В.}
\end{scnrelfromlist}

\bigskip

\scntext{аннотация}{В главе рассмотрен один из вариантов программной реализации \textit{ostis-платформы} массовой коллективной разработки и эксплуатации интеллектуальных компьютерных систем нового поколения. Детально иллюстрируется пример использования онтологического и компонентного подходов к разработке и описанию подкласса \textit{программных компьютерных систем}, являющихся системами автоматизации проектирования и реализации других \textit{программных компьютерных систем}. Данная глава является \textit{Документацией Программного варианта реализации ostis-платформы}, включающей описание особенностей, аналогов, а также достоинств и недостатков ее реализации.}

\bigskip

\begin{scnrelfromlist}{подраздел}
	\scnitem{\ref{sec_soft_platform_problems}~\nameref{sec_soft_platform_problems}}
	\scnitem{\ref{sec_soft_platform_description}~\nameref{sec_soft_platform_description}}
	\scnitem{\ref{sec_soft_platform_sc_memory}~\nameref{sec_soft_platform_sc_memory}}
	\scnitem{\ref{sec_soft_platform_sc_memory_interface}~\nameref{sec_soft_platform_sc_memory_interface}}
	\scnitem{\ref{sec_soft_platform_file_memory}~\nameref{sec_soft_platform_file_memory}}
	\scnitem{\ref{sec_soft_platform_sc_server_subsystem}~\nameref{sec_soft_platform_sc_server_subsystem}}
	\scnitem{\ref{sec_soft_platform_sci_machine}~\nameref{sec_soft_platform_sci_machine}}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Программный вариант реализации ostis-платформы}
	\begin{scnindent}
		\scntext{часто используемый sc-идентификатор}{Программная платформа ostis-систем}
	\end{scnindent}
	\scnitem{Реализация sc-памяти в ostis-платформе}
	\scnitem{SCin-код}
	\scnitem{Программный интерфейс Реализации sc-памяти в ostis-платформе}
	\scnitem{Реализация файловой памяти в ostis-платформе}
	\scnitem{SCfin-код}
	\scnitem{Реализация подсистемы взаимодействия ostis-платформы с внешней средой}
	\scnitem{SC-JSON-код}
	\scnitem{Реализация интерпретатора sc-моделей пользовательских интерфейсов}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевое знание}
	\scnitem{Спецификация Программного варианта реализации ostis-платформы}
	\begin{scnindent}
		\scntext{часто используемый sc-идентификатор}{Документация Программного варианта реализации ostis-платформы}
		\scnidtf{База знаний Программного варианта реализации ostis-платформы}
	\end{scnindent}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{библиографическая ссылка}
	\scnitem{\scncite{Iliadis2019}}
	\scnitem{\scncite{Sokolov2021}}
	\scnitem{\scncite{Dillon2007}}
	\scnitem{\scncite{Dillon2008}}
	\scnitem{\scncite{Ouksel1999}}
	\scnitem{\scncite{Neiva2016}}
	\scnitem{\scncite{Lu2022}}
	\scnitem{\scncite{Hagoort2009}}
	\scnitem{\scncite{Siekmann1984}}
	\scnitem{\scncite{Lenat1990}}
	\scnitem{\scncite{Gribova2016}}
	\scnitem{\scncite{Fillipov2016}}
	\scnitem{\scncite{Ballinger2009}}
	\scnitem{\scncite{Lenat1995}}
	\scnitem{\scncite{Lehmann2015}}
	\scnitem{\scncite{Bai2022}}
	\scnitem{\scncite{Robinson2015}}
	\scnitem{\scncite{Neo4j}}
	\scnitem{\scncite{Abramskiy2018}}
	\scnitem{\scncite{Vicknair2010}}
	\scnitem{\scncite{Klimanskaya2014}}
	\scnitem{\scncite{Chen2022}}
	\scnitem{\scncite{Naumov1991}}
	\scnitem{\scncite{Gavrilova2001}}
	\scnitem{\scncite{Bashlyakov2010}}
	\scnitem{\scncite{Bashlyakov2013}}
	\scnitem{\scncite{Zapata2010}}
	\scnitem{\scncite{Koronchik2013a}}
	\scnitem{\scncite{Ivashenko2015}}
	\scnitem{\scncite{Shunkevich2018}}
	\scnitem{\scncite{Ostis-sc-machine2023}}
	\scnitem{\scncite{Koronchik2015}}
	\scnitem{\scncite{Shunkevich2021a}}
	\scnitem{\scncite{Zotov2022}}
	\scnitem{\scncite{Fort1996}}
	\scnitem{\scncite{Foggia2001}}
	\scnitem{\scncite{McKay2007}}
	\scnitem{\scncite{Cordella2004}}
	\scnitem{\scncite{Bayer1977}}
	\scnitem{\scncite{Belazzougui2010}}
	\scnitem{\scncite{Bhumij2018}}
	\scnitem{\scncite{Tomasetti2021}}
	\scnitem{\scncite{Marrs2017}}
	\scnitem{\scncite{Standart2021}}
	\scnitem{\scncite{Myers1992}}
	\scnitem{\scncite{Ostis-sc-web2023}}
	\scnitem{\scncite{Koronchik2011}}
	\scnitem{\scncite{Koronchik2012}}
	\scnitem{\scncite{Koronchik2013}}
	\scnitem{\scncite{Koronchik2014}}
	\scnitem{\scncite{Sadouski2022}}
\end{scnrelfromlist}

\end{SCn}

\section*{Введение в Главу \ref{chapter_soft_platform}}

До настоящего времени существует обширное множество различных решений в области автоматизации проектирования и разработки \textit{программных компьютерных систем} (см. \scncite{Iliadis2019}), позволяющих решать задачи достаточно серьезного уровня. Однако ни одна из таких систем не способна обеспечить \textit{платформенную независимость}, а значит и возможность к более легкой интеграции создаваемых \textit{программных компьютерных систем}. Актуальность проблемы объясняется необходимостью создания \textit{программных компьютерных систем нового поколения}, способных \myuline{быстро} и \myuline{качественно} решать \textit{задачи} любого \textit{вида деятельности}.

Современные \textit{программные компьютерные системы}, а также средства автоматизации проектирования и разработки таких систем, обладают рядом значительных недостатков:

\begin{textitemize}
   \item Проектируемые \textit{программные компьютерные системы} в значительной степени остаются зависимыми от реализации конкретных платформ, на которых они проектируются, что, в свою очередь, приводит к существенным затратам на приведение в соответствие методов и средств проектирования систем в случае их перехода на новые платформы (см. \textit{\ref{sec_interpreter_analysis}~\nameref{sec_interpreter_analysis}}).
   \item Проектирование и разработка конкретной \textit{программной компьютерной системы} ведется при помощи разных методов и моделей проектирования \textit{программных компьютерных систем}. Тем самым, описание целевого состояния системы и описание текущей реализации могут не соответствовать друг другу, а интеграция таких решений трудно достижима (cм. \scncite{Sokolov2021}).
   \item Место спецификации \textit{программных компьютерных систем} отводится на второй план, а иногда и вовсе не предусматривается проектом разработки конкретной компьютерной системы. Следовательно, увеличиваются затраты на поддержание процесса перманентного реинжиниринга таких систем (см. \scncite{Dillon2007}, \scncite{Dillon2008}).
   \item При разработке современных \textit{программных компьютерных систем} отсутствует понимание необходимости разработки и описания методов проектирования этих систем, в том числе описания процесса реализации, направлений использования и так далее. По этой причине новое поколение разработчиков \textit{программных компьютерных систем} не использует уже имеющийся накопленный опыт, а изобретает одни и те же либо похожие решения.
   \item Отсутствуют единые универсальные инструментальные средства разработки и реинжиниринга других систем, позволяющие не только автоматизировать их проектирование, но и свести к минимуму саму разработку за счет унификации моделей представления этих систем и наличия семантически мощной \textit{комплексной библиотеки многократно используемых компонентов} (см. \textit{Главу \ref{chapter_library}~\nameref{chapter_library}}).
   \item Даже узкоспециализированные \textit{программные компьютерные системы} должны обладать высоким \textit{уровнем интеллекта} для расширения возможностей в решении более сложных задач. \textit{программные компьютерные системы нового поколения} в отличие от современных \textit{программных компьютерных систем}, должны оперировать \textit{смыслом} того, что они знают и обрабатывают: они должны понимать друг друга, находить точки соприкосновения и образовывать коллективы для решения \textit{задач} любого класса (см. \scncite{Ouksel1999}, \scncite{Neiva2016}, \scncite{Lu2022}, \textit{\ref{sec_cyb_syst_overall_quality}~\nameref{sec_cyb_syst_overall_quality}}).
   \item Для эффективной реализации даже существующих моделей представления знаний и моделей решения трудно формализуемых задач современные компьютеры оказываются плохо приспособленными, что требует разработки принципиально новых платформ и компьютеров, обеспечивающих унификацию представления этих знаний (см. \scncite{Hagoort2009}, \scncite{Siekmann1984}).
\end{textitemize}

Обычно системы такого рода проектируются и разрабатываются для решения узких прикладных задач. В результате образуются системы с описанными выше проблемами. Так, большая часть из описанных проблем, к сожалению, не были решены при создании \textit{систем автоматизации проектирования}, описанных в работах \scncite{Lenat1990}, \scncite{Gribova2016}, \scncite{Fillipov2016}.

При разработке спецификации таких систем важной задачей является задача выбора средств и методов проектирования будущей \textit{ostis-платформы}. Она должна обеспечивать:

\begin{textitemize}
    \item \myuline{\textit{однозначность интерпретации}} и представления \textit{sc-моделей ostis-систем}, обеспечиваемые используемым унифицированным языком представления знаний и онтологии проектирования \textit{ostis-платформ};
    \item \myuline{\textit{семантическую совместимость}} \textit{sc-моделей ostis-систем} и их компонентов между собой;
    \item \myuline{\textit{платформенную независимость}} реализуемых и интерпретируемых на ней \textit{sc-моделей ostis-систем};
    \item \myuline{\textit{простоту}} и \myuline{\textit{гибкость расширения}} своих функциональных возможностей;
    \item \myuline{\textit{функциональную полноту}} для создания \textit{sc-моделей ostis-систем} за счет наличия формальной методологии проектирования ее реализации;
    \item разделение обязанностей между компонентами \textit{ostis-платформы}.
\end{textitemize}

\section{Существующие подходы к проектированию систем автоматизации проектирования и реализации программных компьютерных систем}
\label{sec_soft_platform_problems}

\begin{SCn}

\begin{scnrelfromlist}{ключевое понятие}
	\scnitem{реляционная база данных}
	\scnitem{реляционная модель данных}
	\scnitem{графовая база данных}
	\scnitem{графовая модель данных}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Платформа SMILA}
	\scnitem{Платформа Teradata}
	\scnitem{Платформа SYC}
	\scnitem{Платформа Semantic Web}
	\scnitem{Платформа Neo4j}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевое знание}
	\scnitem{Аналоги Программной платформы ostis-систем}
	\scnitem{Отличие графовых баз данных от реляционных баз данных}
	\scnitem{Способы программной реализации ostis-платформы}
\end{scnrelfromlist}

\end{SCn}

Реализация хранилищ данных, используемых в подавляющем большинстве \textit{программных компьютерных систем}, основывается на \textit{реляционной модели данных}. Примерами таких систем для обработки \textit{неструктурированных} и \textit{слабоструктурированных данных} являются: \textit{Платформа SMILA} (\textit{SeMantic Information Logistic Architecture}), \textit{Платформа Teradata} (\textit{Teradata Aster Discovery Platform}, см. \scncite{Ballinger2009}), реализующие реляционную, поколоночную и гибридную модели хранения записей в базе данных с массово-параллельной архитектурой, \textit{Платформа CYC} (см. \scncite{Lenat1995}) и \textit{Платформа Semantic Web} (см. \scncite{Lehmann2015}). Перечисленные платформы являются \textit{Аналогами Программной платформы ostis-систем}.

В настоящее время информационные системы подвергаются интенсивной \textit{интеллектуализации}. В первую очередь, это вызвано повышением уровня сложности решаемых задач. \textit{интеллектуализация} информационных систем требует от технологий разработки программных систем учета слабоформализуемой, возможно не полностью определенной, нечеткой, темпоральной, пространственно-распределенной информации и, как следствие, получения \textit{структурированных}, \textit{слабоструктурированных} и \textit{неструктурированных данных}. Увеличение числа интеллектуальных задач обработки больших объемов данных во всех сферах деятельности человека приводит к потребности создания универсальных средств хранения, представления и обработки \textit{сложноструктурированной информации}.

Наличие таких задач стимулирует \myuline{переход от традиционных \textit{реляционных баз данных} к их графовым аналогам}. Это объясняется не столько эффективностью организации памяти и обработки данных в \textit{графовых базах данных}, сколько важностью представления конфигураций связей (то есть \textit{смысла}) между ними (см. \scncite{Bai2022}). Подробное изъяснение принципов организации \textit{графовых данных} в \textit{базах данных} можно найти в работе авторов популярной  \textbf{\textit{Платформы Neo4j}} (см. \scncite{Robinson2015}, \scncite{Neo4j}).

Для общего понимания всей проблемы, связанной с представлением и обработкой данных и знаний, рассмотрим несколько современных реализаций \textit{графовых моделей данных} в виде программных продуктов. Любая из описанных ниже \textit{баз данных} предназначена для удобного хранения и доступа к данным, представленным в виде \textit{графовых структур}. По организации памяти и процессу обработки данных \textit{графовые базы данных} можно классифицировать на следующие виды:
\begin{textitemize}
    \item \textit{базы данных с локальным хранением и обработкой графов} (\textit{Neo4j}, \textit{HyperGraphDB}, \textit{AllegroGraph});
    \item \textit{базы данных с распределенным хранением и обработкой данных} (\textit{Horton}, \textit{InfiniteGraph});
    \item \textit{базы данных в формате \scnqq{ключ-значение}} (\textit{Trinity}, \textit{CloudGraph}, \textit{RedisGraph}, \textit{VertexDB});
    \item \textit{документо-ориентированные базы данных} (\textit{OrientDB});
    \item \textit{надстройки над SQL-ориентированными базами данных} (\textit{Filament}, \textit{G-store});
    \item \textit{графовые базы данных с моделью MapReduce} (\textit{Pregel}, \textit{Apache Giraph}, \textit{GraphLab}).
\end{textitemize}

С подробным описанием каждой из представленных \textit{баз данных} можно ознакомиться в работах, посвященных сравнению \textit{реляционных} и \textit{графовых баз данных}: \scncite{Abramskiy2018}, \scncite{Vicknair2010}, \scncite{Klimanskaya2014}, \scncite{Chen2022}.

Мотивация перехода от \textit{реляционных баз данных} к \textit{графовым базам данных} объясняется преимуществами организации модели памяти и обработки данных в них:
\begin{textitemize}
    \item Производительность обработки данных улучшается на один или более порядков при представлении данных в виде \textit{графов}, что объясняется свойствами самого \textit{графа}. В отличие от \textit{реляционных баз данных}, где производительность запросов с увеличением интенсивности запросов ухудшается по мере увеличения набора данных, производительность \textit{графовой модели данных} остается постоянной, даже когда набор данных растет. Это связано с тем, что обработка данных локализуется в некоторой части \textit{графа}. В результате время выполнения каждого запроса равно пропорционально только размеру части \textit{графа}, пройденной для удовлетворения этого запроса, а не размеру всего \textit{графа}.
    \item \textit{графовые модели данных} имеют огромную выразительную силу. \textit{графовые базы данных} предлагают чрезвычайно гибкую модель данных и способ их представления. \textit{графы} аддитивны, это обеспечивает гибкость добавления новых связей между данными, новые узлы и новые подграфы к уже существующей структуре \textit{графа}, не нарушая ее целостности и связности.
   	\item Многообразие форм представления данных минимизируется за счет уменьшения количества синтаксических аспектов, учитываемых при хранении данных и использовании их в базах данных, поскольку \textit{графовые модели данных} позволяют записывать различные \textit{виды знаний} одним и тем же способом.
\end{textitemize}

Таким образом, переход к \textit{графовым базам данных} позволяет повысить производительность обработки \textit{сложноструктурированных данных} и улучшить масштабируемость системы.

Не смотря на все преимущества \textit{графовых баз данных} по сравнению с \textit{реляционными базами данных}, \textit{программные компьютерные системы нового поколения} в силу своих свойств (см. \textit{Главу \ref{chap_intro}~\nameref{chap_intro}}) должны оперировать не просто \textit{данными}, а \textit{знаниями}. Чтобы понимать \textit{смысл} знаний, необходимо представлять эти знания в понятной форме для каждого: и для человека, и для системы. Говоря об унификации представления всех \textit{видов знаний}, важным считается использование \textit{графовых баз данных} не просто как средств для хранения \textit{структурированных данных}, а для хранения \textit{семантически целостных} и \textit{связанных} между собой знаний.

Стоит также отметить, что акцент ставится не на разработку \textit{программных компьютерных систем} поддержки проектирования других \textit{программных компьютерных систем}, а на разработку \textit{комплексных инструментальных средств поддержки автоматического проектирования интеллектуальных компьютерных систем нового поколения}. Такие инструментальные средства можно сравнивать с \textit{системами управления базами знаний} (см. \scncite{Naumov1991}, \scncite{Gavrilova2001}, \scncite{Bashlyakov2010}, \scncite{Bashlyakov2013}).

В основе \textit{ostis-платформы} должны лежать основополагающие принципы:
\begin{textitemize}
    \item Все тексты, представляемые на \textit{SC-коде}, представляют собой \textit{графовые конструкции}. Поэтому задача разработки \textit{Программного варианта реализации ostis-платформы} сводится к разработке средств хранения и обработки таких \textit{графовых конструкций}. Другими словами, \textit{ostis-платформа} должна обеспечивать функционально полную и однозначную интерпретацию хранимых \textit{графовых конструкций}.
    \item Проектирование \textit{ostis-платформы}, в том числе ее компонентов, должно четко специфицироваться и формулироваться в рамках моделей, методов и средств описания сложных систем, предлагаемых \textit{Технологией OSTIS}. Именно \textit{онтологический подход} к проектированию, эксплуатации и реинжинирингу такого подкласса \textit{программных компьютерных систем} позволит эффективно и универсально разрабатывать другие \textit{ostis-системы} самого различного назначения \scncite{Zapata2010}.
\end{textitemize}

Спецификация такого сложного программного объекта, как \textit{ostis-платформа}, должна быть представлена на формальном \textit{языке представления знаний}, в данном случае на \textit{SC-коде}, тексты которого она хранит и обрабатывает. Язык, который должен описывать \textit{программную реализацию ostis-платформы}, должен являться \textit{подъязыком*} \textit{SC-кода}, то есть должен наследовать все свойства \textit{Синтаксиса} и \textit{Денотационной семантики SC-кода}. Такая модель представления спецификации \textit{программных компьютерных систем} дает безусловно сильные преимущества по сравнению с другими возможными вариантами представления спецификаций:
\begin{textitemize}
    \item Язык, тексты которого система хранит и обрабатывает, и язык спецификации того, как система представляет тексты первого языка в памяти самой себя, являются подмножествами одного и того же языка. Это упрощает не только становление понимания разработчика, который разрабатывает сложную \textit{программную компьютерную систему}, за счет того, что форма представления обрабатываемого этой системой языка и языка ее спецификации \myuline{унифицирована}, но и позволяет открыть для этой системы новые функциональные возможности в познании самой себя. Таким образом, такой подход позволяет повышать качество \textit{интеллектуальной компьютерной системы}, например, \textit{способность к интроспекции}.
    \item \myuline{Нельзя} проектировать и реализовывать \textit{интеллектуальные компьютерные системы} на \textit{программной компьютерной системе}, которая сама таковой не является. Представление спецификации системы в такой форме позволяет повысить уровень ее \textit{интеллекта}.
    \item Нет необходимости в создании дополнительных средств для верификации и анализа работы всей системы, поскольку форма представления языка описания системы \myuline{унифицирована} с языком, тексты которого она хранит и обрабатывает.
\end{textitemize}

В таком случае, это позволяет не только уменьшить количество используемых средств при проектировании и реализации \textit{ostis-платформы}, но и позволяет унифицировать информацию, хранимую в \textit{ostis-платформе} и описывающую \textit{ostis-платформу}, с целью использования этой информации в процессе эволюции компонентов \textit{ostis-платформы}. При этом спецификация \textit{ostis-платформы} остается \myuline{\textit{платформенно-независимой}}, поэтому при смене одного варианта реализации \textit{ostis-платформы} на другой подход к описанию \textit{ostis-платформы} остается одним тем же.

\section{Принципы, лежащие в основе, и структура предлагаемой Программной платформы ostis-систем}
\label{sec_soft_platform_description}

\begin{SCn}
	
\begin{scnrelfromlist}{подраздел}
	\scnitem{\ref{sec_soft_platform_base_principles}~\nameref{sec_soft_platform_base_principles}}
	\scnitem{\ref{sec_soft_platform_doc_principles}~\nameref{sec_soft_platform_doc_principles}}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Программный вариант реализации ostis-платформы}
	\scnitem{Реализация памяти ostis-платформы}
	\scnitem{Спецификация Программного варианта реализации ostis-платформы}
\end{scnrelfromlist}
	
\begin{scnrelfromlist}{ключевое знание}
	\scnitem{Обоснование разработки Программного варианта реализации ostis-платформы}
	\scnitem{Структура Программного варианта реализации ostis-платформы}
	\scnitem{Принципы, лежащие в основе Программного варианта реализации ostis-платформы}
	\scnitem{Принципы документирования Программного варианта реализации ostis-платформы}
	\scnitem{Отличие Программного варианта реализации ostis-платформы от других программных компьютерных систем}
\end{scnrelfromlist}
	
\end{SCn}

Одним из путей, позволяющих осуществлять апробацию, развитие, а в ряде случаев и внедрение новых моделей и технологий вне зависимости от наличия соответствующих аппаратных средств, является разработка программных моделей этих аппаратных средств, которые были бы функционально эквивалентны этим аппаратным средствам, но при этом интерпретировались на базе традиционной аппаратной архитектуры (в данной работе традиционной архитектурой будем считать \textit{архитектуру фон Неймана}, как доминирующую в настоящее время). Очевидно, что производительность таких программных моделей в общем случае будет \myuline{ниже}, чем самих аппаратных решений, однако в большинстве случаев она оказывается достаточной для того, чтобы развивать соответствующую технологию параллельно с разработкой аппаратных средств и осуществления постепенного перевода уже работающих \textit{программных компьютерных систем} с программной модели на аппаратные средства.

Популярность и развитость \textit{графовых баз данных} приводит к тому, что на первый взгляд целесообразным и эффективным кажется разработка \textit{Программного варианта реализации ostis-платформы} на базе одного из таких средств. Однако, существует ряд причин, в силу которых это сделать невозможно. К ним относятся следующие:
\begin{textitemize}
	\item Для обеспечения эффективности хранения и обработки \textit{информационных конструкций} определенного вида (в данном случае --- \textit{sc-конструкций}), должна учитываться специфика этих конструкций. В частности, описанные в работе \scncite{Koronchik2013a} эксперименты показали значительный прирост эффективности собственного решения по сравнению с существующими на тот момент.
	\item В отличие от классических \textit{графовых конструкций}, где \textit{дуга} или \textit{ребро} могут быть инцидентны только \textit{узлу} \textit{графа} (это справедливо и для \textit{rdf-графов}) в \textit{SC-коде} вполне типичной является ситуация, когда \textit{sc-коннектор} инцидентен другому \textit{sc-коннектору} или даже двум \textit{sc-коннекторам} (см. \textit{\ref{sec_sr_scsyntax}~\nameref{sec_sr_scsyntax}}). В связи с этим существующие средства хранения \textit{графовых конструкций} не позволяют в явном виде хранить \textit{sc-конструкции} (\textit{sc-графы}). Данная проблема также решаема при переходе от \textit{неориентированного графа} к \textit{орграфу} (см. \scncite{Ivashenko2015}).
	\item В основе обработки информации в рамках \textit{Технологии OSTIS} лежит \textit{многоагентный подход} (см. \textit{\ref{sec_mas}~\nameref{sec_mas}}), в рамках которого агенты обработки информации, хранимой в sc-памяти (sc-агенты) реагируют на события, происходящие в sc-памяти и обмениваются информацией посредством спецификации выполняемых ими действий в sc-памяти \scncite{Shunkevich2018}. В связи с этим одной из важнейших задач является реализация в рамках \textit{Программного варианта реализации ostis-платформы} возможности подписки на события, происходящие в программной модели sc-памяти, которая на данный момент практически не поддерживается в рамках современных средств хранения и обработки графовых конструкций.
	\item \textit{SC-код} позволяет описывать также внешние \textit{информационные конструкции} любого рода (изображения, текстовые файла, аудио- и видеофайлы и так далее (см. \textit{Главу \ref{chapter_inf_constr}~\nameref{chapter_inf_constr}})), которые формально трактуются как содержимое \textit{sc-элементов}, являющихся знаками \textit{внешних файлов ostis-системы}. Таким образом, компонентом \textit{Программного варианта ostis-платформы} должна быть реализация файловой памяти, которая позволяет хранить указанные конструкции в каких-либо общепринятых форматах. Реализация такого компонента в рамках современных средств хранения и обработки \textit{графовых конструкций} также не всегда представляется возможной.
\end{textitemize}

По совокупности перечисленных причин было принято решение о реализации \textit{Программного варианта реализации ostis-платформы} \myuline{\scnqq{с нуля}} с учетом особенностей хранения и обработки информации в рамках \textit{Технологии OSTIS}.

\begin{SCn}
\scnheader{Программный вариант реализации ostis-платформы}
\scnidtf{Реализация sc-машины}
\scntext{часто используемый sc-идентификатор}{Программная платформа ostis-систем}
\scnidtf{Базовая программная платформа для массового создания интеллектуальных компьютерных систем нового поколения}
\scnidtf{Предлагаемый нами программный вариант реализации ассоциативного семантического компьютера}
\scnidtf{sc-machine}
\scniselement{специализированная ostis-платформа}
\begin{scnindent}
	\begin{scnreltolist}{ключевой знак}
		\scnitem{\ref{sec_interpreter_ostis_platform}~\nameref{sec_interpreter_ostis_platform}}
	\end{scnreltolist}
\end{scnindent}
\scniselement{web-ориентированный вариант реализации ostis-платформы}
\begin{scnindent}
    \scnidtf{вариант реализации платформы интерпретации sc-моделей компьютерных систем, предполагающий взаимодействие пользователей с системой посредством сети Интернет}
\end{scnindent}
\scniselement{многопользовательский вариант реализации ostis-платформы}
\begin{scnindent}
	\begin{scnreltolist}{ключевой знак}
		\scnitem{\ref{sec_interpreter_ostis_platform}~\nameref{sec_interpreter_ostis_platform}}
	\end{scnreltolist}
\end{scnindent}
\scniselement{многократно используемый компонент ostis-систем, хранящийся в виде файлов исходных текстов}
\begin{scnindent}
	\begin{scnreltolist}{ключевой знак}
		\scnitem{\ref{ostis_library_section}~\nameref{ostis_library_section}}
	\end{scnreltolist}
\end{scnindent}
\scniselement{неатомарный многократно используемый компонент ostis-систем}
\begin{scnindent}
	\begin{scnreltolist}{ключевой знак}
		\scnitem{\ref{ostis_library_section}~\nameref{ostis_library_section}}
	\end{scnreltolist}
\end{scnindent}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\begin{scnindent}
	\begin{scnreltolist}{ключевой знак}
		\scnitem{\ref{ostis_library_section}~\nameref{ostis_library_section}}
	\end{scnreltolist}
\end{scnindent}
\scntext{адрес компонента}{https://github.com/ostis-ai/sc-machine}
\begin{scnrelfromset}{декомпозиция программной системы}
    \scnitem{Реализация памяти ostis-платформы}
    \scnitem{Реализация подсистемы взаимодействия с внешней средой с использованием языков сетевого взаимодействия}
    \scnitem{Реализация интерпретатора sc-моделей пользовательских интерфейсов}
    \scnitem{Реализация базового набора платформенно-зависимых sc-агентов и их общих компонентов}
    \scnitem{Реализация менеджера многократно используемых компонентов ostis-систем}
    \begin{scnindent}
    	\begin{scnreltolist}{ключевой знак}
    		\scnitem{\ref{ostis_library_component_manager}~\nameref{ostis_library_component_manager}}
    	\end{scnreltolist}
    \end{scnindent}
\end{scnrelfromset}
\begin{scnrelfromset}{зависимости компонента}
    \scnitem{Реализация памяти ostis-платформы}
    \scnitem{Реализация подсистемы взаимодействия с внешней средой с использованием языков сетевого взаимодействия}
    \scnitem{Реализация интерпретатора sc-моделей пользовательских интерфейсов}
\end{scnrelfromset}
\end{SCn}

\subsection{Принципы, лежащие в основе Программной платформы ostis-систем}
\label{sec_soft_platform_base_principles}

\begin{SCn}
\scnheader{Программный вариант реализации ostis-платформы}
\begin{scnrelfromlistcustom}{принципы, лежащие в основе}
	\scnitemcustom{Текущий \textit{Программный вариант реализации ostis-платформы} является \myuline{web-ориентированным}, поэтому с этой точки зрения каждая \mbox{ostis-система} представляет собой web-сайт, доступный онлайн посредством обычного браузера. Такой вариант реализации обладает очевидным преимуществом --- доступ к системе возможен из любой точки мира, где есть Интернет, при этом для работы с системой не требуется никакого специализированного программного обеспечения. С другой стороны, такой вариант реализации обеспечивает возможность параллельной работы нескольких пользователей с системой.}
	\scnitemcustom{Реализация является \myuline{\textit{кроссплатформенной}} и может быть собрана из исходных текстов в различных \textit{операционных системах}. В то же время, взаимодействие клиентской и серверной части организовано таким образом, что \mbox{web-интерфейс} может быть легко заменен на настольный или мобильный интерфейс, как универсальный, так и специализированный.}
	\scnitemcustom{Текущий вариант реализации ostis-платформы является \myuline{специализированным}, то есть не включает \textit{Реализацию интерпретатора Языка SCP} (см. \textit{\ref{sec_ps_scp}~\nameref{sec_ps_scp}}). На текущем этапе разработки \textit{Программного варианта реализации ostis-платформы} все функционирующие \textit{ostis-системы} являются \textit{платформенно-зависимыми}. Данная проблема прежде всего связана с недостатками выбранной и реализованной модели управления доступа к sc-памяти, что не позволяет в полной мере создавать распределенные коллективы \textit{sc-агентов}, работающих над sc-памятью.}
	\scnitemcustom{\myuline{Ядром платформы} является \textbf{\textit{Реализация памяти ostis-платформы}}, которая одновременно может взаимодействовать как с \textit{Реализацией интерпретатора sc-моделей пользовательских интерфейсов}, так и с любыми сторонними приложениями по соответствующим языкам сетевого взаимодействия (сетевым протоколам). С точки зрения общей архитектуры \textit{Реализация интерпретатора sc-моделей пользовательских интерфейсов} выступает как один из множества возможных внешних компонентов, взаимодействующих с \textit{Реализацией памяти ostis-платформы} по сети. Текущая \textit{Реализация интерпретатора sc-моделей пользовательских интерфейсов} является \textit{платформенно-зависимой}, поскольку не в полной мере реализован интерпретатор базового \textit{Языка SCP}.}
	\scnitemcustom{Текущая \textit{Реализация памяти ostis-платформы} \myuline{функционально полна}, то есть позволяет хранить и представлять \textit{sc-конструкции}, с помощью которых описывается любая \textit{sc-модель ostis-системы}, внешние \textit{информационные конструкции}, не принадлежащие \textit{SC-коду}, а также предоставлять различные уровни доступа для обработки этих конструкций. В контексте текущего \textit{Программного варианта реализации ostis-платформы} \textit{Реализация памяти ostis-платформы} состоит из таких компонентов как: \textit{Реализация sc-памяти в ostis-платформе}, внутри которой представляются sc-конструкции \textit{sc-моделей ostis-систем}, \textit{Реализация файловой памяти ostis-платформы}, внутри которой представляются внешние \textit{информационные конструкции}, не принадлежащие \textit{SC-коду}, то есть содержимое \textit{внутренних файлов ostis-системы}, но дополнительно описывающие, поясняющие и детализирующие \textit{sc-конструкции} \textit{sc-моделей ostis-систем}.}
	\scnitemcustom{Текущий \textit{Программный вариант реализации ostis-платформы} включает \textit{Реализацию менеджера многократно используемых компонентов ostis-систем}. Это связано с тем, что текущая \textit{Реализация менеджера многократно используемых компонентов ostis-систем} использует \textit{Реализацию памяти ostis-платформы} для хранения и обработки спецификации устанавливаемых компонентов, вне зависимости от языка их реализации. Полная спецификация текущей \textit{Реализации менеджера многократно используемых компонентов ostis-систем} находится в \textit{\ref{ostis_library_component_manager}~\nameref{ostis_library_component_manager}}.}
\end{scnrelfromlistcustom}
\end{SCn}

\begin{SCn}
\scnheader{Реализация памяти ostis-платформы}
\scnidtf{Реализация sc-памяти и файловой памяти ostis-платформы}
\scnidtf{Предлагаемый нами программный вариант реализации sc-памяти и файловой памяти ostis-платформы}
\scniselement{многократно используемый компонент ostis-систем, хранящийся в виде файлов исходных текстов}
\scniselement{неатомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\scntext{адрес компонента}{https://github.com/ostis-ai/sc-machine/tree/main/sc-memory}
\begin{scnrelfromset}{декомпозиция программной системы}
	\scnitem{Реализация sc-памяти в ostis-платформе}
	\scnitem{Реализация файловой памяти ostis-платформы}
\end{scnrelfromset}
\begin{scnrelfromset}{зависимости компонента}
	\scnitem{Библиотека методов и структур данных GLib}
	\scnitem{Библиотека методов и структур данных C++ Standard Library}
	\scnitem{Реализация sc-памяти ostis-платформы}
	\scnitem{Реализация файловой памяти ostis-платформы}
\end{scnrelfromset}
\end{SCn}

Стоит отметить, что при переходе с \textit{Реализации памяти ostis-платформы} на ее аппаратную реализацию \textit{файловую память ostis-системы} целесообразно будет реализовывать на основе традиционной линейной памяти (во всяком случае, на первых этапах развития \textit{ассоциативного семантического компьютера} (см. \textit{Главу~\ref{chapter_computers}~\nameref{chapter_computers}})). Текущий вариант \textit{Реализации памяти ostis-платформы} является открытым и доступен на \scncite{Ostis-sc-machine2023}. Спецификацию компонентов текущего \textit{Программного варианта реализации ostis-платформы}, а также оценку их производительности можно найти в работах \scncite{Koronchik2015}, \scncite{Shunkevich2021a} и \scncite{Zotov2022}.

\textit{Принципы, лежащие в основе Программного варианта реализации ostis-платформы} являются только базовыми, все компоненты, входящие в состав \textit{Программного варианта реализации ostis-платформы} имеют свои особенности реализации, а также аналоги, которые необходимо учитывать при реализации всей \textit{ostis-платформы}.

\subsection{Принципы документирования Программной платформы ostis-систем}
\label{sec_soft_platform_doc_principles}

Перманентный реинжиниринг компонентов текущего \textit{Программного варианта реализации ostis-платформы} обеспечивается открытой командой разработчиков, при этом каждый разрабатываемый компонент документируется согласно общепринятым принципам.

\begin{SCn}
\scnheader{Программный вариант реализации ostis-платформы}
\begin{scnrelfromlistcustom}{принципы документирования}
	\scnitemcustom{Вне зависимости от языка реализации каждого компонента \textit{Программного варианта реализации ostis-платформы}, спецификация каждого компонента включает: (1) спецификацию, непосредственно описанную в исходных файлах самого компонента, описывающую программный интерфейс этого компонента, (2) а также спецификацию как части базы знаний ostis-платформы, детально описывающую реализацию этого компонента, в том числе используемые алгоритмы. При этом дублирование спецификации компонентов \textit{Программного варианта реализации ostis-платформы} категорически запрещается. Так, например, спецификация, непосредственно находящаяся в исходном файле с реализацией самих компонентов, описывает особенности применения компонентов с точки зрения внешнего или внутреннего (то есть входящего в состав команды) разработчика, а спецификация, являющаяся частью \textit{sc-текста} \textit{базы знаний} \textit{Программного варианта реализации ostis-платформы}, дополнительно включает особенности, предлагаемые подходы к реализации, а также достоинства и недостатки входящих в состав компонентов.}
	\scnitemcustom{Каждый компонент \textit{Программного варианта реализации ostis-платформы} описывается средствами \textit{Технологии OSTIS}, то есть на \textit{SC-коде}, тексты которого она обрабатывает и хранит. Таким образом, это дает возможности платформе анализировать свое состояние и способствовать поддержанию своего жизненного цикла без участия ее разработчиков. \textit{Программный вариант реализации ostis-платформы} выступает \myuline{полноценным субъектом}, принимающим непосредственное участие в собственной разработке.}
	\scnitemcustom{\textit{Спецификация Программного варианта реализации ostis-платформы} представляет собой \textit{sc-язык}, то есть \myuline{подъязык \textit{SC-кода}}, для которого уточнены \textit{Cинтаксис} и \textit{Денотационная семантика SC-кода} (см. \textit{\ref{sec_sr_scsyntax}~\nameref{sec_sr_scsyntax}, \ref{sec_sr_scdsemantics}~\nameref{sec_sr_scdsemantics}}). Этот \textit{sc-язык} можно представить в виде некоторого семейства более частных sc-языков, которые позволяют описывать:
	\begin{itemize}[labelsep=\tabsize-\bulletsize,leftmargin=\tabsize,label=$\bullet$]
		\item то, как \textit{sc-конструкции} представляются внутри \textit{sc-памяти ostis-платформы};
		\item то, как \textit{информационные конструкции}, которые не принадлежат \textit{SC-коду}, представляются внутри \textit{файловой памяти ostis-платформы};
		\item то, как различные подсистемы \textit{ostis-платформы}, взаимодействуют между собой;
		\item то, какие методы и соответствующие им агенты взаимодействуют с \textit{sc-памятью ostis-платформы};
		\item то, как представляются и работают различного рода интерпретаторы \textit{sc-моделей ostis-систем} (базы знаний, решателя задач, интерфейса);
		\item и так далее.
	\end{itemize}
	Такой подход позволяет без особых препятствий интегрировать описания различных компонентов, входящих в состав \textit{Программного варианта реализации ostis-платформы}, поскольку вся \textit{Спецификация Программного варианта реализации ostis-платформы} является ее базой знаний с четко выделенной иерархией предметных областей и онтологий (то есть \textit{sc-языков}, описывающих ее реализацию).}
	\scnitemcustom{Каждый разработчик \textit{Программного варианта реализации ostis-платформы} заботится о перманентной поддержки не только состояния ее компонентов, но и спецификации этих компонентов. Гарантом качественной \textit{Спецификации Программного варианта реализации ostis-платформы} является ее коллектив разработчиков, способных не только понимать детали реализации \textit{ostis-платформы}, но и способствовать к созданию \myuline{взаимовыгодного сотрудничества} для достижения поставленных целей.}
\end{scnrelfromlistcustom}
\end{SCn}

Данные принципы можно использовать при описании любых других \textit{программных компьютерных систем}, в том числе тех \textit{программных компьютерных систем}, которые не реализуются на данной \textit{ostis-платформе}.

\section{Реализация sc-памяти в Программной платформе ostis-систем}
\label{sec_soft_platform_sc_memory}

\begin{SCn}

\begin{scnrelfromlist}{подраздел}
	\scnitem{\ref{sec_soft_platform_scin_code}~\nameref{sec_soft_platform_scin_code}}
	\scnitem{\ref{sec_soft_platform_scin_code_alphabet_and_syntax}~\nameref{sec_soft_platform_scin_code_alphabet_and_syntax}}
	\scnitem{\ref{sec_soft_platform_scin_code_semantic}~\nameref{sec_soft_platform_scin_code_semantic}}
	\scnitem{\ref{sec_soft_platform_scin_code_problems}~\nameref{sec_soft_platform_scin_code_problems}}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Реализация sc-памяти в ostis-платформе}
	\scnitem{SCin-код}
	\begin{scnindent}
		\scnidtf{sc.in-текст}
	\end{scnindent}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевое знание}
	\scnitem{Спецификация Реализации sc-памяти в ostis-платформе}
	\scnitem{Принципы, лежащие в основе Реализации sc-памяти в ostis-платформе}
	\scnitem{Ответ на Вопрос. Как кодируются sc-конструкции в текущей Реализации sc-памяти в ostis-платформе}
	\begin{scnindent}
		\scnidtf{Спецификация Метаязыка описания представления sc-конструкций в sc-памяти ostis-платформы}
	\end{scnindent}
	\scnitem{Достоинства и недостатки Реализации sc-памяти в ostis-платформе}
\end{scnrelfromlist}

\end{SCn}

Под текущей \textbf{\textit{Реализацией sc-памяти ostis-платформы}} понимается компонент программной модели, осуществляющий хранение sc-конструкций и доступ к ним через \textit{программный интерфейс}.

В рамках данного \textit{Программного варианта реализации ostis-платформы} \textit{sc-память} моделируется в виде набора \textit{сегментов}, каждый из которых представляет собой фиксированного размера упорядоченную последовательность \textit{элементов sc-памяти}, каждый из которых соответствует конкретному \textit{sc-элементу}. В настоящее время каждый сегмент состоит из $2^{16}-1=65535$ \textit{элементов sc-памяти}. Каждый сегмент состоит из набора структур данных, описывающих конкретные \textit{sc-элементы} (элементов sc-памяти). Независимо от типа описываемого sc-элемента каждый \textit{элемент sc-памяти} имеет фиксированный размер (в текущий момент --- 36 байт), что обеспечивает удобство их хранения.

Выделение \textit{сегментов sc-памяти} позволяет, с одной стороны, упростить адресный доступ к \textit{элементам sc-памяти}, с другой стороны --- реализовать возможность выгрузки части \textit{sc-памяти} из \textit{оперативной памяти} на \textit{файловую систему} при необходимости. Во втором случае сегмент \textit{sc-памяти} становится минимальной (атомарной) выгружаемой частью sc-памяти. Механизм выгрузки сегментов реализуется в соответствии с существующими принципами организации виртуальной памяти в современных \textit{операционных системах}.

Максимально возможное число сегментов ограничивается настройками текущей \textit{Реализации sc-памяти в ostis-платформе} (в настоящее время по умолчанию установлено количество \textit{$2^{16}-1=65535$} sc-сегментов, но в общем случае оно может быть другим). Таким образом, технически максимальное количество хранимых \textit{sc-элементов} в текущей реализации составляет около \textit{$4.3 \times 10^{9}$} \textit{sc-элементов}. По умолчанию все сегменты физически располагаются в \textit{оперативной памяти}, если объема памяти не хватает, то предусмотрен механизм выгрузки части \textit{sc-сегментов} на жесткий диск (механизм виртуальной памяти).

Текущий вариант \textit{Реализации sc-памяти в ostis-платформе} предполагает возможность сохранения состояния (слепка) \textit{sc-памяти} на жесткий диск и последующей загрузки из ранее сохраненного состояния. Такая возможность необходима для перезапуска системы, в случае возможных сбоев, а также при работе с исходными текстами \textit{базы знаний}, когда сборка из исходных текстов сводится к формированию слепка состояния памяти, который затем помещается в \textit{Реализации sc-памяти в ostis-платформе}.

\begin{SCn}
\scnheader{Реализация sc-памяти в ostis-платформе}
\scnidtf{Программный вариант реализации графодинамической ассоциативной памяти в Программной платформе ostis-систем}
\scnidtf{Предлагаемый нами вариант реализации графодинамической ассоциативной памяти для ostis-систем}
\scniselement{реализация sc-памяти}
\scniselement{многократно используемый компонент ostis-систем, хранящийся в виде файлов исходных текстов}
\scniselement{атомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\scnrelto{программная модель}{sc-память}
\begin{scnindent}
	\begin{scnreltolist}{ключевой знак}
		\scnitem{Глава \ref{chapter_interpreter}~\nameref{chapter_interpreter}}
	\end{scnreltolist}
    \scnrelto{семейство подмножеств}{сегмент sc-памяти}
    \begin{scnindent}
        \scnidtf{страница sc-памяти}
        \scnrelto{семейство подмножеств}{элемент sc-памяти}
    \end{scnindent}
\end{scnindent}
\begin{scnrelfromset}{зависимости компонента}
    \scnitem{Библиотека методов и структур данных GLib}
    \scnitem{Библиотека методов и структур данных C++ Standard Library}
\end{scnrelfromset}
\begin{scnrelfromlist}{используемый язык программирования}
    \scnitem{C}
    \scnitem{C++}
\end{scnrelfromlist}
\begin{scnrelfromlist}{внутренний язык}
    \scnitem{SCin-код}
\end{scnrelfromlist}
\end{SCn}

В общем случае \textit{sc-память} может быть реализована по-разному. Так, например, другой вариант \textit{sc-памяти ostis-платформы} можно реализовать при помощи программной реализации \textit{Платформы Neo4j}. Отличие такого возможного варианта реализации \textit{sc-памяти} от текущего состоит в том, что хранение \textit{графовых конструкций} и управление потоком действий над ними должно осуществляться в большей мере средствами, предоставляемыми \textit{Платформой Neo4j}, в то же время представление \textit{графовых конструкций} должно реализовываться по-своему, поскольку зависит от \textit{Cинтаксиса SC-кода}.

Такую модель sc-памяти достаточно просто описывать на \textit{sc-языке}, то есть на подъязыке \textit{SC-кода}. Такой язык позволяет описывать то, как внутри памяти \textit{ostis-платформы} представляются тексты языка, на этом же языке. При этом соблюдается не только унификация представления информации, обрабатываемой \textit{ostis-платформой}, и информации, описывающей саму \textit{ostis-платформу}, но и даются возможности для расширения и использования языка в процессе эволюции \textit{ostis-платформы} и ее компонентов, в том числе в процессе эволюции \textit{Реализации sc-памяти в ostis-платформе}.

\subsection{Спецификация Метаязыка описания представления sc-конструкций в sc-памяти ostis-платформы. SCin-код}
\label{sec_soft_platform_scin_code}

\begin{SCn}

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Реализация sc-памяти в ostis-платформе}
	\scnitem{SCin-код}
	\begin{scnindent}
		\scnidtf{sc.in-текст}
	\end{scnindent}
	\scnitem{Алфавит SCin-кода\scnsupergroupsign}
	\scnitem{Синтаксис SCin-кода}
	\scnitem{элемент sc-памяти}
	\scnitem{Денотационная семантика SCin-кода}
\end{scnrelfromlist}
	
\begin{scnrelfromlist}{ключевое знание}
	\scnitem{Отличие SCin-кода от SC-кода}
\end{scnrelfromlist}	
	
\end{SCn}

Раннее упоминалось об \textit{sc-языках}, которые используются при описании компонентов текущего \textit{Программного варианта реализации ostis-платформы}. Один из таких \textit{sc-языков} описывает то, как \textit{sc-конструкции} хранятся внутри \textit{sc-памяти ostis-платформы}. Такой язык называется \textbf{\textit{Метаязыком описания представления sc-конструкций в sc-памяти ostis-платформы}}, или, кратко, \textit{\textbf{SCin-кодом} (Semantic Сode interior)}. \textit{sc-память} текстов \textit{SC-кода} (как некоторую абстрактную модель, по которой можно реализовать \textit{sc-память ostis-платформы}) можно рассматривать как подмножество \textit{sc.in-текста}.

\begin{SCn}
\scnheader{SCin-код}
\scnidtf{Semantic Code interior}
\scnidtf{Язык описания представления SC-кода внутри sc-памяти ostis-платформы}
\scnidtf{Метаязык описания представления sc-конструкций в sc-памяти ostis-платформы}
\scntext{часто используемый sc-идентификатор}{sc.in-текст}
\begin{scnindent}
    \scniselement{имя нарицательное}
\end{scnindent}
\scniselement{абстрактный язык}
\scniselement{метаязык}
\scniselement{sc-язык}
\scnsubset{SC-код}
\scnsuperset{sc-память}
\end{SCn}

\begin{SCn}
\scnheader{следует отличать*}
\begin{scnhaselementset}
	\scnitem{SC-код}
	\begin{scnindent}
		\scnidtf{Универсальный язык внутреннего смыслового представления знаний в памяти ostis-систем}
	\end{scnindent}
	\scnitem{SCin-код}
	\begin{scnindent}
		\scnidtf{Метаязык описания представления SC-кода в sc-памяти ostis-платформы}
		\scnsubset{SC-код}
	\end{scnindent}
\end{scnhaselementset}
\end{SCn}

\subsection{Алфавит и Cинтаксис SCin-кода}
\label{sec_soft_platform_scin_code_alphabet_and_syntax}

\begin{SCn}
	
\begin{scnrelfromlist}{ключевой знак}
	\scnitem{элемент sc-памяти}
	\scnitem{элемент sc-памяти, соответствующий sc-узлу}
	\scnitem{элемент sc-памяти, соответствующий sc-коннектору}
	\scnitem{элемент sc-памяти, имеющий нулевой sc-адрес}
	\scnitem{класс элемента sc-памяти\scnsupergroupsign}
	\scnitem{синтаксический класс элемента sc-памяти\scnsupergroupsign}
	\scnitem{семантический класс элемента sc-памяти\scnsupergroupsign}
	\scnitem{sc-адрес элемента sc-памяти}
	\scnitem{sc-адрес элемента sc-памяти*}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевое знание}
	\scnitem{Синтаксическая классификация элементов SCin-кода}
\end{scnrelfromlist}
	
\end{SCn}

Одним из замечательных достоинств \textit{SC-кода} является то, что синтаксис любого его \textit{подъязыка} наследует свойства \textit{Синтаксиса SC-кода}. То есть форма представления различных знаний, описываемых его подъязыками, остается одна и та же. В данном случае, \textit{Синтаксис SCin-кода} не является исключением и уточняет семантику \textit{Синтаксиса SC-кода}. При этом \textit{Синтаксис SCin-кода}, как и синтаксис любого другого sc-языка, является частью \textit{Денотационной семантики SCin-кода}. То есть \textit{Синтаксис SCin-кода} описывает семантику того, как формируются sc.in-тексты при помощи \textit{Синтаксических правил SCin-кода}. \textbf{\textit{Синтаксис SCin-кода}} задается: (1) \textit{Алфавитом SCin-кода}, (2) отношением инцидентности \textit{sc-адрес элемента sc-памяти*}. \textit{Алфавит SCin-кода\scnsupergroupsign}, а также отношение инцидентности \textit{sc-адрес элемента sc-памяти*} являются подмножествами \textit{Алфавит SC-кода\scnsupergroupsign} и отношений инцидентности \textit{SC-кода} (\textit{см. \ref{sec_semantic_classification_sc-elements}~\nameref{sec_semantic_classification_sc-elements}}) соответственно, при этом правила \textit{Синтаксиса SCin-кода} включают правила \textit{Синтаксиса SC-кода} и правила, которые уточняют нюансы \textit{Синтаксиса SCin-кода}.

\begin{SCn}
\scnheader{Алфавит SCin-кода\scnsupergroupsign}
\scnidtf{синтаксический класс элемента sc-памяти}
\scnidtf{синтаксический тип элемента sc-памяти}
\scnidtf{Множество классов элементов sc-памяти}
\scnidtf{Множество типов элементов sc-памяти}
\scnrelto{алфавит}{SCin-код}
\begin{scneqtoset}
    \scnitem{элемент sc-памяти, соответствующий sc-узлу}
    \scnitem{элемент sc-памяти, соответствующий sc-коннектору}
    \scnitem{элемент sc-памяти, имеющий нулевой sc-адрес}
    \begin{scnindent}
        \scniselement{синглетон}
    \end{scnindent}
\end{scneqtoset}
\end{SCn}

\textbf{\textit{Алфавит SCin-кода\scnsupergroupsign}} состоит из трех синтаксически выделяемых классов элементов sc-памяти: \textit{элемента sc-памяти, соответствующего sc-узлу}, \textit{элемента sc-памяти, соответствующего sc-коннектору}, и \textit{элемента sc-памяти, имеющего нулевой sc-адрес}. Такой алфавит не только позволяет задавать в \textit{sc-памяти} минимальный набор объектов, с которым можно производить вычислительные операции, но и, при необходимости, удобен для расширения. Так, например, даннный алфавит языка можно расширить, добавив в него \textit{элемент sc-памяти, соответствующий внутреннему файлу ostis-системы}, либо \textit{элемент sc-памяти, соответствующий sc-ребру}.

\begin{SCn}
\scnheader{элемент sc-памяти}
\scnidtf{элемент sc-памяти, соответствующий sc-элементу}
\scnidtf{ячейка sc-памяти}
\scnidtf{образ sc-элемента в рамках sc-памяти}
\scnidtf{структура данных, каждый экземпляр которой в рамках sc-памяти соответствует одному sc-элементу}
\scnidtf{sc\_element}
\begin{scnindent}
	\scniselement{C}
\end{scnindent}
\scniselement{sc-элемент}
\scnsuperset{sc-элемент}
\scnrelfrom{разбиение}{Алфавит SCin-кода\scnsupergroupsign}
\end{SCn}

Отношение \textbf{\textit{sc-адрес элемента sc-памяти*}} определяется как \textit{взаимно однозначное соответствие}, первым компонентом каждой ориентированной пары которого является некоторый элемент sc-памяти, соответствующей некоторому sc-элементу, а вторым компонентом является sc-адрес этого \textit{элемента sc-памяти}. То есть каждый \textit{элемент sc-памяти} имеет уникальный \textit{sc-адрес} как некоторый идентификатор, с помощью которого определяется уникальность \textit{элемента sc-памяти}.

Каждый \textbf{\textit{элемент sc-памяти}} в текущей \textit{Реализации sc-памяти в ostis-платформе} может быть однозначно задан его \textit{sc-адресом}, состоящим из \textit{номера sc-сегмента} и \textit{номера элемента sc-памяти} в рамках sc-сегмента. Таким образом, \textit{sc-адрес} служит уникальными координатами \textit{элемента sc-памяти} в рамках \textit{Реализации sc-памяти}.
Для каждого \textit{sc-адреса элемента sc-памяти} можно \textit{взаимно однозначно} поставить в соответствие некоторый \textit{хэш}, полученный в результате применения специальной \textit{хэш-функции*} над этим \textit{sc-адресом элемента sc-памяти}. \textit{хэш} является \textit{неотрицательным целым числом} и является результатом преобразования \textit{номера sc-сегмента sc-памяти} \textit{si}, в котором располагается \textit{элемент sc-памяти}, и \textit{номера} этого \textit{элемента sc-памяти} \textit{ei} \textit{в рамках} этого {sc-сегмента} \textit{si}. В рамках \textit{sc-памяти} используется единственная \textit{хеш-функция*} для получения \textit{хеша sc-адреса элемента sc-памяти} и задается как $f(si, ei) = si << 16 | ei \& 0xffff$, где операция $<<$ --- операция \textit{битового сдвига влево*} левого аргумента на количество единиц, заданное правым аргументом, относительно этой операции, операция $|$ --- операция \textit{битового сложения*}, операция $\&$ --- операция \textit{битового умножения*}, число $0xffff$ --- \textit{Число 65535}, представленное в шестнадцатеричном виде и обозначающее максимальное количество элементов в одном \textit{sc-сегменте sc-памяти}. Числовое выражение \textit{sc-адреса} является \textit{32-битовым целым числом}.

\begin{SCn}
\scnheader{sc-адрес элемента sc-памяти}
\scnidtf{адрес элемента sc-памяти, соответствующего заданному sc-элементу, в рамках текущего состояния реализации sc-памяти в составе программной модели sc-памяти}
\scnidtf{sc\_addr}
\begin{scnindent}
	\scniselement{C}
\end{scnindent}
\scnidtf{ScAddr}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\scniselement{32-битовое целое число}
\end{SCn}

В рамках любой \textit{реализации sc-памяти} должен существовать набор \textit{синтаксических} и \textit{семантических классов элементов sc-памяти\scnsupergroupsign} (меток), которые:
\begin{textitemize}
    \item задают тип элемента на уровне \textit{ostis-платформы} и не имеют соответствующей \textit{sc-дуги принадлежности} (а точнее --- \textit{базовой sc-дуги}), явно хранимой в рамках sc-памяти (ее наличие подразумевается, однако она не хранится явно, поскольку это приведет к бесконечному увеличению числа элементов, которые необходимо хранить в \textit{sc-памяти});
    \item могут быть представлены в виде параметров соответствующих \textit{элементов sc-памяти}, то есть множеством таких элементов, каждый из которых имеет \scnqq{метку}, выраженную некоторым числовым значением;
    \item могут уточнять \textit{класс элементов sc-памяти} с той степенью детализации, которая необходима чтобы, например, при совершении операции поиска с помощью таких \textit{классов элементов sc-памяти\scnsupergroupsign} можно было легко определить класс конкретного из них.
\end{textitemize}

\begin{SCn}
\scnheader{класс элемента sc-памяти\scnsupergroupsign}
\scnidtf{класс всех синтаксических и семантических классов элементов sc-памяти}
\scnidtf{битовая маска, обозначающая синтаксический и семантический класс элемента sc-памяти}
\scnidtf{sc\_type}
\begin{scnindent}
	\scniselement{C}
\end{scnindent}
\scnidtf{ScType}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromset}{разбиение}
	\scnitem{синтаксический класс элемента sc-памяти\scnsupergroupsign}
	\scnitem{семантический класс элемента sc-памяти\scnsupergroupsign}
\end{scnrelfromset}
\end{SCn}

С этой целью, в \textit{SCin-коде} выделяется базовая \textbf{\textit{Cинтаксическая классификация элементов SCin-кода}}. Для того чтобы представлять и хранить любые \textit{sc-конструкции} достаточно иметь только два базовых \textit{класса элементов sc-памяти} (\textit{элемент sc-памяти, соответствующий sc-узлу}, и \textit{элемент sc-памяти, соответствующий sc-коннектору}), при этом остальные \textit{классы элементов sc-памяти} можно добавить в расширенной версии \textit{SCin-кода} и тем самым дореализовать необходимую логику на уровне конкретной реализации \textit{sc-памяти}.

\begin{SCn}
\scnstructheader{Синтаксическая классификация элементов SCin-кода}
\begin{scnsubstruct}

\scnheader{элемент sc-памяти}
\begin{scnrelfromset}{разбиение}
    \scnitem{элемент sc-памяти, соответствующий sc-узлу}
    \begin{scnindent}
    	\scniselement{синтаксический класс элемента sc-памяти\scnsupergroupsign}
    \end{scnindent}
    \scnitem{элемент sc-памяти, соответствующий sc-коннектору}
    \begin{scnindent}
    	\scniselement{синтаксический класс элемента sc-памяти\scnsupergroupsign}
    \end{scnindent}
    \scnitem{элемент sc-памяти, имеющий нулевой sc-адрес}
    \begin{scnindent}
    	\scniselement{синтаксический класс элемента sc-памяти\scnsupergroupsign}
    \end{scnindent}
\end{scnrelfromset}

\end{scnsubstruct}
\end{SCn}

Стоит отметить, что все \textbf{\textit{классы элементов sc-памяти\scnsupergroupsign}}, входящие в состав \textit{Cинтаксической классификации элементов SCin-кода}, являются синтаксически выделяемыми \textit{классами элементов SCin-кода}, то есть на уровне \textit{Реализации sc-памяти в ostis-платформе} такие программные модели этих элементов представляются по-разному.

Несмотря на то, что отношение \textit{sc-адрес элемента sc-памяти*} позволяет полностью описать связи \textit{элементов sc-памяти}, для спецификации представления конструкций SC-кода внутри sc-памяти только одного отношения \textit{sc-адрес элемента sc-памяти*} не всегда достаточно, чтобы полностью точно и ясно указывать связи между \textit{элементами sc-памяти}, соответствующими \textit{sc-элементам} этих конструкций. Поэтому на практике при описании представления \textit{sc-конструкций} внутри \textit{sc-памяти} необходимо использовать более частные отношения этого базового отношения, например, такие, как \textit{sc-адрес элемента sc-памяти, соответствующего выходящему sc-коннектору из заданного sc-элемента*}, \textit{sc-адрес элемента sc-памяти, соответствующего входящему sc-коннектору в заданный sc-элемент*} и \textit{sc-адрес элемента sc-памяти, соответствующего инцидентному sc-элементу sc-коннектора*}.

\begin{SCn}
\scnheader{sc-адрес элемента sc-памяти*}
\begin{scnrelfromset}{разбиение}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего выходящему sc-коннектору из заданного sc-элемента*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего входящему sc-коннектору в заданный sc-элемент*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего инцидентному sc-элементу sc-коннектора*}
\end{scnrelfromset}
\end{SCn}

Отношение \textbf{\textit{sc-адрес элемента sc-памяти, соответствующего выходящему sc-коннектору из заданного sc-элемента*}} определяется как \textit{бинарное ориентированное отношение}, первым компонентом каждой \textit{ориентированной пары} которого является некоторый \textit{элемент sc-памяти, соответствующий некоторому sc-элементу}, из которого выходит заданный \textit{sc-коннектор}, а вторым компонентом этой пары является \textit{sc-адрес элемента sc-памяти, соответствующего} этому выходящему \textit{sc-коннектору}. Частными видами этого отношения являются отношение \textit{sc-адрес элемента sc-памяти, соответствующего начальному выходящему sc-коннектору из заданного sc-элемента*}, отношение \textit{sc-адрес элемента sc-памяти, соответствующего следующему выходящему sc-коннектору из заданного sc-элемента*} и отношение \textit{sc-адрес элемента sc-памяти, соответствующего предыдущему выходящему sc-коннектору из заданного sc-элемента*}.

\begin{SCn}
\scnheader{sc-адрес элемента sc-памяти, соответствующего выходящему sc-коннектору из заданного sc-элемента*}
\begin{scnrelfromset}{разбиение}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего начальному выходящему sc-коннектору из заданного sc-элемента*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего следующему выходящему sc-коннектору из заданного sc-элемента*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего предыдущему выходящему sc-коннектору из заданного sc-элемента*}
\end{scnrelfromset}
\end{SCn}

Отношение \textbf{\textit{sc-адрес элемента sc-памяти, соответствующего входящему sc-коннектору в заданный sc-элемент*}} определяется как \textit{бинарное ориентированное отношение}, первым компонентом каждой \textit{ориентированной пары} которого является \textit{некоторый элемент sc-памяти, соответствующий некоторому sc-элементу}, в который входит заданный \textit{sc-коннектор}, а вторым компонентом этой пары является \textit{sc-адрес элемента sc-памяти, соответствующего} этому входящему {sc-коннектору}. Частными видами этого отношения являются отношение \textit{sc-адрес элемента sc-памяти, соответствующего начальному входящему sc-коннектору в заданный sc-элемент*}, отношение \textit{sc-адрес элемента sc-памяти, соответствующего следующему входящему sc-коннектору в заданный sc-элемент*} и отношение \textit{sc-адрес элемента sc-памяти, соответствующего предыдущему входящему sc-коннектору в заданный sc-элемент*}.

\begin{SCn}
\scnheader{sc-адрес элемента sc-памяти, соответствующего входящему sc-коннектору в заданный sc-элемент*}
\begin{scnrelfromset}{разбиение}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего начальному входящему sc-коннектору в заданный sc-элемент*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего следующему входящему sc-коннектору в заданный sc-элемент*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего предыдущему входящему sc-коннектору в заданный sc-элемент*}
\end{scnrelfromset}
\end{SCn}

Отношение \textbf{\textit{sc-адрес элемента sc-памяти, соответствующего инцидентному sc-элементу sc-дуги*}} определяется как \textit{бинарное ориентированное отношение}, первым компонентом каждой \textit{ориентированной пары} которого является некоторый \textit{элемент sc-памяти, соответствующий некоторому sc-коннектору}, а вторым компонентом является \textit{sc-адрес элемента sc-памяти, соответствующего некоторому} инцидентному этому sc-коннектору {sc-элементу}. Частными видами этого отношения являются отношение \textit{sc-адрес элемента sc-памяти, соответствующего начальному sc-элементу sc-коннектора*} и отношение \textit{sc-адрес элемента sc-памяти, соответствующего конечному sc-элементу sc-коннектора*}.

\begin{SCn}
\scnheader{sc-адрес элемента sc-памяти, соответствующего инцидентному sc-элементу sc-коннектора*}
\begin{scnrelfromset}{разбиение}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего начальному sc-элементу sc-коннектора*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего конечному sc-элементу sc-коннектора*}
\end{scnrelfromset}
\end{SCn}

\textbf{\textit{sc-адрес элемента sc-памяти}} никак не учитывается при обработке \textit{базы знаний} на семантическом уровне и необходим только для обеспечения доступа к соответствующей структуре данных, хранящейся в линейной памяти на уровне \textit{Реализации sc-памяти в ostis-платформе}.

В общем случае \textit{sc-адрес элемента sc-памяти, соответствующего заданному sc-элементу}, может меняться, например, при пересборке \textit{базы знаний} из исходных текстов и последующем перезапуске системы. При этом \textit{sc-адрес элемента sc-памяти, соответствующего заданному sc-элементу}, непосредственно в процессе работы системы в текущей реализации меняться не может.

На синтаксические \textit{конструкции SCin-кода}, кроме ограничения самого \textit{SC-кода}, накладываются дополнительные ограничения:
\begin{textitemize}
    \item Для каждого \textit{элемента sc-памяти} взаимно однозначно ставится в соответствие \textit{sc-адрес} этого \textit{элемента sc-памяти}.
    \item Для каждого \textit{элемента sc-памяти, соответствующего sc-узлу}, существует одна и только одна пара отношения \textit{sc-адрес элемента sc-памяти, соответствующего начальному выходящему sc-коннектору из заданного sc-элемента*} и одна и только одна пара отношения \textit{sc-адрес элемента sc-памяти, соответствующего начальному входящему sc-коннектору в заданный sc-элемент*}.
    \item Для каждого \textit{элемента sc-памяти, соответствующего выходящему sc-коннектору из заданного sc-элемента} (\textit{элемента sc-памяти, соответствующего входящему sc-коннектору в заданный sc-элемент}), существует не более чем одна пара отношения \textit{sc-адрес элемента sc-памяти, соответствующего следующему выходящему sc-коннектору из заданного sc-элемента*} (\textit{sc-адрес элемента sc-памяти, соответствующего следующему входящему sc-коннектору в заданный sc-элемент*}) и не более чем одна пара отношения \textit{sc-адрес элемента sc-памяти, соответствующего предыдущему выходящему sc-коннектору из заданного sc-элемента*} (\textit{sc-адрес элемента sc-памяти, соответствующего предыдущему входящему sc-коннектору в заданный sc-элемент*}).
    \item Для каждого \textit{элемента sc-памяти, соответствующего sc-коннектору}, который является вторым компонентом каждой пары отношения \textit{sc-адрес элемента sc-памяти, соответствующего начальному выходящему sc-коннектору из заданного sc-элемента*} (\textit{sc-адрес элемента sc-памяти, соответствующего начальному входящему sc-коннектору в заданный sc-элемент*}) существует только и только одна пара отношения \textit{sc-адрес элемента sc-памяти, соответствующего следующему выходящему sc-коннектору из заданного sc-элемента*} (\textit{sc-адрес элемента sc-памяти, соответствующего следующему входящему sc-коннектору в заданный sc-элемент*}).
\end{textitemize}

\subsection{Денотационная семантика SCin-кода}
\label{sec_soft_platform_scin_code_semantic}

\begin{SCn}
	
\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Спецификация элемента sc-памяти, соответствующего sc-узлу}
	\scnitem{Спецификация элемента sc-памяти, соответствующего sc-коннектору}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевое знание}
	\scnitem{Семантическая классификация элементов SCin-кода}
\end{scnrelfromlist}	
	
\end{SCn}

Для каждого \textit{класса sc-элементов} должна существовать программная модель \textit{класса элементов sc-памяти\scnsupergroupsign}, которая удовлетворяет всем перечисленным требованиям. Поэтому важно, чтобы \textit{Алфавит SCin-кода} изначально был полон, чтобы погрузить не только \textit{sc-конструкции} \textit{Ядра SC-кода}, но и его расширенных версий. Для этого разработаны \textbf{\textit{семантические классы элементов sc-памяти\scnsupergroupsign}}, спецификация которых представляется в виде \textbf{\textit{Семантической классификации элементов SCin-кода}}.

\begin{SCn}
\scnstructheader{Семантическая классификация элементов SCin-кода}
\begin{scnsubstruct}

\scnheader{элемент sc-памяти}
\scnrelfrom{разбиение}{Типология элементов sc-памяти по признаку константности\scnsupergroupsign}
\begin{scnindent}
    \begin{scneqtoset}
        \scnitem{элемент sc-памяти, соответствующий sc-константе}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
        \scnitem{элемент sc-памяти, соответствующий sc-переменной}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
        \scnitem{элемент sc-памяти, соответствующий sc-метапеременной}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
    \end{scneqtoset}
\end{scnindent}
\scnrelfrom{разбиение}{Типология элементов sc-памяти по признаку постоянности\scnsupergroupsign}
\begin{scnindent}
    \begin{scneqtoset}
        \scnitem{элемент sc-памяти, соответствующий}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
        \scnitem{элемент sc-памяти, соответствующий временному sc-элементу}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
    \end{scneqtoset}
\end{scnindent}
\scnrelfrom{разбиение}{Типология элементов sc-памяти по признаку доступности\scnsupergroupsign}
\begin{scnindent}
    \scnidtf{класс уровня доступа к элементу sc-памяти}
    \begin{scneqtoset}
        \scnitem{элемент sc-памяти, соответствующий sc-элементу, на котором разрешено право чтения}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
        \scnitem{элемент sc-памяти, соответствующий sc-элементу, на котором разрешено право записи}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
    \end{scneqtoset}
\end{scnindent}
\scnrelfrom{включение}{элемент sc-памяти, соответствующий внутреннему файлу ostis-системы}

\scnheader{элемент sc-памяти, соответствующий sc-узлу общего вида}
\scnrelfrom{разбиение}{Структурная типология элементов sc-памяти, соответствующих sc-узлам\scnsupergroupsign}
\begin{scnindent}
    \begin{scneqtoset}
        \scnitem{элемент sc-памяти, соответствующий sc-узлу, обозначающему небинарную sc-связку}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
        \scnitem{элемент sc-памяти, соответствующий sc-классу}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
        \scnitem{элемент sc-памяти, соответствующий sc-узлу, обозначающему класс классов}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
        \scnitem{элемент sc-памяти, соответствующий sc-структуре}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
        \scnitem{элемент sc-памяти, соответствующий sc-узлу, обозначающему ролевое отношение}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
        \scnitem{элемент sc-памяти, соответствующий sc-узлу, обозначающему неролевое отношение}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
        \scnitem{элемент sc-памяти, соответствующий sc-узлу, обозначающему первичную сущность}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
    \end{scneqtoset}
\end{scnindent}
\scnrelfrom{разбиение}{Структурная типология элементов sc-памяти, соответствующих sc-дугам\scnsupergroupsign}
\begin{scnindent}
    \begin{scneqtoset}
        \scnitem{элемент sc-памяти, соответствующий sc-дуге принадлежности}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
        \scnitem{элемент sc-памяти, соответствующий sc-дуге общего вида}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
    \end{scneqtoset}
\end{scnindent}
\scnrelfrom{разбиение}{Типология элементов sc-памяти, соответствующих sc-дугам принадлежности, по типу обозначаемой принадлежности\scnsupergroupsign}
\begin{scnindent}
    \begin{scneqtoset}
        \scnitem{элемент sc-памяти, соответствующий sc-дуге позитивной принадлежности}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
        \scnitem{элемент sc-памяти, соответствующий sc-дуге нечеткой принадлежности}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
        \scnitem{элемент sc-памяти, соответствующий sc-дуге негативной принадлежности}
        \begin{scnindent}
        	\scniselement{семантический класс элемента sc-памяти\scnsupergroupsign}
        \end{scnindent}
    \end{scneqtoset}
\end{scnindent}

\end{scnsubstruct}
\end{SCn}

Все семантически и синтаксически выделяемые \textit{классы элементов sc-памяти\scnsupergroupsign}, а также всевозможные подклассы этих классов являются экземплярами (элементами) sc-класса. Все перечисленные классы на уровне программной \textit{Реализации sc-памяти в ostis-платформе} выражаются в виде битов в битовой строке, описываемой в каждом \textit{элементе sc-памяти}.

В текущий момент \textit{sc-ребра} хранятся так же, как \textit{sc-дуги}, то есть имеют начальный и конечный \textit{sc-элементы}, отличие заключается только в \textit{семантическом классе элемента sc-памяти\scnsupergroupsign}. Это приводит к ряду неудобств при обработке, но \textit{sc-ребра} используются в настоящее время достаточно редко.

\textbf{\textit{Спецификация SCin-кода}} является объединением спецификацией его \textit{элементов sc-памяти}.

\begin{SCn}
\scnheader{элемент sc-памяти}
\scnrelfrom{понятие, специфицирующее заданную сущность}{\scnnonamednode}
\begin{scnindent}
    \scnsuperset{сужение отношения по первому домену(спецификация знака*, элемент sc-памяти, соответствующий sc-узлу)*}
    \scnsuperset{сужение отношения по первому домену(понятие, специфицирующее заданную сущность знака*, элемент sc-памяти, соответствующий sc-коннектору)*}
\end{scnindent}
\end{SCn}

Каждый \textit{элемент sc-памяти} описывается его синтаксическим типом (меткой), а также независимо от \textit{класса элемента sc-памяти\scnsupergroupsign} указывается \textit{sc-адрес первого входящего в данный sc-элемент sc-коннектора} и \textit{sc-адрес первого выходящего из данного sc-элемента sc-коннектора} (могут быть пустыми, если таких sc-коннекторов нет). Оставшиеся байты в зависимости от \textit{класса элемента sc-памяти} (sc-узел или sc-коннектор) могут использоваться для хранения спецификации \textit{элемента sc-памяти, соответствующего sc-коннектору}. Также \textit{sc-адрес первой sc-дуги, выходящей из данного sc-элемента*} и \textit{sc-адрес первой sc-дуги, входящей в данный sc-элемент*} в общем случае могут отсутствовать (быть нулевыми, \scnqq{пустыми}), но размер \textit{элемента sc-памяти} в байтах останется тем же.

\begin{SCn}
\scnstructheader{Спецификация элемента sc-памяти, соответствующего sc-узлу}
\begin{scnsubstruct}

\scnheader{элемент sc-памяти, соответствующий sc-узлу}
\begin{scnrelfromset}{понятие, специфицирующее заданную сущность}
    \scnitem{класс элемента sc-памяти\scnsupergroupsign}
    \scnitem{класс уровня доступа к элементу sc-памяти\scnsupergroupsign}
    \scnitem{sc-адрес элемента sc-памяти*}
    \scnitem{sc-адрес первого sc-коннектора, выходящего из данного sc-элемента*}
    \scnitem{sc-адрес первого sc-коннектора, входящего в данный sc-элемент*}
\end{scnrelfromset}

\end{scnsubstruct}

\scnstructheader{Спецификация элемента sc-памяти, соответствующего sc-коннектору}
\begin{scnsubstruct}
	
\scnheader{элемент sc-памяти, соответствующий sc-коннектору}
\begin{scnrelfromset}{понятие, специфицирующее заданную сущность}
    \scnitem{класс элемента sc-памяти\scnsupergroupsign}
    \scnitem{класс уровня доступа к элементу sc-памяти\scnsupergroupsign}
    \scnitem{sc-адрес элемента sc-памяти*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего начальному sc-элементу sc-коннектора*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего конечному sc-элементу sc-коннектора*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего начальному выходящему sc-коннектору из заданного sc-элемента*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего начальному входящему sc-коннектору в заданный sc-элемент*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего следующему выходящему sc-коннектору из заданного sc-элемента*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего следующему входящему sc-коннектору в заданный sc-элемент*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего предыдущему выходящему sc-коннектору из заданного sc-элемента*}
    \scnitem{sc-адрес элемента sc-памяти, соответствующего предыдущему входящему sc-коннектору в заданный sc-элемент*}
\end{scnrelfromset}

\end{scnsubstruct}
\end{SCn}

В текущей \textit{Реализации sc-памяти в ostis-платформе} \textbf{\textit{классы уровня доступа\scnsupergroupsign}} используются для того, чтобы обеспечить возможность ограничения доступа некоторых \textit{процессов в sc-памяти} к некоторым \textit{элементам sc-памяти}. Каждый \textit{элемент sc-памяти} принадлежит одному из двух классов: классу \textit{элементов sc-памяти, соответствующих sc-элементам, на которых разрешено право чтения} и классу \textit{элементов sc-памяти, соответствующих sc-элементам, на которых разрешено право записи}, каждый из которых выражается \textit{целым числом} от 0 до 255.

Таким образом нулевое значение числовых выражений класса \textit{элементов sc-памяти, соответствующих sc-элементам, на которых разрешено право чтения} и класса \textit{элементов sc-памяти, соответствующих sc-элементам, на которых разрешено право записи} означает, что любой процесс может получить неограниченный доступ к данному \textit{элементу sc-памяти}.

В качестве примера на рисунке \nameref{fig:sc_code_in_memory_representation} представлены пятиэлементная sc-конструкция (слева) и конструкция в sc-памяти, представленная на SCin-коде (справа).

\begin{figure*}[htbp]
	\caption{SCg-текст. Пример трансляции sc-текста в sc-память ostis-платформы}
	\includegraphics[scale=0.65]{author/part6/figures/sc_code_in_memory_representation.png}
	\label{fig:sc_code_in_memory_representation}
\end{figure*}

\subsection{Достоинства и недостатки текущего варианта Реализации sc-памяти в ostis-платформе и Метаязыка описания представления sc-конструкций в sc-памяти ostis-платформы}
\label{sec_soft_platform_scin_code_problems}

Описанная модель представления в текущей \textit{Реализации sc-памяти в ostis-платформы} \textit{синтаксических} и \textit{семантических классов sc-элементов} в виде \textit{синтаксических} и \textit{семантических классов элементов sc-памяти\scnsupergroupsign}, которые соответствуют первым, обладает рядом преимуществ:
\begin{textitemize}
	\item \textit{cинтаксические} и {семантические классы элементов sc-памяти\scnsupergroupsign} могут \myuline{комбинироваться} между собой для получения более частных классов. С точки зрения программной реализации такая комбинация может быть представлена операцией \textit{битовое сложение*} \textit{классов элементов sc-памяти\scnsupergroupsign} (здесь, в спецификации на \textit{SC-коде} это можно сделать с помощью пересечения соответствующих классов). Так, например, \textit{битовое сложение*} классов \textit{элементов sc-памяти, соответствующих sc-узл}у и \textit{sc-константе} в результате образуют новый \textit{класс элементов sc-памяти\scnsupergroupsign} --- \textit{элемент sc-памяти, соответствующий константному sc-узлу}.
	\item Числовые выражения некоторых классов могут совпадать. Это сделано для уменьшения размера \textit{элемента sc-памяти} за счет уменьшения максимального размера числового выражения класса этих \textit{элементов sc-памяти}. Конфликт в данном случае не возникает, поскольку такие классы не могут комбинироваться, например \textit{элемент sc-памяти, соответствующий sc-узлу ролевого отношения} и \textit{элемент sc-памяти, соответствующий sc-дуге нечеткой принадлежности}.
	\item Важно отметить, что каждому из выделенных \textit{классов элементов sc-памяти} (кроме классов, получаемых путем комбинации других классов) однозначно соответствует порядковый номер бита в линейной памяти, что можно заметить, глядя на соответствующие числовые выражения этих классов. Это означает, что классы элементов не включаются друг в друга (хоть в спецификации это и не так), например, указание принадлежности к классу \textit{элементов sc-памяти, соответствующих sc-дуге позитивной принадлежности} не означает автоматическое указание принадлежности \textit{элементов sc-памяти, соответствующих sc-дуге принадлежности}. На уровне реализации это позволяет сделать операции комбинирования и сравнения меток более эффективными.
\end{textitemize}

\textit{Реализация sc-памяти в ostis-платформе} учитывает технические аспекты реализации современных \textit{операционных систем}, что дает следующие достоинства:
\begin{textitemize}
	\item Используемый подход адресации \textit{sc-элементов} позволяет загружать сегменты с диска в память, а также выгружать их обратно на диск в любой момент и при этом данная операция не требует дополнительных преобразований. Все содержимое из \textit{оперативной памяти} без изменений попадает на диск. Это дает возможность выгружать неиспользуемые сегменты на диск, что позволяет \textit{sc-памяти} абстрагироваться от имеющихся ресурсов \textit{оперативной памяти} и работать на любых ее объемах;
	\item Максимальное количество хранимых \textit{sc-элементов} можно увеличивать путем расширения \textit{sc-адреса элемента sc-памяти}.
\end{textitemize}

С точки зрения программной \textit{Реализации sc-памяти в ostis-платформе}, структура данных для хранения \textit{sc-узла} и \textit{sc-коннектора} остается остается та же, но в ней меняется список полей (компонентов). Кроме того, как можно заметить каждый \textit{элемент sc-памяти} (в том числе, \textit{элемент sc-памяти, соответствующий sc-дуге}) не хранит список \textit{sc-адресов} связанных с ним \textit{элементов sc-памяти}, а хранит \textit{sc-адреса} одного \textit{выходящего} и одного \textit{входящего элементов sc-памяти, соответствующих sc-коннекторам}, каждый из которых в свою очередь хранит \textit{sc-адреса следующего} и \textit{предыдущего элементов, соответствующих sc-коннекторам}, в списке выходящих и входящих \textit{элементов sc-памяти.} Все перечисленное позволяет:
\begin{textitemize}
	\item сделать размер такой структуры фиксированным (в настоящее время 36 байт) и не зависящим от \textit{синтаксического класса} хранимого \textit{элемента в sc-памяти\scnsupergroupsign};
	\item с минимальными временными затратами добавлять и удалять инцидентные элементы в и из программной структуры \textit{элемента sc-памяти} соответственно;
	\item обеспечить возможность работы с sc-элементами без учета их синтаксического класса в случаях, когда это необходимо (например, при реализации поисковых запросов вида \scnqqi{Какие sc-элементы являются элементами данного множества}, \scnqqi{Какие sc-элементы непосредственно связаны с данным sc-элементом} и так далее);
	\item обеспечить возможность доступа к \textit{элементу sc-памяти} за константное время;
	\item обеспечить возможность помещения \textit{элемента sc-памяти} в процессорный кэш, что в свою очередь, позволяет ускорить обработку \textit{sc-конструкций}.
\end{textitemize}

\section{Программный интерфейс Реализации sc-памяти в ostis-платформе}
\label{sec_soft_platform_sc_memory_interface}

\begin{SCn}

\begin{scnrelfromlist}{подраздел}
	\scnitem{\ref{sec_soft_platform_information_creation_subsystem}~\nameref{sec_soft_platform_information_creation_subsystem}}
	\scnitem{\ref{sec_soft_platform_information_retrieval_subsystem}~\nameref{sec_soft_platform_information_retrieval_subsystem}}
	\scnitem{\ref{sec_soft_platform_information_retrieval_subsystem_extension}~\nameref{sec_soft_platform_information_retrieval_subsystem_extension}}
	\scnitem{\ref{sec_soft_platform_scin_code_example}~\nameref{sec_soft_platform_scin_code_example}}
	\scnitem{\ref{sec_soft_platform_sc_memory_interface_problems}~\nameref{sec_soft_platform_sc_memory_interface_problems}}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Библиотека многократно используемых компонентов Программного варианта реализации ostis-платформы}
	\scnitem{Программный интерфейс Реализации sc-памяти в ostis-платформе}
	\scnitem{Программный интерфейс информационно-формирующих методов Реализации sc-памяти в ostis-платформе}
	\scnitem{Программный интерфейс информационно-поисковых методов Реализации sc-памяти в ostis-платформе}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевое знание}
	\scnitem{Спецификация Программного интерфейса Реализации sc-памяти в ostis-платформе}
	\scnitem{Принципы, лежащие в основе Программного интерфейса Реализации sc-памяти в ostis-платформе}
	\scnitem{Ответ на Вопрос. Как создавать, находить, изменять и удалять конструкции в текущей Реализации sc-памяти в ostis-платформе}
	\scnitem{Достоинства и недостатки Программного интерфейса Реализации sc-памяти в ostis-платформе}
\end{scnrelfromlist}
	
\end{SCn}

\textit{SCin-кода} достаточно, чтобы представлять \textit{sc-тексты} внутри \textit{sc-памяти ostis-платформы}. Чтобы совершить трансляцию некоторого \textit{sc-текста} в \textit{sc-память ostis-платформы} необходимо использовать методы текущей \textit{Реализации sc-памяти в ostis-платформе}. Описанные далее методы sc-памяти являются формальной спецификацией текущего \myuline{\textbf{\textit{Программного интерфейса Реализации sc-памяти в ostis-платформе}}}, с помощью которых можно выполнять действия над \textit{sc-памятью}.

В текущей \textit{Реализации sc-памяти в ostis-платформе} все программные методы реализованы на \textit{языках представления методов} \textit{C} и \textit{С++}. Текущий \textit{Программный интерфейс Реализации sc-памяти в ostis-платформе} содержит необходимый функционал не только для выполнения действий над \textit{элементами sc-памяти}, но и --- над \textit{элементами файловой памяти} (см. \textit{\ref{sec_soft_platform_file_memory}~\nameref{sec_soft_platform_file_memory}}). Данный \textit{программный интерфейс} является \myuline{одним из языков текущего} \myuline{\textit{Программного варианта реализации ostis-платформы}} для выполнения действий над sc-памятью и может быть использован для решения \textit{задач} любой информационной сложности. Так, например, данный программный интерфейс используется в текущих \textit{Реализации Серверной системы на основе Websocket и JSON, обеспечивающей сетевой доступ к этой sc-памяти}, \textit{Реализации менеджера многократных используемых компонентов ostis-систем} и \textit{Реализации интерпретатора логических моделей решения задач}, а также при реализации любых \textit{платформенно-зависимых ostis-систем} любого назначения.

\begin{SCn}
	
\scnheader{Программный интерфейс Реализации sc-памяти в ostis-платформе}
\scnrelto{программный интерфейс}{Реализация sc-памяти в ostis-платформе}
\scniselement{программный интерфейс}
\scniselement{многократно используемый компонент ostis-систем, хранящийся в виде файлов исходных текстов}
\scniselement{атомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\begin{scnrelfromset}{зависимости компонента}
	\scnitem{Библиотека методов и структур данных GLib}
	\scnitem{Библиотека методов и структур данных C++ Standart Library}
\end{scnrelfromset}
\begin{scnrelfromlist}{используемый язык представления методов}
	\scnitem{C}
	\scnitem{C++}
\end{scnrelfromlist}
\begin{scnrelfromlist}{внутренний язык}
	\scnitem{SCin-код}
\end{scnrelfromlist}
\scnsuperset{Программный интерфейс информационно-формирующих методов Реализации sc-памяти в ostis-платформе}
\begin{scnindent}
	\scnidtf{информационно-формирующие методы Реализации sc-памяти в ostis-платформе}
	\scnidtf{подсистема, являющаяся частью Реализации sc-памяти в ostis-платформе, которая позволяет создавать, изменять и удалять конструкции в sc-памяти}
	\scnrelto{программный интерфейс}{Реализация информационно-порождающей подсистемы Реализации sc-памяти в ostis-платформе}
	\begin{scnindent}
		\scnsubset{Реализация sc-памяти в ostis-платформе}
	\end{scnindent}
\end{scnindent}
\scnsuperset{Программный интерфейс информационно-поисковых методов Реализации sc-памяти в ostis-платформе}
\begin{scnindent}
	\scnidtf{информационно-поисковые методы Реализации sc-памяти в ostis-платформе}
	\scnidtf{подсистема, являющаяся частью Реализации sc-памяти в ostis-платформе, которая позволяет находить конструкции в sc-памяти}
	\scnrelto{программный интерфейс}{Реализация информационно-поисковой подсистемы Реализации sc-памяти в ostis-платформе}
	\begin{scnindent}
		\scnsubset{Реализация sc-памяти в ostis-платформе}
	\end{scnindent}
\end{scnindent}

\end{SCn}

Логически текущий \textit{Программный интерфейс Реализации sc-памяти в ostis-платформе} разделяется на два программных интерфейса: \textbf{\textit{Программный интерфейс информационно-формирующих методов Реализации sc-памяти в ostis-платформе}} и \textbf{\textit{Программный интерфейс информационно-поисковых методов Реализации sc-памяти в ostis-платформе}}. В первую очередь, такое разделение связано с тем, что реализация методов информационного поиска в текущей \textit{Реализации sc-памяти в ostis-платформе} достаточна сложна и требует намного большего уточнения при описании этой реализации. Также это разделение \textit{программного интерфейса} позволяет выделять и структурировать спецификацию методов \textit{Программного интерфейса Реализации sc-памяти в ostis-платформе} таким образом, чтобы она оставалась однообразной, компактной и простой для внешнего пользователя. Как такового физического разделения в \textit{Программном интерфейсе Реализации sc-памяти в ostis-платформе} не существует, все методы \textit{Программного интерфейса Реализации sc-памяти в ostis-платформе} можно использовать одним и тем же программным образом и являются компонентами \textbf{\textit{Библиотеки многократно используемых компонентов Программного варианта реализации ostis-платформы}}, то есть могут быть использованы при реализации других компонентов специального назначения.

\subsection{Программный интерфейс информационно-формирующих методов Реализации sc-памяти в ostis-платформе}
\label{sec_soft_platform_information_creation_subsystem}

\begin{SCn}

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Метод создания элемента в sc-памяти, соответствующего некоторому sc-узлу заданного класса}
	\scnitem{Метод создания элемента в sc-памяти, соответствующего некоторому sc-коннектору заданного класса}
	\scnitem{Метод удаления элемента из sc-памяти}
	\scnitem{Метод уточнения класса элемента sc-памяти, соответствующего некоторому sc-элементу}
	\scnitem{Метод получения класса элемента sc-памяти, соответствующего некоторому sc-элементу}
\end{scnrelfromlist}

\end{SCn}

Базовыми методами в {Программном интерфейсе Реализации sc-памяти в ostis-платформе} являются методы, которые позволяют создавать \textit{конструкции в sc-памяти}, изменять их, а также удалять эти конструкции из нее. Физически разделяются процессы создания \textit{элемента sc-памяти, соответствующего sc-узлу}, и \textit{элемента sc-памяти, соответствующего sc-коннектору}, поскольку соответствующие им \textit{sc-элементы} являются синтаксически разными, а сами элементы имеют разные программные модели внутри \textit{Реализации sc-памяти в ostis-платформе}. Однако процесс удаления этих элементов их sc-памяти никоим образом не отличается. Удаление элемента из sc-памяти предполагает физическое извлечение элемента из линейно-адресуемой \textit{sc-памяти} и освобождение занимаемого места в \textit{оперативной памяти} устройства.

\begin{SCn}
\scnstructheader{Библиотека многократно используемых компонентов Программного варианта реализации ostis-платформы}
\begin{scnsubstruct}
	
\scnstructheader{Программный интерфейс информационно-формирующих методов Реализации sc-памяти в ostis-платформе}
\scnhaselement{Метод создания элемента в sc-памяти, соответствующего некоторому sc-узлу заданного класса}
\scnhaselement{Метод создания элемента в sc-памяти, соответствующего некоторому sc-коннектору заданного класса}
\scnhaselement{Метод удаления элемента из sc-памяти}
\scnhaselement{Метод уточнения класса элемента sc-памяти, соответствующего некоторому sc-элементу}
\scnhaselement{Метод получения класса элемента sc-памяти, соответствующего некоторому sc-элементу}

\end{scnsubstruct}
\end{SCn}

\begin{SCn}
\scnheader{Метод создания элемента в sc-памяти, соответствующего некоторому sc-узлу заданного класса}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{ScAddr ScMemoryContext::CreateNode(ScType const \& type)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{класс элемента sc-памяти\scnsupergroupsign}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{sc-адрес элемента sc-памяти}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{некорректный синтаксический класс для создаваемого элемента в sc-памяти}
	\scnitem{некорректный семантический класс для создаваемого элемента в sc-памяти}
\end{scnrelfromlist}

\scnheader{Метод создания элемента в sc-памяти, соответствующего некоторому sc-коннектору заданного класса}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{ScAddr ScMemoryContext::CreateConnector(ScType const \& type, ScAddr const \& begAddr, ScAddr const \& endAddr)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{класс элемента sc-памяти\scnsupergroupsign}
	\scnitem{sc-адрес элемента sc-памяти}
	\scnitem{sc-адрес элемента sc-памяти}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{sc-адрес элемента sc-памяти}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{элемент с заданным sc-адресом не существует в sc-памяти}
	\scnitem{некорректный синтаксический класс для создаваемого элемента в sc-памяти}
	\scnitem{некорректный семантический класс для создаваемого элемента в sc-памяти}
\end{scnrelfromlist}
\end{SCn}

При помощи \textbf{\textit{Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-узлу}} и \textbf{\textit{Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-коннектору}} можно создавать все программные элементы \textit{Алфавита SCin-кода\scnsupergroupsign}, соответствующие sc-элементам \textit{Алфавита SC-кода\scnsupergroupsign} в \textit{sc-памяти ostis-платформы} (см. \textit{\ref{sec_semantic_classification_sc-elements}~\nameref{sec_semantic_classification_sc-elements}}).

Для создания \textit{элемента в sc-памяти, соответствующего sc-узлу}, необходимо указать соответствующий \textit{семантический класс элемента в sc-памяти\scnsupergroupsign}, являющийся подклассом \textit{класса элемента sc-памяти, соответствующего sc-узлу\scnsupergroupsign} (см. \textit{\ref{sec_soft_platform_scin_code_semantic}~\nameref{sec_soft_platform_scin_code_semantic}}). А для создания \textit{элемента в sc-памяти, соответствующего sc-коннектору}, кроме того, что необходимо указать соответствующий \textit{семантический класс элемента в sc-памяти\scnsupergroupsign}, являющийся подклассом \textit{класса элемента sc-памяти, соответствующего sc-коннектору\scnsupergroupsign} (см. \textit{\ref{sec_soft_platform_scin_code_semantic}~\nameref{sec_soft_platform_scin_code_semantic}}), также необходимо указать \textit{sc-адреса} инцидентных ему \textit{элементов sc-памяти}: \textit{sc-адрес элемента sc-памяти}, из которого создаваемый коннектор должен выходить, и \textit{sc-адрес элемента sc-памяти}, в который данный коннектор должен входить. Такими \textit{элементами sc-памяти} могут выступать любые \textit{элементы sc-памяти}, которые уже находятся в ней. При этом при помощи \textit{Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-узлу} и \textit{Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-коннектору} нельзя создавать \textit{элементы sc-памяти, соответствующие sc-коннекторам}, и \textit{элементы sc-памяти, соответствующие sc-узлам}, соответственно (см. \textit{\ref{sec_sr_scsyntax}~\nameref{sec_sr_scsyntax}}). Также не допускается применять \textit{Метод создания элемента в sc-памяти, соответствующего некоторому sc-коннектору заданного класса} для \textit{sc-адресов}, которые не являются \textit{sc-адресами элементов в sc-памяти}. В случае некорректного использования одного из этих методов внешний пользователь метода получит \textit{исключительную ситуацию} с описанием ошибки. При помощи \textit{Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-узлу} можно создавать любые \textit{элементы sc-памяти, соответствующие sc-узлам} или \textit{файлам ostis-системы}, а при помощи \textit{Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-коннектору} --- любые \textit{элементы sc-памяти, соответствующие sc-коннекторам (sc-ребрам или sc-дугам)}.

При помощи \textbf{\textit{Метода создания элемента в sc-памяти, соответствующего некоторому sc-узлу заданного класса}} и \textbf{\textit{Метода создания элемента в sc-памяти, соответствующего некоторому sc-коннектору заданного класса}} можно транслировать в sc-память sc-конструкции любой конфигурации. \textit{Общее описание процесса и пример трансляции sc-текста в sc-память ostis-платформы} рассмотрены в \textit{\ref{sec_soft_platform_scin_code_example}~\nameref{sec_soft_platform_scin_code_example}}.

При реализации прикладных \textit{ostis-систем} очень часто необходимо создавать сложные \textit{конструкции в sc-памяти}. Чтобы упростить разработку и сделать текст разрабатываемого метода, использующего \textit{Программный интерфейс Реализации sc-памяти в ostis-платформе}, более простым и компактным можно использовать \textit{Метод создания конструкции в sc-памяти, изоморфной данному графу-образцу}.

\begin{SCn}
\scnheader{Метод удаления элемента из sc-памяти}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{bool ScMemoryContext::EraseElement(ScAddr const \& addr)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{sc-адрес элемента sc-памяти}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{логическое значение}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{элемент с заданным sc-адресом не существует в sc-памяти}
\end{scnrelfromlist}
\end{SCn}

Любой \textit{элемент sc-памяти} может быть удален из нее. Для того, чтобы удалить заданный \textit{элемент из sc-памяти} необходимо применить \textbf{\textit{Метод удаления элемента из sc-памяти}} с указанным в качестве аргумента \textit{sc-адресом} заданного \textit{элемента sc-памяти}. Если заданный sc-адрес в действительности является \textit{sc-адресом} некоторого \textit{элемента sc-памяти}, то этот элемент будет удален из \textit{sc-памяти}, а метод закончит работу с результатом логического значения \textit{Истина}. Если указанный sc-адрес является \textit{sc-адресом} некоторого \textit{элемента sc-памяти, соответствующего некоторому sc-элементу}, из которого выходят или в который входят \textit{элементы sc-памяти, соответствующие sc-коннекторам}, то из \textit{sc-памяти} также будут эти \textit{элементы sc-памяти, соответствующие sc-коннекторам}.

Стоит отметить, что \textit{действие удаления элемента из sc-памяти} может привести к внештатным ситуациям в самой \textit{ostis-платформе}. Поэтому кроме \textit{Реализации sc-памяти в ostis-платформе} и \textit{Программного интерфейса Реализации sc-памяти в ostis-платформе} должны быть реализованы средства верификации действий над \textit{sc-памятью} (см. \textit{Главу \ref{chapter_kb_design}~\nameref{chapter_kb_design}}).

\begin{SCn}
\scnheader{Метод уточнения класса элемента sc-памяти, соответствующего некоторому sc-элементу}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{bool ScMemoryContext::SetElementSubtype(ScAddr const \& addr, ScType const \& type)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{sc-адрес элемента sc-памяти}
	\scnitem{класс элемента sc-памяти\scnsupergroupsign}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{логическое значение}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{элемент с заданным sc-адресом не существует в sc-памяти}
	\scnitem{некорректный синтаксический класс для уточнения класса элемента sc-памяти}
	\scnitem{некорректный семантический класс для уточнения класса элемента sc-памяти}
\end{scnrelfromlist}
\end{SCn}

На практике частой ситуацией бывает, что пользователю, разработчику или самой системе неизвестны все знания о создаваемом \textit{элементе в sc-памяти} либо об элементах его \textit{семантической окрестности}. Так, например, во время трансляции в \textit{sc-память ostis-платформы} исходных файлов, реализованных на \textit{внешних языках представления знаний}: \textit{SCs-коде} или \textit{SCg-коде} --- зачастую происходит уточнение классов уже созданных элементов sc-памяти. Такие действия над \textit{элементами в sc-памяти ostis-платформы} можно осуществить при помощи \textbf{\textit{Метода уточнения класса элемента sc-памяти, соответствующего некоторому sc-элементу}}. Для этого необходимо задать в качестве аргументов \textit{sc-адрес элемента sc-памяти}, для которого необходимо уточнить класс, и сам \textit{класс элемента sc-памяти\scnsupergroupsign}. В случае успешного выполнения метода в результате пользователем этого метода будет получено логическое значение \textit{Истина}. По правилам \textit{Синтаксиса SC-кода} запрещается указывать несколько \textit{синтаксических классов} для одного и того же \textit{sc-элемента}, также как и запрещается уточнять класс \textit{sc-элемента}, которые не могут быть указаны для \textit{sc-элементов} с заданным \textit{синтаксическим классом}. При попытке совершить такие действия над \textit{элементом sc-памяти} результатом работы \textit{Метода уточнения класса элемента sc-памяти, соответствующего некоторому sc-элементу} будет логическое значение \textit{Ложь}. 

Во всех методах, где используются классы обрабатываемых \textit{элементов sc-памяти}, в качестве операций над классами используются операции \textit{Булевой алгебры}: \textit{битовое сложение*} ($|$), \textit{битовое умножение*} ($\&$) и \textit{битовое отрицание*} ($!$). Так, при помощи операции \textit{битового умножения*} можно определить: является ли заданный класс подклассом \textit{класса} заданного \textit{элемента sc-памяти\scnsupergroupsign}, при помощи операции \textit{битового умножения*} --- уточнять \textit{класс} заданного \textit{элемента sc-памяти\scnsupergroupsign}, а при помощи операции \textit{битового отрицания*} в комбинациях с первыми двумя операциями --- проверять корректность задаваемых \textit{классов элементов sc-памяти\scnsupergroupsign}. Так, например, \textit{битовое сложение*} классов элементов sc-памяти, соответствующих \textit{sc-коннектору} и sc-переменной в результате образуют новый \textit{класс элементов sc-памяти\scnsupergroupsign} --- \textit{элемент sc-памяти, соответствующий константному sc-узлу}. Таким образом, в результате можно получать любые допустимые комбинации \textit{классов элементов sc-памяти\scnsupergroupsign}.

\begin{SCn}
\scnheader{Метод получения класса элемента sc-памяти, соответствующего некоторому sc-элементу}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{ScType ScMemoryContext::GetElementType(ScAddr const \& addr) const}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{sc-адрес}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{класс элемента sc-памяти\scnsupergroupsign}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{элемент с заданным sc-адресом не существует в sc-памяти}
\end{scnrelfromlist}
\end{SCn}

Чтобы получить \textit{класс} заданного \textit{элемента sc-памяти\scnsupergroupsign} достаточно применить \textbf{\textit{Метод получения класса элемента sc-памяти, соответствующего некоторому sc-элементу}}, задав в качестве аргумента sc-адрес заданного элемента sc-памяти. В последних двух методах не допускается использовать \textit{sc-адреса}, которые не являются \textit{sc-адресами элементов в sc-памяти}.

\subsection{Программный интерфейс информационно-поисковых методов Реализации sc-памяти в ostis-платформе}
\label{sec_soft_platform_information_retrieval_subsystem}

\begin{SCn}
	
\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Метод создания итератора поиска трехэлементных конструкций в sc-памяти}
	\scnitem{Метод создания итератора поиска пятиэлементных конструкций в sc-памяти}
	\scnitem{Метод поиска конструкций в sc-памяти, изоморфных данному графу-образцу}
	\scnitem{Метод создания конструкции в sc-памяти, изоморфной данному графу-образцу}
	\scnitem{Метод создания программного объекта графа-образца}
\end{scnrelfromlist}	
	
\begin{scnrelfromlist}{ключевое понятие}
	\scnitem{информационный поиск}
	\scnitem{изоморфный поиск}
	\scnitem{граф-образец}
\end{scnrelfromlist}	
	
\end{SCn}

В задачах, решаемых в прикладных ostis-системах, реализуемых на базе текущего \textit{Программного варианта реализации ostis-платформы}, необходимо использовать механизмы поиска уже существующих элементов или \textit{конструкций в sc-памяти}. Такие механизмы являются частью \textbf{\textit{Реализации информационно-поисковой подсистемы Реализации sc-памяти в ostis-платформе}}, на базе которой можно реализовывать \textit{информационные-поисковые подсистемы} для \textit{платформенно-зависимых} и \textit{платформенно-независимых ostis-систем}. Несмотря на сложность \textit{информационного поиска}, текущий \textit{Программный вариант реализации ostis-платформы} позволяет эффективно использовать реализуемые методы \textit{информационного поиска} в задачах, решаемых прикладными ostis-системами. Данную подсистему нельзя реализовать независимо от реализации \textit{ostis-платформы}, то есть ее нельзя сделать \textit{платформенно-независимой}, поэтому необходимо разделять \textit{Реализацию информационно-поисковой подсистемы Реализации sc-памяти в ostis-платформе} и \textit{Реализацию информационно-поисковой подсистемы Метасистемы OSTIS}, которая реализуется на \textit{Языке SCP} и независимо от текущего \textit{Программного варианта реализации ostis-платформы} (см. \textit{Главу \ref{chapter_ims_standard}~\nameref{chapter_ims_standard}}). Сам же \textit{scp-интерпретатор} должен использовать информационно-поисковые методы \textit{Реализации sc-памяти в ostis-платформе}, а \textit{Язык SCP} --- предоставлять возможность навигироваться по \textit{базе знаний} любой \textit{ostis-системы} (см. \textit{\ref{sec_ps_scp}~\nameref{sec_ps_scp}}).

\begin{SCn}
\scnstructheader{Библиотека многократно используемых компонентов Программного варианта реализации ostis-платформы}
\begin{scnsubstruct}
	
\scnstructheader{Программный интерфейс информационно-поисковых методов в Реализации sc-памяти в ostis-платформе}
\scnhaselement{Метод создания итератора поиска трехэлементных конструкций в sc-памяти}
\scnhaselement{Метод создания итератора поиска пятиэлементных конструкций в sc-памяти}
\scnhaselement{Метод поиска конструкций в sc-памяти, изоморфных данному графу-образцу}
\scnhaselement{Метод создания конструкции в sc-памяти, изоморфной данному графу-образцу}
\scnhaselement{Метод создания программного объекта графа-образца}	
	
\end{scnsubstruct}
\end{SCn}
	
\begin{SCn}	
\scnheader{Метод создания итератора поиска трехэлементных конструкций в sc-памяти}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{template <typename ParamType1, typename ParamType2, typename ParamType3> std::shared\_ptr<TIterator5<
	ParamType1, ParamType2, ParamType3>> Iterator3(ParamType1 const \& param1, ParamType2 const \& param2, ParamType3 const \& param3)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{параметр Метода создания итератора поиска конструкций в sc-памяти}
	\scnitem{параметр Метода создания итератора поиска конструкций в sc-памяти}
	\scnitem{параметр Метода создания итератора поиска конструкций в sc-памяти}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{итератор поиска трехэлементных конструкций в sc-памяти}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{элемент с заданным sc-адресом не существует в sc-памяти}
\end{scnrelfromlist}
\end{SCn}

\begin{SCn}
\scnheader{Метод создания итератора поиска пятиэлементных конструкций в sc-памяти}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{template <typename ParamType1, typename ParamType2, typename ParamType3, typename ParamType4, typename ParamType5> std::shared\_ptr<TIterator5<ParamType1, ParamType2, ParamType3, ParamType4, ParamType5>> Iterator5(ParamType1 const \& param1, ParamType2 const \& param2, ParamType3 const \& param3, ParamType4 const \& param4, ParamType5 const \& param5)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{параметр Метода создания итератора поиска конструкций в sc-памяти}
	\scnitem{параметр Метода создания итератора поиска конструкций в sc-памяти}
	\scnitem{параметр Метода создания итератора поиска конструкций в sc-памяти}
	\scnitem{параметр Метода создания итератора поиска конструкций в sc-памяти}
	\scnitem{параметр Метода создания итератора поиска конструкций в sc-памяти}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{итератор поиска пятиэлементных конструкций в sc-памяти}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{элемент с заданным sc-адресом не существует в sc-памяти}
\end{scnrelfromlist}
\end{SCn}

По правилам \textit{Синтаксиса SC-кода} \textit{sc-конструкции}, то есть конструкции, состоящие из \textit{sc-элементов}, могут состоять из трех \textit{sc-элементов}, пяти \textit{sc-элементов}, семи sc-элементов и так далее (см. \textit{\ref{sec_sr_scsyntax}~\nameref{sec_sr_scsyntax}}). В \textit{sc-памяти ostis-платформы} эквивалентом \textit{sc-конструкции} является конструкция, состоящая из \textit{элементов sc-памяти} (\textbf{\textit{конструкция в sc-памяти}}). \textbf{\textit{Метод создания итератора поиска трехэлементных конструкций в sc-памяти}} и \textbf{\textit{Метод создания итератора поиска пятиэлементных конструкций в sc-памяти}} позволяют создавать итераторы поиска трех- и пяти- элементных \textit{конструкций в sc-памяти ostis-платформы} соответственно. С помощью параметров данных методов можно создавать итераторы любой необходимой конфигурации для поиска \textit{трех-} и {пяти- элементных sc-конструкций}. Так, например, если необходимо найти все \textit{элементы sc-памяти, соответствующие sc-элементам}, которые принадлежат некоторому \textit{sc-множеству}, для которого соответствует заданный \textit{элемент sc-памяти}, то необходимо при помощи \textit{Метода создания итератора поиска трехэлементных конструкций элементов в sc-памяти} создать итератор поиска, задав в качестве первого аргумента \textit{элемент sc-памяти, соответствующий} заданному \textit{sc-множеству}, а в качестве второго и третьего аргументов --- \textit{класс элементов sc-памяти, соответствующих базовой sc-дуге\scnsupergroupsign} и \textit{класс элементов sc-памяти, соответствующих sc-элементам неуточненного класса\scnsupergroupsign}, соответственно. Для поиска в \textit{sc-памяти} более сложных конструкций, состоящих из семи и более элементов, необходимо комбинировать итераторы поиска трех- и пяти- элементных \textit{конструкций в sc-памяти}, или использовать \textbf{\textit{Метод поиска конструкций в sc-памяти, изоморфных данному графу-образцу}}.

\textit{программный интерфейс} этих \textit{методов} ограничивается особенностями \textit{языка представления методов} \textit{C++}. Например, при помощи этих \textit{методов} нельзя создать \textit{итераторы}, задав в качестве аргументов только \textit{классы элементов sc-памяти\scnsupergroupsign}, по которым необходимо найти все \textit{соответствующие конструкции в sc-памяти}, в которых \textit{классы их элементов sc-памяти\scnsupergroupsign} являются классами, заданными в качестве аргументов для указанных методов, как и впрочем нельзя указать что-то иное в качестве аргументов, кроме \textit{sc-адреса} или \textit{класса элемента sc-памяти\scnsupergroupsign}. Попытка произвести что-то из перечисленного приведет к ошибке \scnqq{склейки} интерфейса одного из указанных \textit{методов}, указанного в заголовочном файле \textit{С++}, с реализацией с заданными параметрами, указанной в исходном файле \textit{С++}, поскольку компилятор \textit{C++} не сможет найти реализацию для указанного \textit{программного интерфейса}. Таким образом, согласно последней проблеме, параметрами \textit{Метода создания итератора поиска трехэлементных конструкций в sc-памяти} и \textit{Метода создания итератора поиска пятиэлементных конструкций в sc-памяти} могут быть \textit{sc-адрес} и/или \textit{класс элемента sc-памяти\scnsupergroupsign}.

Создаваемые при помощи данных \textit{методов} \textit{итераторы} также \textit{имеют программный интерфейс}. Результатами обоих \textit{методов} являются разные \textit{итераторы}, но имеющие общий \textit{программный интерфейс}. Такие \textit{итераторы} позволяют работать с \textit{конструкциями в sc-памяти} в тот же момент, когда они были найдены. При помощи \textit{Метода перехода к следующей \scnqq{подходящей} для заданного итератора конструкции в sc-памяти} \textit{итератор} обновляет свое внутреннее состояние каждый раз, когда была найдена новая \textit{конструкция в sc-памяти}. Под следующей \scnqq{подходящей} для заданного итератора \textit{конструкцией в sc-памяти} подразумевается \textit{конструкция в sc-памяти}, элементы которой удовлетворяют конфигурации созданного \textit{итератора поиска конструкций в sc-памяти} и которая не была найдена раннее. Результатом последнего \textit{метода} является логическое значение \textit{Истина}, если следующая \scnqq{подходящая} для заданного \textit{итератора} конструкция существует в \textit{sc-памяти}. Если \scnqq{подходящих} для этого \textit{итератора} конструкций нет в \textit{sc-памяти}, то результатом \textit{Метода перехода к следующей подходящей для заданного итератора конструкции в sc-памяти} является логическое значение \textit{Ложь}. Чтобы получить \textit{sc-адрес} некоторого из элементов найденной \textit{конструкции в sc-памяти} необходимо использовать \textit{Метода доступа к sc-адресу элемента заданной конструкции в sc-памяти по номеру позиции этого элемента в заданной конструкции sc-памяти}, задав качестве аргумента целочисленное значение в виде номера позиции искомого элемента в этой конструкции. При этом нумерация позиций элементов в \textit{конструкции sc-памяти} в текущей \textit{Реализации sc-памяти в ostis-платформе} происходит начиная с нуля, а не с единицы, а порядок нумерации задается тем, какой порядок аргументов для создания \textit{итератора} был использован. При попытке указать для данного метода номер позиции, по которому не существует позиции в данной конструкции, результатом этого метода будет \textit{исключительная ситуация} о недопустимой позиции элемента в заданной \textit{конструкции sc-памяти}. Таким образом, диапазон номеров позиции для \textit{трехэлементных конструкций} ограничен от нуля до двух, а для пятиэлементных --- от нуля до четырех.

\begin{SCn}
\scnstructheader{Библиотека многократно используемых компонентов Программного варианта реализации ostis-платформы}
\begin{scnsubstruct}
	
\scnstructheader{Программный интерфейс информационно-поисковых методов в Реализации sc-памяти в ostis-платформе}
\begin{scnsubstruct}
\scnsuperset{Расширение Программного интерфейса информационно-поисковых методов в Реализации sc-памяти в ostis-платформе}
	
\scnheader{итератор поиска трех- и пяти- элементных конструкций в sc-памяти}
\scnsubset{программный объект}
\scnidtf{ScIterator}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
	
\scnstructheader{Программный интерфейс итератора поиска трех- и пяти- элементных конструкций в sc-памяти}
\begin{scnsubstruct}

\scnrelto{программный интерфейс}{итератор поиска трех- и пяти- элементных конструкций в sc-памяти}
	
\scnheader{Метод перехода к следующей \scnqq{подходящей} для заданного итератора конструкции в sc-памяти}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{bool Next() const}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{логическое значение}
\end{scnrelfromlist}

\scnheader{Метод доступа к sc-адресу элемента заданной конструкции в sc-памяти по номеру позиции этого элемента в заданной конструкции}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{ScAddr Get(size\_t idx) const}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{32-битовое целое число}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{sc-адрес элемента sc-памяти}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{недопустимая позиция элемента в заданной конструкции sc-памяти}
\end{scnrelfromlist}
	
\end{scnsubstruct}
	
\end{scnsubstruct}

\end{scnsubstruct}
\end{SCn}

Для \textit{Метода создания итератора поиска трехэлементных конструкций в sc-памяти}, как и для \textit{Метода создания итератора поиска пятиэлементных конструкций в sc-памяти} можно использовать различные комбинации параметров, кроме комбинаций, где все параметры являются классами \textit{элементов sc-памяти}. Для простоты и компактности используемых терминов на уровне реализации методов создания итераторов поиска конструкций в sc-памяти вводятся дополнительные обозначения: символом \scnqq{f} (от английского слова fixed) обозначается факт, что параметром заданного метода создания итератора поиска \textit{конструкций в sc-памяти} указан \textit{sc-адрес} некоторого \textit{элемента sc-памяти}, а символом \scnqq{a} (от английского слова assign) --- \textit{класс элемента sc-памяти}\scnsupergroupsign. Для \textit{Метода создания итератора поиска трехэлементных конструкций в sc-памяти} правильным обозначением искомых конструкций будет комбинация символов \scnqq{f} и \scnqq{a} длиной в три символа, а для \textit{Метода создания итератора поиска пятиэлементных конструкций в sc-памяти} --- комбинация символов \scnqq{f} и \scnqq{a} длиной в пять символов. В \textit{Языке SCP} для указания признака заданности значения у переменной используются соответствующие ролевые отношения: для переменных класса \scnqq{f} ---  \textit{scp-операнд с заданным значением\scnrolesign}, для переменных класса \scnqq{a} --- \textit{scp-операнд со свободным значением\scnrolesign} (см. \textit{\ref{sec_ps_scp}~\nameref{sec_ps_scp}}).

\begin{SCn}
\scnstructheader{Библиотека многократно используемых компонентов Программного варианта реализации ostis-платформы}
\begin{scnsubstruct}

\scnstructheader{Программный интерфейс информационно-поисковых методов в Реализации sc-памяти в ostis-платформе}
\begin{scnsubstruct}
			
\scnheader{Метод создания итератора поиска трехэлементных конструкций в sc-памяти}
\scnsuperset{Метод создания итератора поиска fff-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{sc-адрес элемента sc-памяти}
	\end{scnrelfromvector}
\end{scnindent}
%\scnsuperset{Метод создания итератора поиска ffa-конструкций в sc-памяти}
\scnsuperset{Метод создания итератора поиска faa-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
	\end{scnrelfromvector}
\end{scnindent}
%\scnsuperset{Метод создания итератора поиска aff-конструкций в sc-памяти}
\scnsuperset{Метод создания итератора поиска aaf-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
	\end{scnrelfromvector}
\end{scnindent}
\scnsuperset{Метод создания итератора поиска faf-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
	\end{scnrelfromvector}
\end{scnindent}
\scnsuperset{Метод создания итератора поиска afa-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
	\end{scnrelfromvector}
\end{scnindent}

\end{scnsubstruct}

\end{scnsubstruct}
\end{SCn}

Данные варианты реализации \textit{Метода создания итератора поиска трехэлементных конструкций в sc-памяти} являются достаточными для решения любых поисково-навигационных задач. Возможны варианты реализации \textbf{\textit{Метода создания итератора поиска ffa-конструкций в sc-памяти}} и \textbf{\textit{Метода создания итератора поиска aff-конструкций в sc-памяти}}, но на практике нет необходимости искать третий элемент sc-памяти по известным элементу, соответствующему sc-коннектору, и элементу, соответствующему sc-элементу, из которого данный sc-коннектор выходит или в который данный sc-коннектор входит. Такую задачу можно решить, используя \textbf{\textit{Метод создания итератора поиска afa-конструкций в sc-памяти}}. Впрочем, реализация \textit{Метода создания итератора поиска пятиэлементных конструкций в sc-памяти} вовсе не обязательна, поскольку все задачи, решаемые при помощи данного метода, можно также решить при помощи \textit{Метода создания итератора поиска трехэлементных конструкций в sc-памяти}, однако реализация \textit{Метода создания итератора поиска пятиэлементных конструкций в sc-памяти} позволяет сделать текст создаваемого метода более компактным по сравнению с методом, в котором бы использовался \textit{Метод создания итератора поиска трехэлементных конструкций в sc-памяти}. 

В качестве всех трех аргументов для \textit{Метода создания итератора поиска трехэлементных конструкций в sc-памяти} могут быть указаны:

\begin{textitemize}
	\item \textit{sc-адреса элементов sc-памяти} (например, задача проверки инцидентности всех трех заданных элементов sc-памяти),
	\item \textit{sc-адрес элемента sc-памяти}, \textit{класс элементов sc-памяти, соответствующих sc-коннекторам\scnsupergroupsign}, которые выходят из заданного в качестве первого аргумента \textit{элемента sc-памяти}, и \textit{sc-адрес элемента sc-памяти}, соответствующего некоторому \textit{sc-элементу}, в который искомые \textit{sc-коннекторы} входят (например, задача поиска всех \textit{элементов sc-памяти, соответствующих sc-коннекторам между sc-элементами}, для которых соответствуют заданные \textit{элементы sc-памяти}),
	\item \textit{sc-адрес элемента sc-памяти}, \textit{класс элементов sc-памяти, соответствующих sc-коннекторам\scnsupergroupsign}, которые выходят из заданного в качестве первого аргумента \textit{элемента sc-памяти}, и \textit{класс элементов sc-памяти, соответствующих некоторым sc-элементам\scnsupergroupsign}, в которые искомые \textit{sc-коннекторы} входят (например, задача поиска всех \textit{элементов sc-памяти}, \textit{соответствующих sc-коннекторам}, выходящим из \textit{sc-элемента}, для которого соответствует заданный в качестве первого аргумента \textit{элемент sc-памяти}),
	\item \textit{класс sc-элементов sc-памяти\scnsupergroupsign}, \textit{класс элементов sc-памяти, соответствующих sc-коннекторам\scnsupergroupsign}, которые выходят из заданных в качестве первого аргумента \textit{элементов sc-памяти}, и \textit{sc-адрес элемента sc-памяти, соответствующего некоторому sc-элементу}, в который искомые \textit{sc-коннекторы} входят (например, задача поиска всех \textit{элементов sc-памяти, соответствующих sc-коннекторам}, входящим в \textit{sc-элемент}, для которого соответствует заданный в качестве третьего аргумента \textit{элемент sc-памяти}),
	\item \textit{класс элементов sc-памяти\scnsupergroupsign}, \textit{sc-адрес элемента sc-памяти, соответствующий sc-коннектору}, который выходит из заданного в качестве первого аргумента \textit{элемента sc-памяти}, и \textit{класс элементов sc-памяти, соответствующих некоторому sc-элементу\scnsupergroupsign}, в который искомый \textit{sc-коннектор} входит (например, задача поиска \textit{элементов sc-памяти, соответствующих sc-элементам}, один из которых является \textit{sc-элементом}, из которого выходит \textit{sc-коннектор}, для которого соответствует заданный \textit{элемент sc-памяти}, а второй из которых является \textit{sc-элементом}, в который входит этот \textit{sc-коннектор}, для которого соответствует заданный \textit{элемент sc-памяти})
	\item и так далее.
\end{textitemize}
			
\begin{SCn}
\scnstructheader{Библиотека многократно используемых компонентов Программного варианта реализации ostis-платформы}
\begin{scnsubstruct}

\scnstructheader{Программный интерфейс информационно-поисковых методов в Реализации sc-памяти в ostis-платформе}
\begin{scnsubstruct}
	
\scnheader{Метод создания итератора поиска пятиэлементных конструкций элементов в sc-памяти}
\scnsuperset{Метод создания итератора поиска fffff-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{sc-адрес элемента sc-памяти}
	\end{scnrelfromvector}
\end{scnindent}
%\scnsuperset{Метод создания итератора поиска ffffa-конструкций в sc-памяти}
%\scnsuperset{Метод создания итератора поиска fffaa-конструкций в sc-памяти}
%\scnsuperset{Метод создания итератора поиска ffaaa-конструкций в sc-памяти}
\scnsuperset{Метод создания итератора поиска faaaa-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
	\end{scnrelfromvector}
\end{scnindent}
%\scnsuperset{Метод создания итератора поиска affff-конструкций в sc-памяти}
%\scnsuperset{Метод создания итератора поиска aafff-конструкций в sc-памяти}
%\scnsuperset{Метод создания итератора поиска aaaff-конструкций в sc-памяти}
\scnsuperset{Метод создания итератора поиска aaaaf-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
	\end{scnrelfromvector}
\end{scnindent}
%\scnsuperset{Метод создания итератора поиска fffaf-конструкций в sc-памяти}
%\scnsuperset{Метод создания итератора поиска ffaaf-конструкций в sc-памяти}	
%\scnsuperset{Метод создания итератора поиска fafff-конструкций в sc-памяти}
%\scnsuperset{Метод создания итератора поиска faaff-конструкций в sc-памяти}			
\scnsuperset{Метод создания итератора поиска faaaf-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
	\end{scnrelfromvector}
\end{scnindent}
\scnsuperset{Метод создания итератора поиска fafaf-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
	\end{scnrelfromvector}
\end{scnindent}
%\scnsuperset{Метод создания итератора поиска ffaff-конструкций в sc-памяти}
%\scnsuperset{Метод создания итератора поиска afffa-конструкций в sc-памяти}
%\scnsuperset{Метод создания итератора поиска affaa-конструкций в sc-памяти}
\scnsuperset{Метод создания итератора поиска afaaa-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
	\end{scnrelfromvector}
\end{scnindent}
%\scnsuperset{Метод создания итератора поиска aaffa-конструкций в sc-памяти}
\scnsuperset{Метод создания итератора поиска aaafa-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
	\end{scnrelfromvector}
\end{scnindent}
\scnsuperset{Метод создания итератора поиска aafaa-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
	\end{scnrelfromvector}
\end{scnindent}
\scnsuperset{Метод создания итератора поиска afaaf-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
	\end{scnrelfromvector}
\end{scnindent}
%\scnsuperset{Метод создания итератора поиска affaf-конструкций в sc-памяти}
\scnsuperset{Метод создания итератора поиска faafa-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
	\end{scnrelfromvector}
\end{scnindent}
%\scnsuperset{Метод создания итератора поиска faffa-конструкций в sc-памяти}
\scnsuperset{Метод создания итератора поиска afafa-конструкций в sc-памяти}
\begin{scnindent}
	\scniselement{метод}
	\begin{scnrelfromvector}{классы входных аргументов метода}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
		\scnitem{sc-адрес элемента sc-памяти}
		\scnitem{класс элемента sc-памяти\scnsupergroupsign}
	\end{scnrelfromvector}
\end{scnindent}

\end{scnsubstruct}

\end{scnsubstruct}
\end{SCn}

В качестве всех пяти аргументов для \textbf{\textit{Метода создания итератора поиска пятиэлементных конструкций в sc-памяти}} могут быть указаны и другие комбинации, не указанные в представленной классификации. Однако в этом нет необходимости, поскольку все задачи, решаемые с помощью таких \textit{итераторов}, можно решить уже существующими \myuline{\textit{итераторами поиска пятиэлементных конструкций в sc-памяти}}.

\subsection{Расширение Программного интерфейса информационно-поисковых методов в Реализации sc-памяти в ostis-платформе. Реализация изоморфного поиска конструкций в sc-памяти по заданному графу-образцу}
\label{sec_soft_platform_information_retrieval_subsystem_extension}

\begin{SCn}
	
\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Метод поиска конструкций в sc-памяти, изоморфных данному графу-образцу}
	\scnitem{Метод создания конструкции в sc-памяти, изоморфной данному графу-образцу}
	\scnitem{Метод создания программного объекта графа-образца}
	\scnitem{Программный интерфейс программного объекта графа-образца}
	\scnitem{Программный интерфейс программного объекта конструкции в sc-памяти, изоморфной заданному графу-образцу}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевое понятие}
	\scnitem{программный объект графа-образца}
	\scnitem{программный объект трехэлементной конструкции заданного графа-образца}
	\scnitem{программный объект конструкции в sc-памяти, изоморфной заданному графу-образцу}
\end{scnrelfromlist}	
	
\end{SCn}

\textit{Метод создания итератора поиска трехэлементных конструкций в sc-памяти} и \textit{Метод создания итератора поиска пятиэлементных конструкций в sc-памяти}, а также \textit{программный интерфейс итератора поиска трех- и пяти- элементных конструкций в sc-памяти} являются достаточно мощными средствами для решения любых задач \myuline{\textit{информационного поиска}} в прикладных \textit{ostis-системах}. Однако есть \textit{модели решения задач}, в которых необходимо использовать другие методы поиска. Так, например, в задачах \myuline{\textit{логического вывода}} считается удобным решать \textit{задачи}, когда \textit{поиск конструкций} любой необходимой конфигурации \textit{в sc-памяти} сводится к \textbf{\textit{изоморфному поиску}} этих конструкций по заданному \textbf{\textit{графу-образцу}}. Такими \textit{графами-образцами} могут выступать любые \textit{атомарные логические формулы}, входящие в состав в любой другой \textit{неатомарной формулы} (см. \textit{Главу \ref{chapter_logic}~\nameref{chapter_logic}}).

\textit{изоморфный поиск} является одним из способов решения \textit{задачи} поиска подграфа в \textit{графе} (см. \scncite{Fort1996}). Эта задача заключается в том, чтобы найти все вхождения заданного \textit{графа-образца} в исходном графе. Процесс \textit{изоморфного поиска} может быть реализован с использованием различных алгоритмов. Один из них --- \textit{Алгоритм Ульмана}, который основан на использовании матрицы смежности, чтобы определить соответствие между вершинами графов. Другой алгоритм --- \textit{Алгоритм VF2}, который использует функцию сравнения для проверки соответствия соответствующих узлов и ребер в двух графах (см. \scncite{Foggia2001}). В современной информатике также известны алгоритмы, позволяющие решать \textit{задачу} \textit{изоморфного поиска} за субэкспоненциальное время (см. \scncite{McKay2007}).

Основополагающим принципом разрабатываемой \textit{Технологии OSTIS} является принцип заимствования наилучших существующих технологий для разработки \textit{ostis-систем}. Однако в силу разных обстоятельств, например, связанных с особенностями \textit{Реализации sc-памяти в ostis-платформе}, а также требований, предъявляемых к sc-агентам, занимающихся логическим выводом, необходимо разрабатывать и апробировать новые решения. В рамках текущей \textit{Реализации sc-памяти в ostis-платформе} разработан принципиально другой алгоритм \textit{изоморфного поиска}, позволяющего за оптимальное время находить графы, изоморфные данному \textit{графу-образцу}.

В общем случае \myuline{нет} необходимости реализовывать \textit{изоморфный поиск} в универсальном виде. Это объясняется тем, что:
\begin{textitemize}
	\item \textit{изоморфный поиск} является NP-полной задачей, что означает, что затраты на ее решение растут экспоненциально с размером входных данных, и пока не существует эффективного алгоритма для решения задачи \textit{изоморфного поиска};
	\item в результате определения изоморфизма двух заданных графов может быть обнаружено несколько узлов, которые соответствуют друг другу, но на самом деле не являются изоморфными;
	\item из-за экспоненциального роста количества возможных вариантов изоморфизма при увеличении размера графа, даже небольшие погрешности при расчете изоморфизма могут привести к сильному искажению результатов;
	\item для больших графов временные затраты на перебор всех возможных вариантов изоморфизма могут быть очень высокими. Это может снижать эффективность поиска и ограничивать возможности применения \textit{изоморфного поиска} в реальных задачах (см. \scncite{Cordella2004});
	\item сложность поиска увеличивается с увеличением количества циклов в исходном \textit{графе}, поскольку приводит к большему числу переборов;
	\item существующие алгоритмы либо медленны, либо нерационально используют память, что приводит \textit{изоморфный поиск} к медленной работе.
\end{textitemize}

Некоторые алгоритмы изоморфного поиска вовсе имеют сложность \textit{O(n!)} и не могут быть использованы для графов большого размера (см. \scncite{Fort1996}). Несмотря на все проблемы, связанные с \textit{изоморфным поиском}, для удобства решения логических задач в текущем \textit{Программном варианте реализации ostis-платформы} реализован \scnqq{наиболее подходящий} алгоритм \textit{изоморфного поиска}. Текущий вариант \textit{изоморфного поиска} реализован в \textit{Методе поиска конструкций в sc-памяти, изоморфных данному графу-образцу}. Данный метод позволяет находить \textit{конструкции в sc-памяти}, изоморфные не просто некоторому \textit{графу-образцу}, который представлен в \textit{sc-памяти}, а \textit{программному объекту} этого \textit{графа-образца}, то есть \textit{графу-образцу}, который представлен в удобном и быстром для обработки программном формате.

\begin{SCn}
\scnheader{Метод поиска конструкций в sc-памяти, изоморфных данному графу-образцу}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{ScTemplate::Result HelperSearchTemplate(ScTemplate const \& templ, ScTemplateSearchResult \& result)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{программный объект графа-образца}
	\scnitem{кортеж программных объектов конструкций в sc-памяти, изоморфных заданному графу-образцу}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{код ошибки результата поиска конструкций в sc-памяти, изоморфной заданному графу-образцу}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{синтаксически некорректный программный объект графа-образца}
	\scnitem{семантически некорректный программный объект графа-образца}
\end{scnrelfromlist}
\end{SCn}

\begin{SCn}
\scnheader{Метод создания конструкции в sc-памяти, изоморфной данному графу-образцу}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{ScTemplate::Result HelperGenTemplate(ScTemplate const \& templ, ScTemplateGenResult \& result)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{программный объект графа-образца}
	\scnitem{программный объект конструкции sc-памяти, изоморфной заданной графу-образцу}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{код ошибки результата создания конструкции, изоморфной заданному графу-образцу}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{синтаксически некорректный программный объект графа-образца}
	\scnitem{семантически некорректный программный объект графа-образца}
\end{scnrelfromlist}
\end{SCn}

\begin{SCn}
\scnheader{Метод создания программного объекта графа-образца}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{ScTemplate::Result HelperBuildTemplate(ScTemplate \& templ, ScAddr const \& templAddr)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{программный объект графа-образца}
	\scnitem{sc-адрес элемента sc-памяти}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{код ошибки результата создания программного объекта по заданному элементу, соответствующему графу-образцу}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{синтаксически некорректный программный объект графа-образца}
	\scnitem{семантически некорректный программный объект графа-образца}
\end{scnrelfromlist}
\end{SCn}

\textbf{\textit{программный объект граф-образца}} можно сформировать при помощи \textit{Метода создания программного объекта графа-образца}, для этого необходимо в качестве аргументов задать \textit{программный объект графа-образца} как выходный параметр и \textit{sc-адрес элемента sc-памяти, соответствующего sc-структуре} \textit{атомарной логической формулы} (sc-шаблону).
Как и \textit{итератор поиска трех- и пяти- элементных конструкций в sc-памяти}, \textit{программный объект графа-образца} имеет специализированный \textit{программный интерфейс}. Изначально \textit{программный объект графа-образца} задается пустым. При помощи \textbf{\textit{Метода добавления трехэлементной конструкции для заданного графа-образца}} и \textbf{\textit{Метода добавления пятиэлементной конструкции для заданного графа-образца}} можно расширять заданный \textit{программный объект графа-образца}. Расширение \textit{программного объекта графа-образца} происходит с добавлением трехэлементных конструкций в \textbf{\textit{кортеж программных объектов трехэлементных конструкций в заданном графе-образце}}, при этом порядок программный объектов конструкций в этом множестве задается последовательностью выполнения \textit{Метода добавления трехэлементной конструкции для заданного графа-образца} и \textit{Метода добавления пятиэлементной конструкции для заданного графа-образца}.

\begin{SCn}
\scnstructheader{Библиотека многократно используемых компонентов Программного варианта реализации ostis-платформы}
\begin{scnsubstruct}

\scnstructheader{Программный интерфейс информационно-поисковых методов в Реализации sc-памяти в ostis-платформе}
\begin{scnsubstruct}
	
\scnheader{программный объект графа-образца}
\scnidtf{ScTemplate}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\scnidtf{программный объект атомарной логической формулы}
\scnidtf{программный объект sc-шаблона}
\scnsubset{программный объект}
\begin{scnrelfromset}{понятие, специфицирующее заданную сущность}
	\scnitem{кортеж программных объектов трехэлементных конструкций в заданном графе-образце}
	\begin{scnindent}
		\scnidtf{std::vector<ScTemplateTriple *> m\_templateTriples}
	\end{scnindent}
	\scnitem{локальный идентификатор элемента sc-памяти и номера позиций этого элемента в заданном графе-образце*}
	\begin{scnindent}
		\scnidtf{std::unordered\_multimap<std::string, size\_t> m\_templateItemsNamesToReplacementItemsPositions}
	\end{scnindent}
	\scnitem{упорядоченное по степени приоритета поиска множество множеств номеров программных объектов трехэлементных конструкций в заданном графе-образце}
	\begin{scnindent}
		\scnidtf{std::vector<std::unordered\_set<size\_t>> m\_priorityOrderedTemplateTriples}
	\end{scnindent}
	\scnitem{локальный идентификатор элемента sc-памяти и sc-адрес этого элемента в заданном графе-образце*}
	\begin{scnindent}
		\scnidtf{std::map<std::string, ScAddr> m\_templateItemsNamesToReplacementItemsAddrs}
	\end{scnindent}
	\scnitem{локальный идентификатор элемента sc-памяти и класс этого элемента в заданном графе-образце*}
	\begin{scnindent}
		\scnidtf{std::map<std::string, ScType> m\_templateItemsNamesToTypes}
	\end{scnindent}
\end{scnrelfromset}
	
\scnheader{программный объект трехэлементной конструкции заданного графа-образца}
\scnidtf{ScTemplateTriple}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\scnsubset{программный объект}
\begin{scnrelfromset}{понятие, специфицирующее заданную сущность}
	\scnitem{номер программного объекта трехэлементной конструкции в заданном графе-образце}
	\begin{scnindent}
		\scnidtf{size\_t m\_index}
	\end{scnindent}
	\scnitem{кортеж трех элементов программного объекта трехэлементной конструкции}
	\begin{scnindent}
		\scnidtf{std::array<ScTemplateItem, 3> m\_values}
	\end{scnindent}
\end{scnrelfromset}

\scnheader{элемент программного объекта трехэлементной конструкции}
\scnidtf{ScTemplateItem}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\scnsubset{программный объект}
\begin{scnrelfromset}{понятие, специфицирующее заданную сущность}
	\scnitem{sc-адрес элемента программного объекта трехэлементной конструкции}
	\scnsubset{sc-адрес элемента sc-памяти}
	\begin{scnindent}
		\scnidtf{ScAddr m\_addrValue}
	\end{scnindent}
	\scnitem{класс элемента программного объекта трехэлементной конструкции}
	\scnsubset{класс элемента sc-памяти\scnsupergroupsign}
	\begin{scnindent}
		\scnidtf{ScType m\_typeValue}
	\end{scnindent}
	\scnitem{локальный идентификатор программного объекта трехэлементной конструкции}
	\begin{scnindent}
		\scnidtf{std::string m\_name}
	\end{scnindent}
\end{scnrelfromset}
	
\scnstructheader{Программный интерфейс программного объекта графа-образца}
\begin{scnsubstruct}
				
\scnrelto{программный интерфейс}{программный объект графа-образца}

\scnheader{Метод добавления трехэлементной конструкции для заданного графа-образца}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{ScTemplate \& Triple(ScTemplateItemValue const \& param1, ScTemplateItemValue const \& param2, ScTemplateItemValue const \& param3)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{параметр Метода добавления конструкции для заданного графа-образца}
	\scnitem{параметр Метода добавления конструкции для заданного графа-образца}
	\scnitem{параметр Метода добавления конструкции для заданного графа-образца}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{программный объект графа-образца}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{некорректный параметр Метода добавления конструкции для заданного графа-образца}
	\begin{scnindent}
		\scnsuperset{локальный идентификатор не привязан раннее к sc-адресу элемента программного объекта трехэлементной конструкции в заданном программном объекте графа-образца}
		\scnsuperset{локальный идентификатор уже использован ранее для другого sc-адреса элемента программного объекта трехэлементной конструкции в заданном программном объекте графа-образца}
		\scnsuperset{один и тот же локальный идентификатор одновременно указан для второго и первого (третьего) элементов заданного программного объекта трехэлементной конструкции}
		\scnsuperset{класс элемента создаваемого программного объекта трехэлементной конструкции в заданном программном объекте графа-образца является классом элементов в sc-памяти, соответствующих sc-константам}
		\scnsuperset{элемент с sc-адресом элемента создаваемого программного объекта трехэлементной конструкции в заданном программном объекте графа-образца не существует в sc-памяти}
	\end{scnindent}
\end{scnrelfromlist}

\scnheader{Метод добавления пятиэлементной конструкции для заданного графа-образца}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{ScTemplate \& Fiver(ScTemplateItemValue const \& param1, ScTemplateItemValue const \& param2, ScTemplateItemValue const \& param3, ScTemplateItemValue const \& param4, ScTemplateItemValue const \& param5)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\scntext{устаревший заголовок метода на языке представления методов}{ScTemplate \& TripleWithRelation(ScTemplateItemValue const \& param1, ScTemplateItemValue const \& param2, ScTemplateItemValue const \& param3, ScTemplateItemValue const \& param4, ScTemplateItemValue const \& param5)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{параметр Метода добавления конструкции для заданного графа-образца}
	\scnitem{параметр Метода добавления конструкции для заданного графа-образца}
	\scnitem{параметр Метода добавления конструкции для заданного графа-образца}
	\scnitem{параметр Метода добавления конструкции для заданного графа-образца}
	\scnitem{параметр Метода добавления конструкции для заданного графа-образца}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{программный объект графа-образца}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{некорректный параметр Метода добавления конструкции для заданного графа-образца}
	\begin{scnindent}
		\scnsuperset{локальный идентификатор не привязан раннее к sc-адресу элементу программного объекта трехэлементной конструкции в заданном программном объекте графа-образца}
		\scnsuperset{локальный идентификатор уже использован ранее для другого sc-адреса элемента программного объекта трехэлементной конструкции в заданном программном объекте графа-образца}
		\scnsuperset{один и тот же локальный идентификатор одновременно указан для второго и первого (третьего) элементов заданного программного объекта трехэлементной конструкции в заданном программном объекте графа-образца}
		\scnsuperset{класс элемента создаваемого программного объекта трехэлементной конструкции является классом элементов в sc-памяти, соответствующих sc-константам}
		\scnsuperset{элемент с sc-адресом элемента создаваемого программного объекта трехэлементной конструкции в заданном программном объекте графа-образца не существует в sc-памяти}
	\end{scnindent}
\end{scnrelfromlist}
				
\end{scnsubstruct}

\end{scnsubstruct}

\end{scnsubstruct}
\end{SCn}

Чтобы сформировать необходимый \textit{программный объект графа-образца} следует выполнить следующие действия:
\begin{textitemize}
	\item Если \textit{программный объект графа-образца} не создавался раннее, то необходимо создать его.
	\item Для созданного \textit{программного объекта графа-образца} применить несколько раз \textit{Метод добавления трехэлементной конструкции для заданного графа-образца} (\textit{Метод добавления пятиэлементной конструкции для заданного графа-образца}), задав в качестве трех (пяти) входных параметров \textbf{\textit{параметры Метода добавления конструкции для заданного графа-образца}} в зависимости от нужной конфигурации добавляемого \textit{программного объекта трехэлементной (пятиэлементной) конструкции}.
\end{textitemize}

При этом \textit{параметр Метода добавления конструкции для заданного графа-образца} существенно \myuline{отличается} от \textit{параметра Метода создания итератора поиска конструкций в sc-памяти}. Кроме sc-адресов и классов элементов sc-памяти, могут быть указаны локальные идентификаторы этих адресов или классов в созданном графе-образце. Это существенно упрощает процесс формирования \textit{программного объекта графа-образца}, когда необходимо в добавляемой конструкции указать \textit{sc-адрес} или \textit{класс элемента sc-памяти\scnsupergroupsign}, который был уже указан раннее в другой конструкции в заданном \textit{графе-образце}. Таким образом можно сослаться с помощью такого локального идентификатора на параметр уже ранее добавленной конструкции в заданный граф-образец. Кроме того такой способ позволяет получать по таким локальным идентификаторам элементы из найденных по заданному \textit{графу-образцу} конструкций в sc-памяти.

Вне зависимости от того, какие методы были применены для созданного \textit{программного объекта графа-образца} в самой структуре \textit{программного объекта графа образца} для удобства представления и обработки данных создаются \myuline{только} \textbf{\textit{программные объекты трехэлементных конструкций}}. Каждый элемент в \textit{программном объекте трехэлементной конструкции} кроме sc-адреса, класса и локального идентификатора, имеет свой в рамках этой конструкции номер позиции, заданный в диапазоне от нуля до двух, а также номер позиции в рамках всего графа-образца, вычисляемый как сумма произведения номера \textit{трехэлементной конструкции в заданном графе-образце} и \textit{Числа три} и \textit{номера позиции этого элемента в рамках графа-образца}. Добавление \textit{программного объекта трехэлементной конструкции в заданном программном объекте графа-образца} в \textit{программный объект графа-образца} происходит следующим образом:
\begin{textitemize}
	\item \myuline{Если} указанный в качестве второго параметра аргумент имеет локальный идентификатор в заданном графе-образце и этот локальный идентификатор так же указан для первого или второго аргумента, то завершить работу \textit{Метода добавления трехэлементной конструкции для заданного графа-образца} с исключительной ситуацией о том, что \textit{один и тот же локальный идентификатор одновременно указан для второго и первого (третьего) элементов заданного программного объекта трехэлементной конструкции в заданном программном объекте графа-образца}.
	\item \myuline{Если} какой-то из параметров задан в качестве класса элемента sc-памяти, соответствующего sc-константе, то завершить работу \textit{Метода добавления трехэлементной конструкции для заданного графа-образца} с исключительной ситуацией о том, что \textit{класс элемента создаваемого программного объекта трехэлементной конструкции в заданном программном объекте графа-образца является классом элементов в sc-памяти, соответствующих sc-константам}.
	\item \myuline{Если} какой-то из параметров задан в качестве sc-адреса несуществующего элемента в sc-памяти, то завершить работу \textit{Метода добавления трехэлементной конструкции для заданного графа-образца} с исключительной ситуацией о том, что \textit{элемент с sc-адресом элемента создаваемого программного объекта трехэлементной конструкции в заданном программном объекте графа-образца не существует в sc-памяти}.
	\item Для всех параметров, для которых заданы локальные идентификаторы в заданном графе-образце, а также заданы sc-адреса элементов в sc-памяти, добавить все пары с этими локальными идентификаторами и соответствующими sc-адресами элементов в sc-памяти в отношение \textit{локальный идентификатор элемента sc-памяти и sc-адрес этого элемента в заданном графе-образце*}, иначе если известны sc-адреса элементов в sc-памяти для этих локальных идентификаторов в отношении \textit{локальный идентификатор элемента sc-памяти и sc-адрес этого элемента в заданном графе-образце*}, указать для заданных параметров известные sc-адреса элементов в sc-памяти.
	\item Для всех параметров, для которых заданы локальные идентификаторы в заданном графе-образце, а также заданы классы элементов в sc-памяти, добавить все пары с этими локальными идентификаторами и соответствующими классами элементов в sc-памяти в отношение \textit{локальный идентификатор элемента sc-памяти и класс этого элемента в заданном графе-образце*}.
	\item Для всех параметров, для которых заданы только локальные идентификаторы в заданном графе-образце, а также в отношении \textit{локальный идентификатор элемента sc-памяти и номера позиций этого элемента в заданном графе-образце*} по этим локальным идентификаторам неизвестны все номера позиций соответствующих элементов в заданном \textit{графе-образце}, то добавить в это отношение все пары с локальными идентификаторами и номерами позиций соответствующих элементов в заданном графе-образце.
	\item Для полученного \textit{программного объекта трехэлементной конструкции в заданном программном объекте графа-образца} вычислить номер приоритета, необходимый при выполнении \textit{Метода поиска конструкций в sc-памяти, изоморфных данному графу-образцу}:
	\begin{textitemize}
		\item \myuline{Если} в \textit{программном объекте трехэлементной конструкции} для всех элементов указаны \textit{sc-адреса элементов sc-памяти}, то номер приоритета заданной конструкции считается равным нулю (то есть считается самой приоритетной).
		\item \myuline{Если} в \textit{программном объекте трехэлементной конструкции} для второго элемента указан \textit{sc-адрес элемента sc-памяти, соответствующего sc-коннектору}, то номер приоритета заданной конструкции считается равным единице (то есть считается второй по приоритету).
		\item \myuline{Если} в \textit{программном объекте трехэлементной конструкции} для первого и третьего элементов указаны \textit{sc-адреса элемента sc-памяти}, то номер приоритета заданной конструкции считается равным двойке (то есть считается третьей по приоритету).
		\item \myuline{Если} в \textit{программном объекте трехэлементной конструкции} только для третьего элемента указан \textit{sc-адрес элемента sc-памяти}, то номер приоритета заданной конструкции считается равным тройке.
		\item \myuline{Если} в \textit{программном объекте трехэлементной конструкции} для первого элемента указан \textit{sc-адрес элемента sc-памяти}, а для третьего элемента --- \textit{класс элемента sc-памяти, соответствующего sc-узлу\scnsupergroupsign}, то номер приоритета заданной конструкции считается равным четверке.
		\item \myuline{Если} в \textit{программном объекте трехэлементной конструкции} для первого элемента указан \textit{sc-адрес элемента sc-памяти}, а для третьего элемента --- \textit{класс элемента sc-памяти, соответствующего sc-коннектору\scnsupergroupsign}, то номер приоритета заданной конструкции считается равным пятерке.
		\item \myuline{Если} в \textit{программном объекте трехэлементной конструкции} нет элементов, для которых заданы \textit{sc-адреса элементов sc-памяти}, то номер приоритета заданной конструкции считается равным шестерке (то есть считается самой неприоритетной).
	\end{textitemize}
	После определения номера приоритета заданного \textit{программного объекта трехэлементной конструкции в заданном программном объекте графа-образца} добавить данный объект во множество с позицией, равной вычисленному номеру приоритета, \textit{упорядоченного по степени приоритета поиска множества множеств номеров программных объектов трехэлементных конструкций в заданном графе-образце}.
	\item Полученный \textit{программный объект трехэлементной конструкции заданного графа-образца} добавить в \textit{кортеж программных объектов трехэлементных конструкций в заданном графе-образце}.
\end{textitemize}

Добавление \textit{программного объекта пятиэлементной конструкции} в \textit{программный объект графа-образца} сводится к добавлению двух \textit{программных объектов трехэлементной конструкции} в этот \textit{программный объект графа-образца}, при этом во втором добавляемом \textit{программном объекте трехэлементной конструкции} для третьего элемента указывается только локальный идентификатор второго элемента первого добавляемого \textit{программного объекта трехэлементной конструкции в заданном программном объекте графа-образца} для заданного \textit{программного объекта графа-образца}.

Чтобы найти все \textit{конструкции в sc-памяти}, изоморфные заданному \textit{программному объекту графа-образца} следует выполнить следующие действия:
\begin{textitemize}
	\item Для сформированного \textit{программного объекта графа-образца} применить \textit{Метод поиска конструкций в sc-памяти, изоморфных данному графу-образцу}.
	\item Результатом этого метода будет \textit{кортеж программных объектов всех конструкций в sc-памяти, изоморфных заданному графу-образцу}, который, как и итератор поиска трех- и пяти- элементных конструкций в sc-памяти, имеет свой \textit{программный интерфейс}.
\end{textitemize}

\begin{SCn}
\scnstructheader{Библиотека многократно используемых компонентов Программного варианта реализации ostis-платформы}
\begin{scnsubstruct}

\scnstructheader{Программный интерфейс информационно-поисковых методов в Реализации sc-памяти в ostis-платформе}
\begin{scnsubstruct}
	
\scnheader{кортеж программных объектов конструкций в sc-памяти, изоморфных заданному графу-образцу}
\scnidtf{ScTemplateSearchResult}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\scnsubset{программный объект}
	
\scnstructheader{Программный интерфейс кортежа программных объектов конструкций в sc-памяти, изоморфных заданному графу-образцу}
\begin{scnsubstruct}
\scnrelto{программный интерфейс}{кортеж программных объектов конструкций в sc-памяти, изоморфных заданному графу-образцу}

\scnheader{Метод получения программного объекта конструкции в sc-памяти, изоморфной заданному графу-образцу, по его номеру в кортеже}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{ScTemplateSearchResultItem operator[](size\_t index) const noexcept(false)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{32-битовое целое число}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{программный объект конструкции в sc-памяти, изоморфной заданному графу-образцу}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{по заданному номеру нет элемента в кортеже}
\end{scnrelfromlist}

\scnheader{Метод получения программного объекта конструкции в sc-памяти, изоморфной заданному графу-образцу, по его номеру в кортеже с предварительной проверкой заданного номера}
\scniselement{метод}
\scniselement{метод без исключительных ситуаций}
\scntext{заголовок метода на языке представления методов}{bool Get(size\_t index, ScTemplateSearchResultItem \& outItem) const noexcept}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{32-битовое целое число}
	\scnitem{программный объект конструкции в sc-памяти, изоморфной заданному графу-образцу}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{логическое значение}
\end{scnrelfromlist}

\end{scnsubstruct}

\scnheader{программный объект конструкции в sc-памяти, изоморфной заданному графу-образцу}
\scnidtf{ScTemplateSearchResultItem}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\scnsubset{программный объект}

\scnstructheader{Программный интерфейс программного объекта конструкции в sc-памяти, изоморфной заданному графу-образцу}
\begin{scnsubstruct}
	
\scnrelto{программный интерфейс}{программный объект конструкции в sc-памяти, изоморфной заданному графу-образцу}

\scnheader{Метод получения sc-адреса элемента программного объекта конструкции в sc-памяти, изоморфной заданному графу-образцу, по его номеру в этом программном объекте}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{ScAddr const \& operator[](size\_t index) const noexcept(false)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{32-битовое целое число}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{sc-адрес элемента sc-памяти}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{по заданному номеру нет элемента в программном объекте конструкции в sc-памяти, изоморфной заданному графу-образцу}
\end{scnrelfromlist}

\scnheader{Метод получения sc-адреса элемента программного объекта конструкции в sc-памяти, изоморфной заданному графу-образцу, по его номеру в этом программном объекте с предварительной проверкой заданного номера}
\scniselement{метод}
\scniselement{метод без исключительных ситуаций}
\scntext{заголовок метода на языке представления методов}{bool Get(size\_t index, ScAddr \& outAddr) const noexcept}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{32-битовое целое число}
	\scnitem{sc-адрес элемента sc-памяти}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{логическое значение}
\end{scnrelfromlist}

\scnheader{Метод получения sc-адреса элемента программного объекта конструкции в sc-памяти, изоморфной заданному графу-образцу, по локальному идентификатору элемента соответствующего программного объекта трехэлементной конструкции в заданном программном объекте графа-образца}
\scniselement{метод}
\scntext{заголовок метода на языке представления методов}{ScAddr const \& operator[](std::string const \& name) const noexcept(false)}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{локальный идентификатор элемента трехэлементной конструкции в заданном графе-образце}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{sc-адрес элемента sc-памяти}
\end{scnrelfromlist}
\begin{scnrelfromlist}{класс исключительных ситуаций}
	\scnitem{по заданному локальному идентификатору нет элемента в программном объекте конструкции в sc-памяти, изоморфной заданному графу-образцу}
\end{scnrelfromlist}

\scnheader{Метод получения sc-адреса элемента программного объекта конструкции в sc-памяти, изоморфной заданному графу-образцу, по локальному идентификатору элемента соответствующего программного объекта трехэлементной конструкции заданного графа-образца с предварительной проверкой заданного локального идентификатора}
\scniselement{метод}
\scniselement{метод без исключительных ситуаций}
\scntext{заголовок метода на языке представления методов}{bool Get(std::string const \& name, ScAddr \& outAddr) const noexcept}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\begin{scnrelfromvector}{классы входных аргументов метода}
	\scnitem{локальный идентификатор элемента трехэлементной конструкции в заданном графе-образце}
	\scnitem{sc-адрес элемента sc-памяти}
\end{scnrelfromvector}
\begin{scnrelfromlist}{класс результата метода}
	\scnitem{логическое значение}
\end{scnrelfromlist}

\end{scnsubstruct}
	
\end{scnsubstruct}

\end{scnsubstruct}
\end{SCn}

Текущий \textbf{\textit{Метод поиска конструкций в sc-памяти, изоморфных данному графу-образцу}}, состоит из двух этапов: (1) \textit{Этапа предобработки графа-образца}, (2)\textit{Этапа поиска конструкций в sc-памяти, изоморфных заданному графу-образцу}. При этом внутри \textit{Метода поиска конструкций в sc-памяти, изоморфных данному графу-образцу} происходит создание программного \textit{итератора поиска конструкций в sc-памяти, изоморфных данному графу-образцу}, выполняющего весь алгоритм изоморфного поиска.

\begin{SCn}
\scnstructheader{Библиотека многократно используемых компонентов Программного варианта реализации ostis-платформы}
\begin{scnsubstruct}

\scnstructheader{Программный интерфейс информационно-поисковых методов в Реализации sc-памяти в ostis-платформе}
\begin{scnsubstruct}

\scnstructheader{Программный интерфейс программного объекта графа-образца}
\begin{scnsubstruct}

\scnheader{итератор поиска конструкций в sc-памяти, изоморфных данному графу-образцу}
\scnidtf{ScTemplateSearch}
\begin{scnindent}
	\scniselement{C++}
\end{scnindent}
\scnsubset{программный объект}
\begin{scnrelfromset}{понятие, специфицирующее заданную сущность}
	\scnitem{локальный идентификатор некоторого элемента в некотором программном объекте трехэлементной конструкции заданного графа-образца и множество всех номеров программных объектов трехэлементных конструкций в заданном графе-образце с этим элементом*}
	\begin{scnindent}
		\scnidtf{std::map<std::string, std::unordered\_set<size\_t>> m\_templateItemsNamesToDependedTemplateTriples}
	\end{scnindent}
	\scnitem{кортеж множеств номеров программных объектов трехэлементных конструкций компонент связности в заданном графе-образце}
	\begin{scnindent}
		\scnidtf{std::vector<std::unordered\_set<size\_t>> m\_connectivityComponentsTemplateTriples}
	\end{scnindent}
	\scnitem{множество номеров самых приоритетных для поиска программных объектов трехэлементных конструкций компонент связности в заданном графе-образце}
	\begin{scnindent}
		\scnidtf{std::vector<size\_t> m\_connectivityComponentPriorityTemplateTriples}
	\end{scnindent}
	\scnitem{кортеж множеств sc-адресов элементов sc-памяти, соответствующих sc-коннекторам, таких трехэлементных конструкций, которые не изоморфны соответствующим трехэлементным конструкциям заданного графа-образца, номера которых равны номерам позиций множеств в этом ориентированном множестве}
	\begin{scnindent}
		\scnidtf{std::vector<std::unordered\_set<ScAddr, ScAddrHashFunc<uint32\_t>>> m\_notUsedEdgesInTemplateTriples}
	\end{scnindent}
	\scnitem{кортеж множеств sc-адресов элементов sc-памяти, соответствующих sc-коннекторам, таких трехэлементных конструкций, которые изоморфны соответствующим трехэлементным конструкциям заданного графа-образца, номера которых равны номерам позиций множеств в этом ориентированном множестве}
	\begin{scnindent}
		\scnidtf{std::vector<std::unordered\_set<ScAddr, ScAddrHashFunc<uint32\_t>>> m\_usedEdgesInTemplateTriples}
	\end{scnindent}
	\scnitem{кортеж множеств sc-адресов элементов sc-памяти, соответствующих sc-коннекторам, являющихся вторыми элементами соответствующих трехэлементных конструкций найденных конструкций в sc-памяти, изоморфных заданному графу-образцу, номера которых равны номерам позиций множеств в этом ориентированном множестве}
	\begin{scnindent}
		\scnidtf{std::vector<std::unordered\_set<ScAddr, ScAddrHashFunc<uint32\_t>>> m\_usedEdgesInReplacementConstructions}
	\end{scnindent}
	\scnitem{кортеж множеств номеров программных объектов трехэлементных конструкций заданного графа-образца для найденных по нему изоморфных конструкций в sc-памяти, номера которых равны номерам позиций множеств в этом ориентированном множестве}
	\begin{scnindent}
		\scnidtf{std::vector<std::unordered\_set<size\_t>> m\_checkedTemplateTriplesInReplacementConstructions}
	\end{scnindent}
	\scnitem{номер последней найденной конструкции в sc-памяти по заданному графу-образцу}
	\begin{scnindent}
		\scnidtf{size\_t m\_lastReplacementConstructionIdx}
	\end{scnindent}
	\scnitem{множество номеров всех найденных и изоморфных конструкций в sc-памяти по заданному графу-образцу}
	\begin{scnindent}
		\scnidtf{std::unordered\_set<size\_t> m\_foundReplacementConstructions}
	\end{scnindent}
\end{scnrelfromset}
				
\end{scnsubstruct}

\end{scnsubstruct}

\end{scnsubstruct}
\end{SCn}

\textbf{\textit{Этап предобработки графа-образца}} состоит из \myuline{следующих} промежуточных шагов обработки:
\begin{textitemize}
	\item Добавление в отношение \textit{локальный идентификатор некоторого элемента в некотором программном объекте трехэлементной конструкции заданного графа-образца и множество всех номеров программных объектов трехэлементных конструкций в заданном графе-образце с этим элементом*} всех пар с локальными идентификаторами элементов в некотором программном объекте трехэлементной конструкции заданного графа-образца и множествами номеров соответствующих им программных объектов трехэлементных конструкций в заданном графе-образце. Во множества таких программных объектов не включаются те \textit{программные объекты трехэлементных конструкций} в заданном графе-образце, номера которых входят в локальный идентификатор самого элемента. Этот локальный идентификатор элемента не является локальным идентификатором этого элемента в рамках всего графа-образца. Такой локальный идентификатор формируется самой системой, а не пользователем \textit{Метода добавления трехэлементной конструкции для заданного графа-образца} (\textit{Метода добавления пятиэлементной конструкции для заданного графа-образца}) и состоит из локального идентификатора элемента в рамках всего графа-образца и номера соответствующего программного объекта трехэлементной конструкции в заданном графе-образце. Зная такой локальный идентификатор элемента некоторого \textit{программного объекта трехэлементной конструкции} графа-образца, можно быстро получать доступам к другим \textit{программным объектам трехэлементных конструкций}, в которых есть данный элемент.
	\item Удаление из множеств номеров \textit{программных объектов трехэлементных конструкций}, которые являются вторыми компонентами пар отношения \textit{локальный идентификатор некоторого элемента в некотором программном объекте трехэлементной конструкции заданного графа-образца и множество всех номеров программных объектов трехэлементных конструкций в заданном графе-образце с этим элементом*} и в которых есть элементы, являющиеся первыми компонентами этих пар, всех таких номеров \textit{программных объектов трехэлементных конструкций}, переход по которым в процессе поиска изоморфных по заданному графу-образцу конструкций может привести к зацикливанию алгоритма поиска конструкций по заданному графу-образцу. Данный этап предобработки сформированного \textit{программного объекта графа-образца} позволяет максимально возможным образом устранить переходы по таким \textit{программным объектам трехэлементных конструкций} заданного графа-образца, существенно усложняющие процесс изоморфного поиска конструкций по заданному графу-образцу. Такими \textit{программными объектами трехэлементных конструкций} являются программные объекты трехэлементных конструкций, например, у которых первыми элементами является sc-адрес одного и того же \textit{элемента sc-памяти, соответствующего sc-структуре}, или \textit{класс элемента sc-памяти\scnsupergroupsign, соответствующего переменной sc-структуре}, или sc-адрес одного и того же \textit{элемента sc-памяти, соответствующего sc-узлу неролевого отношения}. Поскольку сам SC-код позволяет представлять конструкции любой возможной конфигурации, то нельзя точно сказать, какие именно конфигурации конструкций могут приводить к циклическим ситуациям при выполнении алгоритма изоморфного поиска этих конструкций по заданному графу-образцу. Более универсальный алгоритм устранения циклов в графе-образце может привести к существенным дополнительным временным затратам, поскольку может потребовать более глубокого синтаксического анализа в исходном графе-образце, поэтому рекомендуется реализовывать условия, по которым можно определять программные объекты трехэлементных конструкций, переход по которым может привести к циклическим ситуациям в обработке графа-образца. Устранение циклов в графе-образце позволяет алгоритму изоморфного поиска конструкций по заданному графу-образцу более эффективно производить все требуемые операции над графами, поэтому он является ключевым этапом предобработки исходного \textit{программного объекта графа-образца}. Также данный шаг нельзя выполнять вместе с предыдущим шагом, поскольку для устранения всех циклов в графе-образце необходимо знать полностью все возможные переходы по этому графу-образцу.
	\item Поиск всех компонент связности в заданном графе-образце, то есть не связанных между собой подграфов в этом графе, и добавление всех соответствующих этим компонентам связности \textit{программных объектов трехэлементных конструкций} во множества \textit{кортежа множеств номеров программных объектов трехэлементных конструкций компонент связности в заданном графе-образце}. Таким образом, это позволяет найти даже такие компоненты связности, которые могли быть получены после выполнения второго шага алгоритма предобработки заданного графа-образца, то есть устранения циклов в заданном графе-образце. Разбиение графа-образца на компоненты связности могло быть одним из решений в задаче устранения цикла в заданном графе-образце, однако сам алгоритм изоморфного поиска конструкций по заданному графу-образцу является более совершенным и позволяет за один обход итератора поиска трехэлементных конструкций находить все трехэлементные конструкции для тем трехэлементных конструкций графа-образца, которые имеют один и тот же первый или третий элемент, поэтому разбиение графа-образца на компоненты связности не используется в предыдущем шаге.
	\item Последним шагом \textit{Этапа предобработки графа-образца} является выделение в найденных на предыдущем шаге \textit{Этапа предобработки графа-образца} компонентах связности самых приоритетных для поиска \textit{программных объектов трехэлементных конструкций} в заданном графе-образце. Самым приоритетным программным объектом трехэлементной конструкции является объект, имеющий номер приоритета, равный нулю, самым неприоритетным --- объект, имеющий номер приоритета, равный шести. При этом, если есть несколько \textit{программных объектов трехэлементных конструкций}, которые имеют один и тот же номер приоритета, то самым приоритетным из них считается тот объект, у которого первый (третий) элемент, являющийся sc-адресом элемента sc-памяти, имеет наименьшее количество элементов, соответствующих выходящим (входящим) sc-коннекторам. В результате формируется \textit{множество номеров самых приоритетных для поиска программных объектов трехэлементных конструкций компонент связности в заданном графе-образце}.
\end{textitemize}

Таким образом, \textit{Этап предобработки графа-образца} позволяет существенно упростить обработку графа-образца на этапе поиска изоморфных ему конструкций. Следующий \textbf{\textit{Этап поиска конструкций в sc-памяти, изоморфных заданному графу-образцу}} включает \myuline{следующие} шаги:
\begin{textitemize}
	\item \myuline{Если} заданный \textit{кортеж программных объектов конструкций в sc-памяти, изоморфных заданному графу-образцу} не пустой, то удалить из него все программные объекты конструкций в sc-памяти.
	\item \myuline{Если} \textit{множество номеров самых приоритетных для поиска программных объектов трехэлементных конструкций компонент связности в заданном графе-образце} является пустым, то это означает, что заданный \textit{граф-образец} является пустым. В таком случае результатом поиска является пустой \textit{кортеж программных объектов конструкций в sc-памяти, изоморфных заданному графу-образцу} и \textit{Этап поиска конструкций в sc-памяти, изоморфных заданному графу-образцу} завершается с успешным результатом.
	\item Инициализировать \textit{номер последней найденной конструкции в sc-памяти по заданному графу-образцу} значением, равным нулю. Задать \textit{Номер текущей найденной конструкции в sc-памяти по заданному графу-образцу}, равным \textit{номеру последней найденной конструкции в sc-памяти по заданному графу-образцу}. Задать \textit{множество номеров \scnqq{равносильных} программных объектов конструкций}, равным {множеству номеров самых приоритетных для поиска программных объектов трехэлементных конструкций компонент связности в заданном графе-образце}. Задать \textit{множество номеров текущих программных объектов конструкций}, равным \textit{множество номеров \scnqq{равносильных} программных объектов конструкций}.
	\item Из \textit{множество номеров \scnqq{равносильных} программных объектов конструкций} выбрать следующий номер. По полученному номеру из \textit{кортежа программных объектов трехэлементных конструкций в заданном графе-образце} взять соответствующий ему \textit{программный объект трехэлементной конструкции заданного графа-образца} в этом графе-образце.
	\item Для \textit{выбранного программного объекта трехэлементной конструкции} в заданнои графе-образце найти \myuline{все} такие \textit{программные объекты трехэлементных конструкций}, (1) у элементов которых заданные классы и sc-адреса совпадают с классами и sc-адресами элементов \textit{выбранного программного объекта трехэлементной конструкции} соответственно, при этом либо первые, либо третие их элементы имеют одинаковые локальные идентификаторы в заданном графе-образце или не имеют их вовсе, (2) для которых не были найдены соответствующие замены, то есть множеству, расположенному в \textit{кортеже множеств номеров программных объектов трехэлементных конструкций заданного графа-образца для найденных по нему изоморфных конструкций в sc-памяти, номера которых равны номерам позиций множеств в этом ориентированном множестве} по \textit{номеру текущей найденной конструкции в sc-памяти по заданному графу-образцу}, не принадлежат номера найденных \textit{программных объектов трехэлементных конструкций}, а также номера которых не принадлежат \textit{множеству номеров текущих программных объектов конструкций}. \textit{Множество номеров \scnqq{равносильных} программных объектов конструкций} сделать равным множеству всех найденных \textit{программные объекты трехэлементных конструкций}.
	\item \myuline{Если} полученное \textit{множество номеров \scnqq{равносильных} программных объектов конструкций} является пустым, то завершить данную итерацию алгоритма.
	\item \myuline{Если} полученное \textit{множество номеров \scnqq{равносильных} программных объектов конструкций} не является пустым, то из \textit{множества номеров \scnqq{равносильных} программных объектов конструкций} выбрать случайный номер. По полученному номеру из \textit{кортежа программных объектов трехэлементных конструкций в заданном графе-образце} взять соответствующий ему \textit{программный объект трехэлементной конструкции заданного графа-образца} в этом графе-образце.
	\item По полученному \textit{программному объекту трехэлементной конструкции} создать \textit{итератор поиска трехэлементных конструкций в sc-памяти}. Создание \textit{итератора поиска трехэлементных конструкций в sc-памяти} происходит при помощи \textit{Метода создания итератора поиска трехэлементных конструкций в sc-памяти}. Параметры метода назначаются элементы заданного \textit{программного объекта трехэлементной конструкции}, при этом вместо \textit{классов элементов sc-памяти, соответствующих sc-переменным} (\textit{классов элементов sc-памяти, соответствующих sc-метапеременным}), используются соответствующие им \textit{классы элементов sc-памяти, соответствующие sc-константам} (\textit{классы элементов sc-памяти, соответствующие sc-переменным}). То есть, например, если у некоторого элемента \textit{программного объекта трехэлементной конструкции} задан \textit{класс элементов sc-памяти, соответствующих переменным sc-узлам}, то вместо него для \textit{Метода создания итератора поиска трехэлементных конструкций в sc-памяти} используется соответствующий ему \textit{класс элементов sc-памяти, соответствующих константным sc-узлам}. Таким образом, при переходе от \textit{программного объекта трехэлементной конструкции} к \textit{программному итератору поиска трехэлементных конструкций sc-памяти} понижается степень переменности элементов \textit{программного объекта трехэлементной конструкции}: \textit{классы элементов sc-памяти, соответствующих sc-метапеременным} преобразуются в \textit{классы элементов sc-памяти, соответствующих sc-переменным}, а \textit{классы элементов sc-памяти, соответствующих sc-переменным} --- в \textit{классы элементов sc-памяти, соответствующих sc-константам}. Если \textit{класс элемента программного объекта трехэлементной конструкции} не является нестрогим подмножеством \textit{класса элементов sc-памяти, соответствующих sc-метапеременным} или \textit{класса элементов sc-памяти, соответствующих sc-переменным}, то степень переменности не понижается.
	\item С помощью \textit{Метода перехода к следующей "подходящей" для заданного итератора конструкции в sc-памяти} перейти к \textit{конструкции в sc-памяти}, изоморфной заданной конструкции в графе-образце.
\end{textitemize}

Несмотря на широкий спектр задач, которые можно решать при помощи текущей реализации \textit{изоморфного поиска}, существует ряд причин, по которым не следует использовать эту и другие реализации \textit{изоморфного поиска}:
\begin{textitemize}
	\item \textit{изоморфный поиск} позволяет решать широкий спектр задач, если все знания, изоморфные заданному \textit{графу-образцу}, находятся в \textit{базе знаний}, либо отсутствуют. То есть уровень качества \textit{изоморфного поиска} напрямую зависит от состояния \textit{базы знаний}. Чем разнообразнее \textit{фрагменты базы знаний}, тем хуже \textit{изоморфный поиск} в работе;
	\item Затраты на поиск при больших \textit{графах-образцах} могут расходится с желаниями разработчика или пользователя. Чем больше \textit{граф-образец}, тем больше ситуаций, в которых может быть нестандартное поведение алгоритма \textit{изоморфного поиска}.
	\item Большую часть задач, решаемых при помощи \textit{изоморфного поиска}, можно и нужно решать при помощи \textit{итераторов поиска трех- и пяти- элементных конструкций}. Чем проще метод решения задач, тем меньше ошибок и внештатных ситуаций можно получить.
\end{textitemize}	

\subsection{Общее описание процесса и Пример трансляции sc-текста в sc-память ostis-платформы}
\label{sec_soft_platform_scin_code_example}

\myuline{Любой} \textit{sc-конструкции} взаимно-однозначно соответствует \textit{конструкция sc-памяти} \textit{ostis-платформы}. Погрузка \textit{sc-конструкции} в \textit{sc-память ostis-платформы} означает трансляцию каждого sc-элемента этой \textit{sc-конструкции} и связей инцидентности между этими sc-элементами в \textit{sc-память ostis-платформы}, то есть трансляцию синтаксической структуры sc-конструкции в соответствующее представление внутри \textit{памяти ostis-системы}. В общем случае, алгоритм погрузки любой произвольной sc-конструкции в \textit{sc-память ostis-платформы} состоит из следующих этапов:
\begin{textitemize}
	\item Выделение sc-узлов и их синтаксических и семантических классов в sc-конструкции и создание соответствующих элементов в sc-памяти ostis-платформы при помощи \textit{Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-узлу};
	\item Выделение всех независимых sc-коннекторов и их синтаксических и семантических классов в sc-конструкции (то есть sc-коннекторов, у которых начальным и конечным sc-элементом не являются другие sc-коннекторы) между sc-узлами, для которых были созданы на шаге 1 соответствующие элементы в sc-памяти, и создание соответствующих элементов в sc-памяти ostis-платформы при помощи \textit{Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-коннектору};
	\item Возврат в пункт 2, если остались нетранслированные в sc-память sc-коннекторы (то есть sc-коннекторы, для которых не были созданы соответствующие элементы в sc-памяти ostis-платформы);
	\item Погрузка содержимого всех внутренних файлов ostis-системы в файловую память ostis-платформы (данный подпроцесс рассмотрен в \textit{\ref{sec_soft_platform_scfin_code_example}~\nameref{sec_soft_platform_scfin_code_example}}).
\end{textitemize}

На рисунке \textit{\nameref{fig:sc_code_in_memory_representation}} изображен пример спецификации представления sc-конструкции в \textit{sc-памяти ostis-платформы}. Здесь каждому sc-элементу заданной sc-конструкции ставится в соответствие sc-элемент, обозначающий элемент sc-памяти, соответствующий непосредственно этому sc-элементу. Для каждого sc-элемента, обозначающего элемент sc-памяти некоторого sc-элемента заданной sc-конструкции описываются связи между элементами sc-памяти, а также синтаксические и семантические классы этих элементов.

\subsection{Достоинства и недостатки Программного интерфейса Реализации sc-памяти в ostis-платформе}
\label{sec_soft_platform_sc_memory_interface_problems}

Текущий \textit{Программный интерфейс Реализации sc-памяти в ostis-платформе} позволяет:
\begin{textitemize}
	\item В необходимой и достаточной мере реализовывать \myuline{платформенно-зависимые} подсистемы текущего \textit{Программного варианта реализации ostis-платформы}, практически независимо от \textit{Реализации sc-памяти в ostis-платформе}. То есть текущий \textit{Программный интерфейс Реализации sc-памяти в ostis-платформе} является способом унификации доступа к программной \textit{Реализации sc-памяти в ostis-платформе} и позволяет \myuline{легко} подменять различные варианты реализации sc-памяти на \textit{языке представления методов} \textit{С++}, при этом сам \textit{Программный интерфейс Реализации sc-памяти в ostis-платформе} практически не меняется или не изменяется вовсе.
	\item Реализовывать базовые инструментальные средства для проектирования платформенно-независимых ostis-систем, например, \textit{Реализацию scp-интерпретатора}.
	\item Формировать и расширять \textit{Библиотеку многократно используемых компонентов Программного варианта реализации ostis-платформы} за счет компонентов, использующих методы \textit{Реализации sc-памяти в ostis-платформе} и входящих в состав различных программных расширений текущего \textit{Программного интерфейса Реализации sc-памяти в ostis-платформе}.
	\item Обеспечить различные уровни доступа к \textit{Реализации sc-памяти в ostis-платформе}, в том числе уровни доступа различных пользователей \textit{Программного варианта реализации ostis-платформы}. 
\end{textitemize}

Стоит отметить, что \textit{Программный интерфейс Реализации sc-памяти в ostis-платформе} не может существовать отдельно от текущей \textit{Реализации sc-памяти в ostis-платформе}. Кроме того, он является частью \textit{Реализации sc-памяти в ostis-платформе}, то есть проектируется и разрабатывается согласованно с реализацией самой sc-памяти. Однако при необходимости он может быть использован для различных модификаций или версий текущей \textit{Реализации sc-памяти в ostis-платформе}.

Несмотря на широкий спектр функциональных возможностей текущего \textit{Программного интерфейса Реализации sc-памяти в ostis-платформе}, к его недостатком можно отнести следующее:
\begin{textitemize}
	\item На уровне \textit{Программного интерфейса Реализации sc-памяти в ostis-платформе} никак не ограничивается диапозон классов sc-элементов в sc-памяти, которые могут быть установлены в качестве аргументов, например, для \textit{Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-узлу} и \textit{Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-коннектору}.
	\item Из-за недостатков текущей реализации агентной архитектуры в \textit{Программном варианте реализации ostis-платформы} \myuline{нельзя} для \textit{Программного интерфейса Реализации sc-памяти в ostis-платформе} использовать \textit{Реализацию sc-памяти в ostis-платформе}, хранящуюся в виде скомпилированного файла. Прежде всего это связано с тем, что платформенно-зависимые агенты реализуются средствами, которые используют создание исходных файлов при сборке всей платформы. Таким образом скомпилированные файлы остаются зависимыми от того устройства, где они были собраны.
\end{textitemize}

\section{Реализация файловой памяти в Программной платформе ostis-систем}
\label{sec_soft_platform_file_memory}

\begin{SCn}

\begin{scnrelfromlist}{подраздел}
	\scnitem{\ref{sec_soft_platform_scfin_code}~\nameref{sec_soft_platform_scfin_code}}
	\scnitem{\ref{sec_soft_platform_scfin_code_alphabet_and_syntax}~\nameref{sec_soft_platform_scfin_code_alphabet_and_syntax}}
	\scnitem{\ref{sec_soft_platform_scfin_code_semantic}~\nameref{sec_soft_platform_scfin_code_semantic}}
	\scnitem{\ref{sec_soft_platform_scfin_code_example}~\nameref{sec_soft_platform_scfin_code_example}}
	\scnitem{\ref{sec_soft_platform_scfin_code_problems}~\nameref{sec_soft_platform_scfin_code_problems}}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Реализация файловой памяти в ostis-платформе}
	\scnitem{SCfin-код}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевое знание}
	\scnitem{Спецификация Реализации файловой памяти в ostis-платформе}
	\scnitem{Принципы, лежащие в основе Реализации файловой памяти в ostis-платформе}
	\scnitem{Ответ на Вопрос. Как кодируются внешние информационные конструкции в текущей Реализации файловой памяти в ostis-платформе}
	\begin{scnindent}
		\scnidtf{Спецификация Метаязыка описания представления внешних информационных конструкций в файловой памяти ostis-платформы}
	\end{scnindent}
	\scnitem{Достоинства и недостатки Реализации файловой памяти в ostis-платформе}
\end{scnrelfromlist}

\end{SCn}

\textit{SC-код} является универсальным средством для представления любых видов знаний, \myuline{но} (!) не всегда есть необходимость погружать что-либо в \textit{sc-память ostis-платформы}, по крайней мере, на ранних стадиях развития \textit{ostis-платформы}. Это может быть объяснено и тем, что \textit{информационные конструкции, не принадлежащие SC-коду}, достаточно сложны в понимании для неподготовленного \textit{пользователя ostis-системы}. Для решения таких проблем на уровне \textit{Алфавита SC-кода\scnsupergroupsign} вводится дополнительный элемент --- \textit{внутренний файл ostis-системы}. С помощью \textit{внутренних файлов ostis-системы} можно представлять, хранить, обрабатывать и визуализировать \textit{информационные конструкции, не принадлежащие SC-коду}.

Поэтому при реализации \textit{sc-памяти} необходимо учитывать необходимость хранения \textit{информационных конструкций, не принадлежащих SC-коду}, с помощью \textit{SC-кода}. Кроме собственно \textit{sc-памяти} \textit{Реализация sc-памяти в ostis-платформе} включает также \textit{Реализацию файловой памяти ostis-платформы}, предназначенную для хранения содержимого \textit{внутренних файлов ostis-систем}, то есть \textit{внешние информационные конструкции} (линейные тексты, изображения, видео и так далее).

За весь период развития \textit{Программного варианта реализации ostis-платформы} было достаточно много попыток реализовать полно функциональную и быструю файловую память на базе популярных баз данных. Однако из всех этих решений не были учтены потенциальные проблемы при \textit{Реализации информационно-поисковой подсистемы Программного варианта реализации ostis-платформы}. Сейчас \textit{файловая память} реализована своими средствами, в качестве структур данных для хранения \textit{информационных конструкций}, не принадлежащих \textit{SC-коду}, используются префиксные деревья \scncite{Bayer1977} и линейные списки.

Выбор аргументируется тем, что:
\begin{textitemize}
    \item префиксные структуры достаточно просты в понимании и минимальны в своем синтаксисе;
    \item с помощью префиксных структур достаточно удобно хранить и обрабатывать связи типа \scnqq{ключ-значение};
    \item доступ к значению по ключу происходит в худшем случае за длину этого ключа \scncite{Belazzougui2010};
    \item за счет того, что префиксы склеиваются, выходит сильный выигрыш в использовании памяти.
\end{textitemize}

\begin{SCn}
\scnheader{Реализация файловой памяти в ostis-платформе}
\scniselement{реализация файловой памяти на основе префиксного дерева}
\scnrelto{программная модель}{файловая память ostis-платформы}
\scniselement{многократно используемый компонент ostis-систем, хранящийся в виде файлов исходных текстов}
\scniselement{атомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\begin{scnrelfromset}{зависимости компонента}
    \scnitem{Библиотека методов и структур данных GLib}
\end{scnrelfromset}
\begin{scnrelfromlist}{язык представления методов}
    \scnitem{C}
\end{scnrelfromlist}
\begin{scnrelfromlist}{внутренний язык}
    \scnitem{SCfin-код}
\end{scnrelfromlist}
\end{SCn}

\subsection{Спецификация Метаязыка описания представления конструкций, не принадлежащих SC-коду, в файловой памяти ostis-платформы}
\label{sec_soft_platform_scfin_code}

Для описания представления \textit{информационных конструкций}, не принадлежащих \textit{SC-коду}, внутри \textit{файловой памяти ostis-платформы} также необходим \textit{sc-язык}. Такой \textit{sc-язык} называется \textbf{\textit{Метаязыком описания представления информационных конструкций, не принадлежащих SC-коду, в файловой памяти ostis-платформы}}, или, кратко, \textit{\textbf{SCfin-кодом} (Semantic Сode file interior)}. \textit{файловая память} текстов, не принадлежащих \textit{SC-коду} (как абстрактную модель, по которой можно реализовывать соответствующую ей \textit{файловую память ostis-платформы}), можно рассматривать как подмножество \textit{sc.fin-текста}.

\begin{SCn}
\scnheader{SCfin-код}
\scnidtf{Semantic Code file interior}
\scnidtf{Язык описания представления информационных конструкций, не принадлежащих SC-коду, внутри файловой памяти ostis-платформы}
\scnidtf{Метаязык описания представления информационных конструкций, не принадлежащих SC-коду, внутри файловой памяти ostis-платформы}
\scntext{часто используемый sc-идентификатор}{sc.fin-текст}
\begin{scnindent}
    \scniselement{имя нарицательное}
\end{scnindent}
\scniselement{абстрактный язык}
\scniselement{метаязык}
\scniselement{sc-язык}
\scnsubset{SC-код}
\scnsuperset{файловая память ostis-платформы}
\end{SCn}

\subsection{Алфавит и Синтаксис SCfin-кода}
\label{sec_soft_platform_scfin_code_alphabet_and_syntax}

\textit{Синтаксис SCfin-кода} задается: (1) \textit{Алфавитом SCfin-кода\scnsupergroupsign}, (2) отношением порядка \textit{последовательность в линейном тексте*}.

\begin{SCn}
\scnheader{Алфавит SCfin-кода\scnsupergroupsign}
\scnidtf{синтаксический тип элемента файловой памяти ostis-платформы}
\scnidtf{Множество типов элементов файловой памяти ostis-платформы}
\scnrelto{алфавит}{SCfin-код}
\begin{scneqtoset}
    \scnitem{элемент файловой памяти ostis-платформы, соответствующий подстроке текста линейного языка}
\end{scneqtoset}
\end{SCn}

\textbf{\textit{Алфавит SCfin-кода\scnsupergroupsign}} состоит из одного синтаксически выделяемого типа элементов файловой памяти --- \textit{элемента файловой памяти ostis-платформы, соответствующего подстроке текста линейного языка}.

\begin{SCn}
\scnheader{элемент файловой памяти ostis-платформы, соответствующий подстроке текста линейного языка}
\scniselement{sc-элемент}
\scnidtf{элемент файловой памяти ostis-платформы}
\scnidtf{ячейка файловой памяти ostis-платформы}
\scnidtf{образ подстроки информационной конструкции, не принадлежащей SC-коду, в рамках файловой памяти ostis-платформы}
\end{SCn}

Отношение \textbf{\textit{последовательности в линейном тексте*}} определяется как бинарное ориентированное отношение порядка, компонентами каждой ориентированной пары которого являются элементы файловой памяти ostis-платформы, соответствующие некоторым подстрокам линейного текста, в результате конкатенации которых образуется подстрока, принадлежащая этому же линейному тексту.

\textit{Синтаксис SCfin-кода} достаточно прост, поскольку информационные конструкции на нем задаются при помощи \textit{Алфавита SCfin-кода\scnsupergroupsign}, мощность которого равна 1, и единственного отношения инцидентности \textit{последовательности в линейном тексте*}. Иерархии синтаксических элементов как таковые не выделяются, поскольку в этом нет необходимости.

На уровне реализации важно выделить семантические классы \textit{элементов файловой памяти ostis-платформы, соответствующих подстроке текста линейного языка}, которые обозначают некоторую префиксную или постфиксную часть целой информационной конструкции.

\subsection{Денотационная семантика SCfin-кода}
\label{sec_soft_platform_scfin_code_semantic}

\begin{SCn}
\scnstructheader{Семантическая классификация элементов SCfin-кода}
\begin{scnsubstruct}

\scnheader{элемент файловой памяти ostis-платформы, соответствующий тексту линейного языка}
\scnrelfrom{разбиение}{Типология элементов по месту расположения подстроки в линейном тексте}
\begin{scnindent}
    \begin{scneqtoset}
        \scnitem{элемент файловой памяти ostis-платформы, соответствующий префиксной подстроке текста линейного языка}
        \scnitem{элемент файловой памяти ostis-платформы, соответствующий постфиксной подстроке текста линейного языка}
    \end{scneqtoset}
\end{scnindent}

\end{scnsubstruct}
\end{SCn}

На \textit{SCfin-коде} достаточно просто задавать \textit{информационные конструкции} любых линейных текстов. Однако с точки зрения реализуемой модели sc-памяти есть необходимость задавать не столько форму \textit{информационных конструкций}, не принадлежащих \textit{SC-коду}, внутри \textit{файловой памяти ostis-платформы}, сколько связи между этими внутренними \textit{файлами ostis-системы}, являющихся знаками \textit{SC-кода}. Одновременно должны быть реализованы на уровне \textit{sc-памяти} и \textbf{\textit{Метод получения файлов ostis-системы, которые содержат заданную внешнюю информационную конструкцию}}, и \textbf{\textit{Метод получения внешних информационных конструкций из заданных файлов ostis-системы}}.

\subsection{Описание процесса и Пример трансляции внешних информационных конструкций в файловую память ostis-платформы}
\label{sec_soft_platform_scfin_code_example}

На рисунке \textit{\nameref{fig:file_in_memory_representation}} показано представление \textit{информационных конструкций, не принадлежащих SC-коду} и соответствия между файлами ostis-системы и информационными конструкциями. С помощью отношения \textit{множество sc-адресов файлов ostis-системы по префиксам их содержимого*} задается бинарная ориентированная пара, первым компонентом которой является префиксная структура, элементами которой являются подстроки внешних информационных конструкций, а вторым компонентом --- множество соответствующих им sc-адресов файлов ostis-системы, а с помощью отношения \textit{множество постфиксов содержимого файлов ostis-системы по их sc-адресам*} задается бинарная ориентированная пара, первым компонентом которой является префиксная структура, элементами которой являются подстроки sc-адресов файлов ostis-системы, представленных в строковом виде, а вторым компонентом --- множество соответствующих им постфиксов внешних информационных конструкций префиксной структуры, являющейся первым компонентом каждой пары отношения \textit{множество sc-адресов файлов ostis-системы по префиксам их содержимого*}.

\begin{figure*}[htbp]
	\caption{SCg-текст. Пример спецификации представления информационных конструкций, не принадлежащих SC-коду, в памяти ostis-системы}
	\includegraphics[scale=0.6]{author/part6/figures/file_in_memory_representation.png}
	\label{fig:file_in_memory_representation}
\end{figure*}

\subsection{Достоинства и недостатки Реализации файловой памяти ostis-платформы и Метаязыка описания представления внешних информационных конструкций в файловой памяти ostis-платформы}
\label{sec_soft_platform_scfin_code_problems}

Используемая \textit{Реализация файловой памяти ostis-платформы} полностью оправдывает себя при взаимодействии с системой. Благодаря использованию префиксных структур асимптотические сложности метода получения множества внешних информационных конструкций из заданных \textit{файлов ostis-системы} и метода получения множества файлов ostis-системы по заданным \textit{внешним информационным конструкциям} линейны, так как зависит от длины заданной строки и структуры префиксного дерева.

Среди общих недостатков данной \textit{Реализации файловой памяти ostis-платформы} можно выделить следующие:
\begin{textitemize}
    \item \textit{информационные конструкции}, не принадлежащие SC-коду, пока полностью хранятся в оперативной памяти компьютерного устройства, на котором развернута платформа. Данную проблему можно решить, если в оперативной памяти хранить только первые знаки подстрок информационных конструкций, а остальные части этих подстрок хранить на уровне файлового системы;
    \item на данный момент информационно-поисковая подсистема реализована \myuline{не полностью}. \textit{Реализация файловой памяти ostis-платформы} позволяет \myuline{быстро} решать задачи поиска внешних информационных конструкций по их префиксным подстрокам, однако не позволяет быстро решать задачи поиска информационных конструкций по любой подстроке, даже для которого задан некоторый шаблон-образец.
\end{textitemize}

Описанные проблемы будут решены в рамках будущей версии \textit{Программного варианта реализации ostis-платформы}.

\section{Реализация подсистемы сетевого взаимодействия c sc-памятью на основе языка JSON в ostis-платформе}
\label{sec_soft_platform_sc_server_subsystem}

\begin{SCn}

\begin{scnrelfromlist}{подраздел}
	\scnitem{\ref{sec_soft_platform_sc_json_code}~\nameref{sec_soft_platform_sc_json_code}}
	\scnitem{\ref{sec_soft_platform_sc_json_code_alphabet_and_syntax}~\nameref{sec_soft_platform_sc_json_code_alphabet_and_syntax}}
	\scnitem{\ref{sec_soft_platform_sc_json_code_grammar}~\nameref{sec_soft_platform_sc_json_code_grammar}}
	\scnitem{\ref{sec_soft_platform_sc_server}~\nameref{sec_soft_platform_sc_server}}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Реализация подсистемы сетевого взаимодействия c sc-памятью на основе языка JSON в ostis-платформе}
	\scnitem{JSON}
	\scnitem{Websocket}
	\scnitem{HTTP}
	\scnitem{Реализация Серверной системы на основе Websocket и JSON, обеспечивающей сетевой доступ к памяти ostis-платформы}
	\scnitem{Реализация клиентской системы на языке программирования Python}
	\scnitem{Реализация клиентской системы на языке программирования TypeScript}		
	\scnitem{Реализация клиентской системы на языке программирования C\#}
	\scnitem{Реализация клиентской системы на языке программирования Java}
	\scnitem{SC-JSON-код}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевое понятие}
	\scnitem{команда на SC-JSON-коде}
	\scnitem{ответ на команду на SC-JSON-коде}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевое знание}
	\scnitem{Спецификация Реализации подсистемы сетевого взаимодействия c sc-памятью на основе языка JSON в ostis-платформе}
	\scnitem{Принципы, лежащие в основе Реализации подсистемы сетевого взаимодействия c sc-памятью на основе языка JSON в ostis-платформе}
	\scnitem{Отличие Websocket от HTTP}
	\scnitem{Ответ на Вопрос. Как реализуется взаимодействие между подсистемами в ostis-платформе}
	\begin{scnindent}
		\scnidtf{Спецификация Метаязыка описания представления сообщений между подсистемами ostis-платформы}
	\end{scnindent}
\end{scnrelfromlist}

\end{SCn}

Зачастую, просто \textit{Программного интерфейса Реализации sc-памяти в ostis-платформе} недостаточно, чтобы получать доступ к ее элементам. Это обуславливается тем, что:
\begin{textitemize}
	\item Для реализации задаче-ориентированных компонентов платформы необходимо учитывать функциональные возможности \textit{языков программирования}, используемых для их разработки. Так, например, для реализации интерфейсов по ряду причин лучше использовать \textit{языки программирования} более высокого уровня по сравнению с \textit{C++} (\textit{JavaScript}, \textit{TypeScript} и так далее).
	\item В силу существующего многообразия форм представления программ необходимо иметь возможность интегрировать уже существующие решения в области современных технологий программирования с существующим \textit{Программным вариантом реализации ostis-платформы}.
	\item Данный интерфейсе требует того, чтобы клиентское приложение, обращающееся к программной модели \textit{sc-памяти}, фактически составляло с ней единое целое, таким образом исключается возможность построения распределенного коллектива \textit{ostis-систем} на базе реализуемого \textit{Программного варианта реализации ostis-платформы}.
\end{textitemize}

По этим причинам в \textit{Программном варианте реализации ostis-платформы} необходимо иметь дополнительные средства доступа к памяти платформы. Такие средства могут быть реализованы в виде серверной подсистемы текущего \textit{Программного варианта реализации ostis-платформы}, с помощью которой можно общаться с \textit{памятью ostis-платформы} через современные сетевые протоколы.

В общем случае такая \myuline{подсистема взаимодействия ostis-платформы с внешней средой может быть реализована по-разному}. Так, например, до момента реализации текущей подсистемы ранее существовал ее аналог на языке программирования Python, который использовал \textit{протокол HTTP} и бинарное представление команд и ответов.
Поэтому можно говорить о большом разнообразии таких подсистем, которые будут составлять множество всевозможных \textit{Реализаций подсистемы взаимодействия с внешней средой с использованием сетевых языков}.

Данная \textbf{\textit{Реализация подсистемы сетевого взаимодействия c sc-памятью на основе языка JSON в ostis-платформе}} позволяет ostis-системам взаимодействовать с системами из внешней среды на основе общепринятого транспортного формата передачи данных JSON и предоставляет сетевое API для доступа к sc-памяти \textit{Программного варианта реализации ostis-платформы}.

\begin{SCn}
\scnheader{Реализация подсистемы взаимодействия с внешней средой с использованием сетевых языков}
\begin{scnrelfromset}{декомпозиция программной системы}
    \scnitem{Реализация подсистемы взаимодействия с внешней средой с использованием сетевых языков на основе языка JSON}
\end{scnrelfromset}
\end{SCn}

\begin{SCn}
\scnheader{Реализация подсистемы сетевого взаимодействия c sc-памятью на основе языка JSON в ostis-платформе}
\scnidtf{Подсистема взаимодействия с sc-памятью на основе формата JSON}
\scnidtf{Сетевой программный интерфейс Реализации sc-памяти в ostis-платформе}
\scnidtf{Предлагаемый нами вариант реализации механизма доступа к sc-памяти ostis-платформы в распределенном коллективе ostis-систем}
\scniselement{многократно используемый компонент ostis-систем, хранящийся в виде файлов исходных текстов}
\scniselement{неатомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\scniselement{клиент-серверная система}
\begin{scnrelfromlist}{используемый язык представления методов}
    \scnitem{C}
    \scnitem{C++}
    \scnitem{Python}
    \scnitem{TypeScript}
    \scnitem{C\#}
    \scnitem{Java}
\end{scnrelfromlist}
\begin{scnrelfromlist}{используемый язык}
    \scnitem{SC-JSON-код}
\end{scnrelfromlist}
\begin{scnrelfromset}{декомпозиция программной системы}
    \scnitem{Реализация Серверной системы на основе Websocket и JSON, обеспечивающей сетевой доступ к памяти ostis-платформы}
    \scnnonamednode
    \begin{scneqtoset}
        \scnitem{Реализация клиентской системы на языке программирования Python}
        \scnitem{Реализация клиентской системы на языке программирования TypeScript}
        \scnitem{Реализация клиентской системы на языке программирования C\#}
        \scnitem{Реализация клиентской системы на языке программирования Java}
    \end{scneqtoset}
\end{scnrelfromset}
\end{SCn}

Взаимодействие c sc-памятью обеспечивается с помощью передачи информации на \textit{SC-JSON-коде} и ведется, с одной стороны, между сервером, являющегося частью ostis-системы, написанным на том же языке реализации этой \textit{ostis-системы} и имеющим доступ к ее sc-памяти, и с другой стороны множеством клиентов, которым известно о наличии сервера в пределах сети их использования. С помощью подсистемы взаимодействия с sc-памятью на основе языка JSON можно взаимодействовать с \textit{ostis-системой} на таком же множестве возможных операций, как и в случае, если бы взаимодействие происходило (непосредственно) напрямую, на том же языке реализации \textit{ostis-платформы}. При этом результат работы отличается только скоростью обработки информации.

Среди эффективных протоколов, используемых при реализации \textit{клиент-серверных систем}, стоит отметить протоколы прикладного уровня стека \textit{TCP/IP} --- протоколы \textbf{\textit{HTTP}} и \textbf{\textit{WebSocket}} \scncite{Bhumij2018}. Целесообразным является использование протокола \textit{WebSocket}, это объясняется следующими причинами:

\begin{textitemize}
    \item \textit{WebSocket} выгодно использовать в веб-ориентированных системах, в которых данные, отправляемые сервером, представляются или сохраняются на стороне клиента. В \textit{WebSocket} данные постоянно передаются через одно и то же открытое \textit{соединение}, поэтому коммуникация по протоколу \textit{WebSocket} быстрее чем коммуникация по HTTP \scncite{Tomasetti2021}, \scncite{Bhumij2018}. Это очень важно с точки зрения проектирования \textit{Экосистемы OSTIS}, которые могут состоять из \myuline{десятков тысяч} различного вида \textit{ostis-систем}.
    \item Поскольку в основе \textit{ostis-систем} лежит идея агентно-ориентированной обработки знаний (асинхронной обработки), а память таких систем должна быть одновременно распределенной и общей, то необходимо, чтобы каждая из них (в частности, самостоятельная \textit{ostis-система}) могла общаться с другими \textit{ostis-системами}. Причем такое общение может и должно происходить посредством инициирования событий в памяти этих систем. Отсюда следует однозначный вывод, что протокол \textit{HTTP} не может быть использован в передовых \textit{интеллектуальных системах нового поколения} по причине однонаправленности создаваемого им соединения.
\end{textitemize}

В силу слабой развитости средств для обработки текстов на \textit{SCs-коде} в качестве языка коммуникации систем был разработан строковый язык на базе языка \textit{JSON} \scncite{Marrs2017} --- \textit{SC-JSON-код}. Его выбор объясняется гибкостью задания отношений между описываемыми им объектами.

\subsection{Спецификация Метаязыка представления сообщений между подсистемами ostis-платформы. SC-JSON-код}
\label{sec_soft_platform_sc_json_code}

Подсистемы в рамках реализуемого программного варианта \textit{специализированной ostis-платформы} общаются с помощью \textit{языка внешнего представления знаний} \textbf{\textit{SC-JSON-код}}. Данный язык является строковым, то есть линейным, и простым в обработке, поскольку существует большое количество средств для обработки его надъязыка \textit{JSON}.

\begin{SCn}
\scnheader{SC-JSON-код}
\scnidtf{Semantic JSON-code}
\scnidtf{Semantic JavaScript Object Notation code}
\scnidtf{Метаязык описания представления сообщений между подсистемами ostis-платформы}
\scntext{часто используемый sc-идентификатор}{sc-json-текст}
\scnidtf{Предлагаемый нами язык взаимодействия в распределенном коллективе ostis-систем}
\begin{scnindent}
    \scniselement{имя нарицательное}
\end{scnindent}
\scniselement{абстрактный язык}
\scnsubset{SC-код}
\scnsubset{JSON}
\end{SCn}

\subsection{Синтаксис SC-JSON-кода}
\label{sec_soft_platform_sc_json_code_alphabet_and_syntax}

\textit{Синтаксис SC-JSON-кода} задается: (1) \textit{Алфавитом SC-JSON-кода\scnsupergroupsign}, (2) Грамматикой SC-JSON-кода. В Алфавите SC-JSON-кода\scnsupergroupsign выделяется базовая синтаксическая классификация его элементов.

\begin{SCn}
\scnstructheader{Синтаксическая классификация элементов SC-JSON-кода}

\begin{scnsubstruct}
\scnstructheader{SC-JSON-код}
\scnrelto{семейство подмножеств}{sc-json-предложение}
\begin{scnindent}
    \scnsubset{json-список json-пар}
    \scnrelto{семейство подмножеств}{sc-json-пара*}
    \begin{scnindent}
        \begin{scnreltovector}{декартово произведение}
            \scnitem{sc-json-строка}
            \scnitem{sc-json-объект}
        \end{scnreltovector}
    \end{scnindent}
    \begin{scnrelfromset}{разбиение}
        \scnitem{команда на SC-JSON-коде}
        \scnitem{ответ на команду на SC-JSON-коде}
    \end{scnrelfromset}
\end{scnindent}

\scnheader{sc-json-объект}
\begin{scnrelfromset}{разбиение}
    \scnitem{sc-json-cписок}
    \scnitem{sc-json-пара}
    \scnitem{sc-json-литерал}
    \begin{scnindent}
        \begin{scnrelfromset}{разбиение}
            \scnitem{sc-json-строка}
            \scnitem{sc-json-число}
        \end{scnrelfromset}
    \end{scnindent}
\end{scnrelfromset}
\end{scnsubstruct}
\end{SCn}

\textbf{\textit{Алфавит SC-JSON-кода\scnsupergroupsign}} представляет собой множество всех возможных символов в SC-JSON-коде. Поскольку \textit{SC-JSON-код} является линейным строковым языком представления знаний, то его алфавит включает объединение алфавитов всех языков, тексты на которых могут представлять внешние идентификаторы и/или содержимое \textit{файлов ostis-системы}, множество всех цифр и множество всех других специальных символов. Последовательности знаков алфавита могут образовывать sc-json ключевые слова, \textit{sc-json-пары}, \textit{sc-json-предложения} из \textit{sc-json-пар} и \textit{sc-json-тексты} из \textit{sc-json-предложений}. При этом конструкции на \textit{SC-JSON-коде} строятся по следующим \textbf{\textit{Синтаксическим правилам SC-JSON-кода}}:
\begin{textitemize}
    \item Каждое правило \textit{Грамматики SC-JSON-кода} описывает корректный с точки зрения \textit{Синтаксиса SC-JSON-кода} порядок sc-json-объектов в sc-json-предложении. Совокупность правил \textit{Грамматики SC-JSON-кода} описывает корректный с точки зрения \textit{Синтаксиса SC-JSON-кода} порядок \textit{sc-json-предложений} в \textit{sc-json-тексте}. Каждое sc-json-предложение является \textit{sc-json-списком}, состоящим из \textit{sc-json-пар} и представляет собой команду или ответ на эту команду.
    \item Каждая \textit{команда (ответ на команду) на SC-JSON-коде} состоит из заголовка, включающего \textit{sc-json-пары} описания самой команды (ответа на команду), и сообщения, различного для каждого класса команд (ответов на команды). Сообщение \textit{команды (ответа на команду) на SC-JSON-коде} обычно представляет собой список \textit{sc-json-объектов} и может не ограничиваться по мощности.
    \item Каждая \textit{sc-json-пара} состоит из двух элементов: ключевого слова и некоторого другого \textit{sc-json-объекта}, ассоциируемого с этим ключевым словом. Набор ключевых слов в \textit{sc-json-парах} определяется конкретным классом \textit{команд (ответов на команды) на SC-JSON-коде}. \textit{Sc-json-пара} начинается знаком открывающейся фигурной скобки \scnqq{\{} и заканчивается знаком закрывающейся фигурной скобки \scnqq{\}}. Ключевое слово и sc-json-объект, ассоциируемый с ним, разделяются при помощи знака двоеточия \scnqq{:}.
    \item \textit{sc-json-строки}, записанные в sc-json-текстах, начинаются и заканчиваются знаком двух ковычек \textquotedblleft.
    \item \textit{sc-json-списки}, состоящие не из \textit{sc-json-пар}, начинаются знаком открывающейся квадратной скобки \scnqq{[} и заканчиваются знаком закрывающейся квадратной скобки \scnqq{]}. \textit{sc-json-объекты} в \textit{sc-json-списках} разделяются запятыми \scnqq{,}.
\end{textitemize}

\subsection{Грамматика SC-JSON-кода}
\label{sec_soft_platform_sc_json_code_grammar}

\textbf{\textit{Грамматика SC-JSON-кода}} представляет собой множество всех возможных правил, используемых при построении команд и ответов на них на \textit{SC-JSON-коде}. Каждой команде \textit{SC-JSON-кода} однозначно соответствует правило грамматики \textit{SC-JSON-кода}. Правила \textit{Грамматики SC-JSON-кода} позволяют правильно представлять команды на \textit{SC-JSON-коде}. Каждое правило грамматики \textit{SC-JSON-кода} представляется в виде правила на \textit{Языке описания грамматик ANTLR} и его интерпретации на \textit{естественном языке}.

\begin{SCn}
\scnheader{Грамматика SC-JSON-кода}
\scnhaselementrole{ключевой sc-элемент}{Правило, задающее синтаксис \textit{команд на SC-JSON-коде}}
\begin{scnindent}
    \scnrelto{синтаксическое правило}{команда на SC-JSON-коде}
\end{scnindent}
\scnhaselementrole{ключевой sc-элемент}{Правило, задающее синтаксис \textit{ответов на команды на SC-JSON-коде}}
\begin{scnindent}
    \scnrelto{синтаксическое правило}{ответ на команду на SC-JSON-коде}
\end{scnindent}
\scnhaselement{Правило, задающее синтаксис \textit{команды создания элементов в sc-памяти}}
\begin{scnindent}
    \scnrelto{синтаксическое правило}{команда создания элементов в sc-памяти}
\end{scnindent}
\scnhaselement{Правило, задающее синтаксис \textit{ответа на команду создания элементов в sc-памяти}}
\begin{scnindent}
    \scnrelto{синтаксическое правило}{ответ на команду создания элементов в sc-памяти}
\end{scnindent}
\end{SCn}

\textbf{\textit{Правило, задающее синтаксис \textit{команд на SC-JSON-коде}}}, представлено на рисунке \textit{\nameref{fig:command}}. Класс \textit{команд на SC-JSON-коде} включает \textit{команду создания элементов в sc-памяти}, \textit{команду получения классов элементов sc-памяти}, \textit{команду удаления элементов из sc-памяти}, \textit{команду обработки ключевых sc-элементов}, \textit{команду обработки содержимого элементов sc-памяти, соответствующих файлам ostis-системы}, \textit{команду поиска конструкций в sc-памяти, изоморфных заданному программному объекту графа-образца}, \textit{команду создания конструкции в sc-памяти, изоморфной заданному программному объекту графа-образца}, и \textit{команду обработки sc-событий}. В \textit{команду на SC-JSON-коде} включаются идентификатор этой команды, тип и сообщение.

\begin{figure}[H]
  \center
   \caption{Рисунок. Описание Правила, задающего синтаксис \textit{команд на SC-JSON-коде}}
  \includegraphics[scale=0.9]{author/part6/figures/command.png}
  \label{fig:command}
\end{figure}

\textbf{\textit{Правило, задающее синтаксис \textit{ответа на команду на SC-JSON-коде}} }описывает синтаксис ответов на команды, описываемых предыдущим правилом. Класс \textit{ответов на команды на SC-JSON-коде} включает \textit{ответ на команду создания элементов в sc-памяти}, \textit{ответ на команду получения классов элементов в sc-памяти}, \textit{ответ на команду удаления элементов из sc-памяти}, \textit{ответ на команду обработки ключевых элементов в sc-памяти}, \textit{ответ на команду обработки содержимого элементов sc-памяти, соответствующих файлам ostis-системы}, \textit{ответ на команду поиска конструкций в sc-памяти, изоморфных заданному программному объекту графа-образца}, \textit{ответ на команду создания конструкции в sc-памяти, изоморфной заданному программному объекту графа-образца}, и \textit{ответ на команду обработки sc-событий}. В \textit{ответ на команду на SC-JSON-коде} включаются идентификатор соответствующей команды, статус обработки ответа и ответное сообщение \textit{\nameref{fig:command_answer}}.

\begin{figure}[H]
	\caption{Рисунок. Описание Правила, задающего синтаксис ответов на команды SC-JSON-кода на языке ANTLR}
  \includegraphics[scale=0.5]{author/part6/figures/command_answer.png}
  \label{fig:command_answer}
\end{figure}

В сообщении \textbf{\textit{команды создания sc-элементов}} представляется список описаний создаваемых элементов в sc-памяти. Такими элементами могут быть элемент sc-памяти, соответствующий sc-узлу, sc-коннектору или файлу ostis-системы. Класс элемента указывается в паре с ключевым словом \scnqq{el}: для элемента sc-памяти, соответствующего sc-узлу, sc-json-класс элемента представляется как \scnqq{node}, для элемента sc-памяти, соответствующего sc-коннектору --- \scnqq{edge}, для элемента sc-памяти, соответствующего файлу ostis-системы --- \scnqq{link}. Метки классов sc-элементов уточняются в соответствующих им описаниях в сообщении команды в паре с ключевым словом \scnqq{type}. Если создаваемым элементом является элемент sc-памяти, соответствующего файлу ostis-системы, то дополнительно указывается содержимое этого файла ostis-системы в паре с ключевым словом \scnqq{content}, если создаваемым элементом является элемент sc-памяти, соответствующего sc-коннектору, то указываются описания элементов, из которых они выходят, и элементов, в которые они входят. Описание таких элементов состоят из двух пар: первая пара указывает на способ ассоциации с элементом и представляется как \scnqq{addr} или \scnqq{idtf} или \scnqq{ref} в паре с ключевым словом \scnqq{type}, вторая пара --- то, по чему происходит ассоциация с этим элементом: хэш его sc-адреса, локальному идентификатору или номеру в массиве создаваемых элементов --- в паре с ключевым словом \scnqq{value} \textit{\nameref{fig:create_elements_command}}.

\begin{figure}[H]
	\center
	\caption{Рисунок. Описание Правила, задающего синтаксис \textit{команды создания элементов в sc-памяти} на языке ANTLR}
	\includegraphics[scale=0.8]{author/part6/figures/create_elements_command.png}
	\label{fig:create_elements_command}
\end{figure}

Сообщением \textbf{\textit{ответа на команду создания элементов в sc-памяти}} является список хэшей sc-адресов созданных элементов в sc-памяти, соответствующих описаниям \textit{команды создания элементы создания в sc-памяти} со статусом 1, в случае успешной обработки команды \textit{\nameref{fig:create_elements_command_answer}}.

\begin{figure}[H]
	\center
	\caption{Рисунок. Описание Правила, задающего синтаксис \textit{ответа на команду создания элементов в sc-памяти} на языке ANTLR}
	\includegraphics[scale=0.8]{author/part6/figures/create_elements_command_answer.png}
	\label{fig:create_elements_command_answer}
\end{figure}

Множество \textit{команд на SC-JSON-коде} легко расширяемо засчет гибкости и функциональности языка JSON. Множество \textit{ответов на команды на SC-JSON-коде} также легко расширяемо вместе с расширением \textit{команд на SC-JSON-коде}.

Детальное описание синтаксиса команд и ответов на эти команды, а также их примеры можно найти в Стандарте OSTIS (см. \scncite{Standart2021}).

\subsection{Реализация Серверной системы на основе Websocket и JSON, обеспечивающей сетевой доступ к памяти ostis-платформы}
\label{sec_soft_platform_sc_server}

\textbf{\textit{Реализация Серверной системы на основе Websocket и JSON, обеспечивающей сетевой доступ к памяти ostis-платформы}}, представляет собой интерпретатор команд и ответов на них \textit{SC-JSON-кода} в программное представление конструкций в памяти ostis-платформы, использующий \textit{Библиотеку программных компонентов для обработки json-текстов JSON for Modern C++} и \textit{Библиотеку кросс-платформенных программных компонентов для реализации серверных приложений на основе Websocket WebSocket++}. \textit{Реализация Серверной системы на основе Websocket и JSON, обеспечивающей сетевой доступ к памяти ostis-платформы} обеспечивается комплексным тестовым покрытием посредством программных фреймворков \textit{Google Tests} и \textit{Google Benchmark Tests}. \textit{Библиотека программных компонентов для обработки json-текстов JSON for Modern C++} имеет богатый, удобный и быстродействующий функционал, необходимый для реализации подобных компонентов ostis-систем, а \textit{Библиотека кросс-платформенных программных компонентов для реализации серверных приложений на основе Websocket WebSocket++} позволяет элегантно проектировать серверные системы без использовании избыточных зависимостей и решений. Настройка программного компонента осуществляется с помощью \textit{Программного компонента настройки программных компонентов ostis-систем} и скриптов языков CMake и Bash.

\begin{SCn}
\scnheader{Реализация Серверной системы на основе Websocket и JSON, обеспечивающей сетевой доступ к памяти ostis-платформы}
\scnidtf{Реализация системы, работающей по принципам Websocket и предоставляющей параллельно-асинхронный многоклиентский доступ к sc-памяти платформы интерпретации sc-моделей при помощи SC-JSON-кода}
\scnidtf{sc-json-сервер}
\scntext{часто используемый sc-идентификатор}{sc-сервер}
\scnidtf{sc-server}
\scniselement{многократно используемый компонент ostis-систем, хранящийся в виде файлов исходных текстов}
\scniselement{атомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\begin{scnrelfromlist}{используемый язык представления методов}
    \scnitem{C}
    \scnitem{C++}
\end{scnrelfromlist}
\begin{scnrelfromlist}{используемый язык}
    \scnitem{SC-JSON-код}
\end{scnrelfromlist}
\scntext{адрес компонента}{https://github.com/ostis-ai/sc-machine/sc-tools/sc-server}
\begin{scnrelfromset}{зависимости компонента}
    \scnitem{Библиотека программных компонентов для обработки json-текстов JSON for Modern C++}
    \scnitem{Библиотека кросс-платформенных программных компонентов для реализации серверных приложений на основе Websocket WebSocket++}
    \scnitem{Программный компонент настройки программных компонентов ostis-систем версия}
    \scnitem{Реализация sc-памяти}
\end{scnrelfromset}
\end{SCn}

Стоит отметить, что текущая \textit{Реализация Cерверной системы на основе Websocket и JSON, обеспечивающей сетевой доступ к памяти ostis-платформы}, не является первой для текущего \textit{Программного варианта реализации ostis-платформы} и заменяет предыдущую ее реализацию, написанную на языке \textit{Python}. Причина такой замены состоит в следующем:
\begin{textitemize}
    \item Предыдущая \textit{Реализация Cерверной системы на основе Websocket, обеспечивающей доступ к sc-памяти при помощи команд SC-JSON-кода}, реализованная на языке программирования Python, зависит от библиотеки Boost Python, предоставляемой сообществом по развитию и коллаборации языков С++ и Python. Дело в том, что такое решение требует поддержки механизма интерпретации программного кода на Python на язык С++, что является избыточным и необоснованным, поскольку большая часть программного кода \textit{Программного варианта реализации ostis-платформы} реализована на языках С и С++. Новая реализация описываемой программной системы позволяет избавиться от использования емких и ресурсозатратных библиотек (например, boost-python-lib, llvm) и языка Python;
    \item При реализации распределенных подсистем важную роль играет скорость обработки знаний, то есть возможность быстро и своевременно отвечать на запросы пользователя. Качество доступа к sc-памяти посредством реализованной \textit{Подсистемы взаимодействия с sc-памятью на основе языка JSON} должно быть соизмеримо с качеством доступа к sc-памяти при помощи специализированного \textit{программного интерфейса}, реализованного на том же языке программирования, что и сама система. Новая реализация позволяет повысить скорость обработки запросов \textit{Подсистемой взаимодействия с sc-памятью на основе языка JSON}, в том числе и обработки знаний, не менее чем в 1,5 раза по сравнению с предыдущим вариантом реализации этой подсистемы.
\end{textitemize}

\textit{Реализация Серверной системы на основе Websocket и JSON, обеспечивающей сетевой доступ к памяти ostis-платформы}, обладает \myuline{следующими} общими характеристиками:
\begin{textitemize}
    \item Cерверная подсистема имеет такой же специализированный \textit{программный интерфей}с, как и \textit{Реализация sc-памяти}, однако взаимодействие с ней при помощи такого интерфейса осуществляется посредством сети. Это обеспечивает возможность взаимодействия клиентских систем, реализованных на разных языках программирования, с одной общей памятью.
    \item Данную подсистему можно рассматривать как некоторый интерпретатор внешнего языка представления знаний \textit{SC-JSON-код}, на котором могут общаться \textit{ostis-системы}, реализованные на базе \textit{специализированной ostis-платформы}. Каждой команде и ответу на команду этого языка соответствует обработчик (потенциально и вовсе агент), который является частью этого интерпретатора. Сам язык внешнего представления знаний \textit{SC-JSON-код} независим от реализации платформы и используется только как язык внешнего представления знаний, но может быть задействован при реализации других средств и \textit{интерпретаторов sc-моделей ostis-систем}.
    \item Реализованный программный компонент предоставляет многопользовательский асинхронный доступ к sc-памяти. В ходе тестирования \textit{sc-сервера} выяснилось, что его реализация позволяет обрабатывать запросы не менее чем 1000 клиентских систем. В связи с необходимостью обеспечения параллельного доступа к sc-памяти на уровне реализации программного компонента были добавлены блоки синхронизации. Например, в реализации можно заметить очередь команд на обработку системой --- вне зависимости от количества клиентских систем и того, в каком количестве они отправляют команды на обработку, все команды могут становиться в очередь. Такое решение позволяет временно обойти проблемы взаимодействия блоков синхронизации на уровне \textit{sc-памяти} при обработке разных типов команд над ней (поисковых, генеративных, деструктивных и так далее). При этом серверную систему невозможно отключить до тех пор, пока очередь команд имеет какие-нибудь необработанные команды. Также серверная система продолжает работать, если в списке идентификаторов клиентских систем остались неотключенные из них. Необходимость данных функций серверной подсистемы обуславливается необходимостью поддержки атомарности запросов, обрабатываемых системой.
    \item В процессе тестирования подсистемы были получена оценка ее скорости обработки команд и ответов. При нагрузочном тестировании использовалась тестовая клиентская система, написанная на \textit{С++} и не имеющая функционала обработки текстов \textit{SC-JSON-кода}. В результате тестирования было выяснено, что при отправке 1000 различных команд: \textit{команд создания sc-элементов}, \textit{команд обработки содержимого} \textit{файлов ostis-системы} и \textit{команд удаления sc-элементов} --- время, потраченное на их обработку не превышало 0,2 секунды. При этом в отдельных случаях на обработку 1000 \textit{команд создания \textit{sc-элементов}} уходило не более 0,14 секунды, \textit{команд удаления sc-элементов} --- не более 0,07 секунды, \textit{команд обработки содержимого файлов ostis-системы} --- не более 0,27 секунды, \textit{команд поиска sc-конструкций, изоморфных заданному графу-образцу} --- не более 0,45 секунды.
\end{textitemize}

\textit{Реализация Серверной системы на основе Websocket и JSON, обеспечивающей сетевой доступ к памяти ostis-платформы} обеспечивает необходимый и достаточный \textit{программный интерфейс} для взаимодействия c \textit{sc-памятью}. В общем случае ее спецификация включает описание функциональных возможностей не только \textit{Реализации Серверной системы на основе Websocket, обеспечивающей доступ к памяти ostis-платформы}, но и всех клиентских систем взаимодействующих с ней, поскольку зачастую эти клиентские системы включают \textit{специализированный программный интерфейс}, схожий с интерфейсом самой серверной системы, но реализованный на другом \textit{языке программирования}.

\section{Реализация интерпретатора sc-моделей пользовательских интерфейсов}
\label{sec_soft_platform_sci_machine}

\begin{SCn}

\begin{scnrelfromlist}{подраздел}
	\scnitem{\ref{sec_soft_platform_sci_machine_components}~\nameref{sec_soft_platform_sci_machine_components}}
	\scnitem{\ref{sec_soft_platform_sci_machine_problems}~\nameref{sec_soft_platform_sci_machine_problems}}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Реализация интерпретатора sc-моделей пользовательских интерфейсов}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевое знание}
	\scnitem{Спецификация Реализации интерпретатора sc-моделей пользовательских интерфейсов}
	\scnitem{Принципы, лежащие в основе Реализации интерпретатора sc-моделей пользовательских интерфейсов}
\end{scnrelfromlist}

\end{SCn}

В большинстве случаев разработка \textit{пользовательского интерфейса} в современных системах отнимает большую часть времени, затрачиваемого на разработку всей системы. Однако эффективность использования \textit{программной компьютерной системы} зависит от разрабатываемого \textit{пользовательского интерфейса} (см. \scncite{Myers1992}, \textit{Главу \ref{chapter_interfaces}~\nameref{chapter_interfaces}}).

Наряду с \textit{Реализацией sc-памяти} важной частью \textit{Программного варианта реализации ostis-платформы} является \textbf{\textit{Реализация интерпретатора sc-моделей пользовательских интерфейсов}}, которая предоставляет базовые средства просмотра и редактирования базы знаний пользователем, средства для навигации по \textit{базе знаний} (задания \textit{вопросов} к \textit{базе знаний}) и может дополняться новыми компонентами в зависимости от задач, решаемых каждой конкретной \textit{ostis-системой}.

\begin{SCn}
\scnheader{Реализация интерпретатора sc-моделей пользовательских интерфейсов}
\scnidtf{Предлагаемый нами интерпретатор для интерпретации sc-моделей пользовательских интерфейсов ostis-систем}
\scniselement{многократно используемый компонент ostis-систем, хранящийся в виде файлов исходных текстов}
\scniselement{неатомарный многократно используемый компонент ostis-систем}
\scniselement{зависимый многократно используемый компонент ostis-систем}
\begin{scnrelfromlist}{используемый язык представления методов}
	\scnitem{JavaScript}
	\scnitem{TypeScript}
	\scnitem{Python}
	\scnitem{HTML}
	\scnitem{CSS}
\end{scnrelfromlist}
\scntext{адрес компонента}{https://github.com/ostis-ai/sc-web}
\begin{scnrelfromset}{зависимости компонента}
	\scnitem{Библиотека стандартных интерфейсных компонентов на языке программирования JavaScript}
	\scnitem{Библиотека для реализации серверных приложений на языке программирования Python Tornado}
	\scnitem{Реализация клиентской системы на языке программирования TypeScript}
	\scnitem{Реализация клиентской системы на языке программирования Python}
\end{scnrelfromset}
\end{SCn}

Важным принципом \textit{Реализации интерпретатора sc-моделей пользовательских интерфейсов} является простота и однотипность подключения любых компонентов \textit{пользовательского интерфейса} (\textit{редакторов}, \textit{визуализаторов}, \textit{переключателей}, \textit{команд меню} и так далее). Для этого реализуется программная прослойка Sandbox, в рамках которой реализуются низкоуровневые операции взаимодействия с серверной частью и которая обеспечивает более удобный \textit{программный интерфейс} для разработчиков компонентов. Текущий вариант \textit{Реализации интерпретатора sc-моделей пользовательских интерфейсов} является открытым и доступен на \scncite{Ostis-sc-web2023}.

\subsection{Основные компоненты Реализации интерпретатора sc-моделей пользовательских интерфейсов}
\label{sec_soft_platform_sci_machine_components}

\begin{SCn}

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Панель меню команд пользовательского интерфейса}
	\scnitem{Компонент переключения языка идентификации отображаемых sc-элементов}
	\scnitem{Компонент переключения внешнего языка визуализации знаний}
	\scnitem{Поле поиска sc-элементов по идентификатору}
	\scnitem{Панель отображения диалога пользователя с ostis-системой}
	\scnitem{Панель визуализации и редактирования знаний}
	\scnitem{Визуализатор sc.n-текстов}
	\scnitem{Визуализатор и редактор sc.g-текстов}
\end{scnrelfromlist}
	
\end{SCn}

\begin{SCn}
\scnheader{Реализация интерпретатора sc-моделей пользовательских интерфейсов}
\begin{scnrelfromset}{декомпозиция программной системы}
	\scnitem{Панель меню команд пользовательского интерфейса}
	\scnitem{Компонент переключения языка идентификации отображаемых sc-элементов}
	\scnitem{Компонент переключения внешнего языка визуализации знаний}
	\scnitem{Поле поиска sc-элементов по идентификатору}
	\scnitem{Панель отображения диалога пользователя с ostis-системой}
	\scnitem{Панель визуализации и редактирования знаний}
	\begin{scnindent}
		\begin{scnrelfromset}{декомпозиция программной системы}
			\scnitem{Визуализатор sc.n-текстов}
			\scnitem{Визуализатор и редактор sc.g-текстов}
		\end{scnrelfromset}
	\end{scnindent}
\end{scnrelfromset}
\end{SCn}

\textbf{\textit{Компонент переключения языка идентификации отображаемых sc-элементов}} является изображением множества имеющихся в системе \textit{естественных языков}. Взаимодействие пользователя с данным компонентом переключает \textit{пользовательский интерфейс} в режим общения с конкретным пользователем с использованием \textit{основных sc-идентификаторов}, принадлежащих данному \textit{естественному языку}. Это значит, что при изображении \textit{sc-идентификаторов} \textit{sc-элементов} на каком-либо языке, например, \textit{SCg-коде} или \textit{SCn-коде} будут использоваться \textit{основные sc-идентификаторы}, принадлежащие данному \textit{естественному языку}. Это касается как \textit{sc-элементов}, отображаемых в рамках \textit{Панели визуализации и редактирования знаний}, так и любых других sc-элементов, например, классов команд и даже самих \textit{естественных языков}, изображаемых в рамках самого \textit{Компонента переключения языка идентификации отображаемых sc-элементов}.

\textbf{\textit{Компонент переключения внешнего языка визуализации знаний}} служит для переключения языка визуализации знаний в текущем окне, отображаемом на \textbf{\textit{Панели визуализации и редактирования знаний}}. В текущей реализации в качестве таких языков по умолчанию поддерживаются \textit{SCg-код} и \textit{SCn-код}, а также любые другие языки, входящие во множество \textit{внешних языков визуализации SC-кода}.

\textbf{\textit{Поле поиска sc-элементов по идентификатору}} позволяет осуществлять поиск \mbox{sc-идентификаторов}, содержащих подстроку, введенную в данное поле (с учетом регистра). В результате поиска отображается список \textit{sc-идентификаторов}, содержащих указанную подстроку, при взаимодействии с которыми осуществляется автоматическое задание вопроса \scnqqi{Что это такое?}, аргументом которого является либо сам \textit{sc-элемент}, имеющий данный \textit{sc-идентификатор} (в случае, если указанный \textit{sc-идентификатор} является основным или системным, и, таким образом, указанный \textit{sc-элемент} может быть определен однозначно), либо внутренний файл \textit{ostis-системы}, являющийся \textit{sc-идентификатором} (в случае, если данный sc-идентификатор является неосновным).

\textbf{\textit{Панель отображения диалога пользователя с ostis-системой}} отображает упорядоченный по времени список \textit{sc-элементов}, являющихся знаками действий, которые инициировал \textit{пользователь} в рамках диалога с \textit{ostis-системой} путем взаимодействия с изображениями соответствующих классов \textit{команд} (то есть, если действие было инициировано другим способом, например, путем его явного инициирования через создание дуги принадлежности множеству \textit{инициированных действий} в \textit{sc.g-редакторе}, то на данной панели оно отображено не будет). При взаимодействии \textit{пользователя} с любым из изображенных знаков действий на \textit{Панели визуализации и редактирования знаний} отображается окно, содержащее результат выполнения данного \textit{действия} на том языке визуализации, на котором он был отображен, когда \textit{пользователь} просматривал его в последний (предыдущий) раз. Таким образом, в текущей реализации данная \textit{панель} может работать только в том случае, если инициированное \textit{пользователем} действие предполагает явно представленный в памяти результат данного действия. В свою очередь, из этого следует, что в настоящее время данная панель, как и в целом \textit{Реализация интерпретатора sc-моделей пользовательских интерфейсов}, позволяет работать с системой только в режиме диалога \scnqqi{вопрос-ответ}.

\textbf{\textit{Панель визуализации и редактирования знаний}} отображает окна, содержащие sc-текст, представленный на некотором языке из множества \textit{внешних языков визуализации SC-кода} и, как правило, являющийся результатом некоторого действия, инициированного \textit{пользователем}. Если соответствующий визуализатор поддерживает возможность редактирования текстов соответствующего \textit{естественного языка}, то он одновременно является также и редактором. При необходимости \textit{пользовательский интерфейс} каждой конкретной \textit{ostis-системы} может быть дополнен \textit{визуализаторами} и \textit{редакторами} различных \textit{внешних языков}, которые в текущей версии \textit{Реализации интерпретатора sc-моделей пользовательских интерфейсов} будут также располагаться на \textit{Панели визуализации и редактирования знаний}. По умолчанию доступны две панели визуализации и редактирования: \textit{Визуализатор sc.n-текстов} и \textit{Визулизатор и редактор sc.g-текстов}.

\textbf{\textit{Панель меню команд пользовательского интерфейса}} содержит изображения классов команд (как атомарных, так и неатомарных), имеющихся на данный момент в базе знаний и входящих в декомпозицию \textit{Главного меню пользовательского интерфейса} (имеется в виду полная декомпозиция, которая в общем случае может включать несколько уровней \textit{неатомарных классов команд}). Взаимодействие с изображением неатомарного класса команд инициирует команду изображения \textit{классов} \textit{команд}, входящих в декомпозицию данного \textit{неатомарного класса команд}. Взаимодействие с изображением \textit{атомарного класса команд} инициирует генерацию команды данного класса с ранее выбранными аргументами на основе соответствующей \textit{обобщенной формулировки класса команд} (шаблона класса команд).

Семантические модели описанных компонентов \textit{пользовательского интерфейса} более подробно представлены в работах \scncite{Koronchik2011}, \scncite{Koronchik2012}, \scncite{Koronchik2013}, \scncite{Koronchik2014} и \scncite{Sadouski2022}.

\subsection{Достоинства и недостатки текущего варианта Реализации интерпретатора sc-моделей пользовательских интерфейсов}
\label{sec_soft_platform_sci_machine_problems}

Текущая \textit{Реализация интерпретатора sc-моделей пользовательских интерфейсов} имеет большое множество недостатков, а именно:
\begin{textitemize}
	\item Идея платформенной независимости \textit{пользовательского интерфейса} (построения \textit{sc-модели пользовательского интерфейса}) реализована не в полной мере. Полностью описать \textit{sc-модель пользовательского интерфейса} (включая точное размещение, размеры, дизайн компонентов, их поведение и другое) в настоящее время скорее всего окажется затруднительно из-за ограничений производительности, однако вполне возможно реализовать возможность задания вопросов ко всем компонентам интерфейса, изменить их расположение и так далее, однако эти возможности нельзя реализовать в текущем \textit{Программном варианте реализации ostis-платформы}.
	\item Кроме того, часть интерфейса фактически работает напрямую с sc-памятью с использованием технологии \textit{WebSocket}, а часть --- через прослойку на базе \textit{Библиотеки} \textit{tornado} для \textit{языка программирования} \textit{Python}, что приводит к дополнительным зависимостям от сторонних библиотек. В последнее время развития текущего \textit{Программного варианта реализации ostis-платформы} данная проблема в большей мере была решена, однако все еще остались компоненты, реализуемые на \textit{Python}.
	\item Часть компонентов (например, \textit{поле поиска по идентификатору}) реализована сторонними средствами и практически никак не связана с sc-памятью. Это затрудняет развитие \textit{Реализации интерпретатора sc-моделей пользовательских интерфейсов} ориентирована только на ведение диалога с \textit{пользователем} (в стиле вопрос пользователя --- ответ системы). Не поддерживаются такие очевидно необходимые ситуации, как выполнение команды, не предполагающей ответа; возникновение ошибки или отсутствие ответа; необходимость задания вопроса системой пользователю и так далее.
	\item Ограничена возможность взаимодействия пользователя с системой без использования специальных \textit{элементов управления}. Например, можно задать вопрос системе, нарисовав его в \textit{SCg-коде}, но ответ пользователь не увидит, хотя в памяти он будет сформирован соответствующим агентом. Большая часть технологий, использованных при реализации платформы, к настоящему моменту устарела, что затрудняет развитие \textit{ostis-платформы}.
	\item Не реализован механизм наследования при добавлении новых внешних языков. Например, добавление нового языка даже очень близкого к \textit{SCg-коду} требует физического копирования кода компонента и внесение соответствующих изменений, при этом получаются два никак не связанных между собой компонента, которые начинают развиваться независимо друг от друга.
	\item Слабый уровень задокументированности текущей \textit{Реализации интерпретатора sc-моделей пользовательских интерфейсов}. Представленная текущая спецификация пока только описывает ключевые моменты \textit{Реализации интерпретатора sc-моделей пользовательских интерфейсов}, но не раскрывает их.
\end{textitemize}

На основе описанных недостатков к будущей реализации предъявляются следующие требования:
\begin{textitemize}
	\item Унифицировать принципы взаимодействия всех компонентов интерфейса с \textit{Реализации sc-памяти в ostis-платформе}, независимо от того, к какому типу относится компонент. Например, список команд меню должен формироваться через тот же механизм, что и ответ на \textit{запрос пользователя}, и \textit{команда редактирования}, сформированная пользователем, и \textit{команда добавления нового фрагмента в базу знаний} и так далее. Необходимо совершенствовать способы использования интерфейса для удобного и комфортного пользования.
	\item Унифицировать принципы взаимодействия \textit{пользователей} с системой независимо от способа взаимодействия и \textit{внешнего языка}. Например, должна быть возможность задания вопросов и выполнения других команд прямо через SCg/SCn интерфейс. При этом необходимо учитывать принципы редактирования базы знаний, чтобы пользователь не мог под видом задания вопроса внести новую информацию в \textit{согласованную часть базы знаний}.
	\item Унифицировать принципы обработки \textit{событий}, происходящих при взаимодействии пользователя с компонентами интерфейса --- поведение кнопок и других интерактивных компонентов должно задаваться не статически сторонними средствами, а реализовываться в виде агента, который, тем не менее, может быть реализован произвольным образом (не обязательно на \textit{платформенно-независимом} уровне). Любое \textit{действие}, совершаемое \textit{пользователем}, на логическом уровне должно трактоваться и обрабатываться как инициирование \textit{агента}.
	\item Обеспечить возможность выполнять команды (в частности, задавать вопросы) с произвольным количеством аргументов, в том числе --- без аргументов.
	\item Обеспечить возможность отображения ответа на вопрос по частям, если ответ очень большой и для отображения требуется много времени.
	\item Каждый отображаемый компонент интерфейса должен трактоваться как изображение некоторого \textit{sc-узла}, описанного в \textit{базе знаний}. Таким образом, пользователь должен иметь возможность задания произвольных вопросов к любым компонентам интерфейса.
	\item Максимально упростить и задокументировать механизм добавления новых компонентов.
	\item Обеспечить возможность добавления новых компонентов на основе имеющихся без создания независимых копий. Например, должна быть возможность создать компонент для языка, расширяющего \textit{SCg-код} новыми примитивами, переопределять принципы размещения \textit{sc-текстов} и так далее.
	\item Свести к минимуму зависимость от сторонних библиотек.
	\item Свести к минимуму использование протокола \textit{HTTP} (начальная загрузка общей структуры интерфейса), обеспечить возможность равноправного двустороннего взаимодействия серверной и клиентской части.
\end{textitemize}

Очевидно, что реализация большинства из приведенных требований связана не только с собственно вариантом реализации ostis-платформы, но и требует развития теории \textit{sc-моделей пользовательских интерфейсов} и уточнения в рамках нее общих принципов организации \textit{пользовательских интерфейсов ostis-систем}.

\section*{Заключение к Главе \ref{chapter_soft_platform}}
\label{sec_soft_platform_plans_and_tasks}

В дальнейшем развитии \textit{Программного варианта реализации ostis-платформы} важным и правильным будет:
\begin{textitemize}
    \item максимально детализировать спецификацию компонентов проектируемой \textit{ostis-платформы}, в том числе используемых языков внешнего и внутреннего представления знаний, и четко стратифицировать иерархию классов и отношений, используемых при описании компонентов ostis-платформ;
    \item устранить и учесть недостатки при реализации новых компонентов в проектируемой ostis-платформе, указать возможные варианты их реализации;
    \item свести зависимость компонентов ostis-платформы от ее реализации к минимуму, то есть, по возможности, реализовать их на \textit{Языке SCP} (например, \textit{интерпретатор sc-моделей пользовательских интерфейсов ostis-систем});
    \item оценить качество проектируемой системы и ее компонентов в целом.
\end{textitemize}

Кратко перечислим основные положения Главы~\ref{chapter_soft_platform}:
\begin{textitemize}
	\item Текущий \textit{Программный вариант реализации ostis-платформы} является \myuline{кроссплатформенным}, что позволяет:
	\begin{textitemize}
		\item вести разработку и поддерживать состояние ее компонентов вне зависимости от реализации платформ, на которых используются средства их проектирования и разработки,
		\item использовать ее для решения задач на любых доступных устройствах.
	\end{textitemize}
	\item Текущий \textit{Программный вариант реализации ostis-платформы} является \myuline{многопользовательским}, то есть позволяет обрабатывать несколько действий одновременно.
	\item Текущая \textit{Реализация памяти ostis-платформы} является \myuline{достаточно полной} для того, чтобы:
		\begin{textitemize}
		\item взаимно однозначно интерпретировать sc-модели ostis-систем, в том числе внешние информационные конструкции, не принадлежащие SC-коду;
		\item разрабатывать платформенно-зависимые компоненты, требующие доступа к sc-памяти (например, \textit{Программный интерфейс Реализации sc-памяти в данной ostis-платформе}).
	\end{textitemize}
	\item Текущий \textit{Программный вариант реализации ostis-платформы} является \myuline{специализированным}, то есть позволяет создавать только платформенно-зависимые ostis-системы.
	\item На базе текущего \textit{Программного варианта реализации ostis-платформы} реализуются \textit{интерпретатор sc-моделей пользовательских интерфейсов ostis-систем}, \textit{интерпретатор логических моделей решения задач в ostis-системах}, а также \textit{менеджер многократно используемых компонентов ostis-систем}.
\end{textitemize}