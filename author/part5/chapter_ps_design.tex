\chapauthor{Шункевич Д.В.\\Марковец В.С.}
\chapter{Методика и средства компонентного проектирования решателей задач ostis-систем}
\chapauthortoc{Шункевич Д.В.\\Марковец В.С.}
\label{chapter_ps_design}

\abstract{Аннотация к главе.}

В области разработки \textit{решателей задач} существует большое количество конкретных реализаций, однако вопросы совместимости различных решателей при решении одной задачи практически не рассматриваются. Гипотетически возможно существование универсального решателя задач, объединяющего в себе все известные способы и методы решения задач. Однако использование такого решателя в прикладных целях не является целесообразным. Таким образом, наиболее приемлемым вариантом становится создание библиотеки совместимых между собой компонентов, из которых впоследствии может быть скомпилирован решатель, удовлетворяющий необходимым требованиям.

\section{Действия и методики проектирования решателей задач ostis-систем}

Методика построения и модификации решателей задач включает несколько этапов. 
\begin{textitemize}
    \item формирование требований и спецификация решателя задач;
    \item формирование коллектива sc-агентов, входящих в состав разрабатываемого решателя;
    \item разработка алгоритмов атомарных sc-агентов;
    \item реализация scp-программ;
    \item верификация разработанных компонентов;
    \item отладка разработанных компонентов, исправление ошибок.
\end{textitemize}

Методика может быть применена как при разработке объединенных решателей, так и при разработке решателей частного вида, поскольку с формальной точки зрения все они трактуются как неатомарный абстрактный sc-агент.

\textbf{Этап 1. Формирование требований и спецификация  решателя задач}

На данном этапе необходимо:
\begin{textitemize}
\item четко выделить задачи, решение которых должен обеспечивать решатель задач;
\item продумать предполагаемые способы их решения и на основе данного анализа определить место будущего решателя в общей иерархии решателей.
\end{textitemize}

Важность данного этапа заключается в том, что при правильной классификации существует вероятность того, что в составе библиотеки многократно используемых компонентов ostis-систем уже есть реализованный вариант требуемого решателя. В противном случае, у разработчика появляется возможность включить разработанный решатель в библиотеку многократно используемых компонентов ostis-систем для последующего использования. Данные факты обусловлены тем, что структура библиотеки многократно используемых компонентов решателей задач основана на семантической классификации таких решателей и, соответственно, их компонентов.

При недостаточно четкой спецификации и классификации разрабатываемого решателя повышается вероятность того, что подходящий решатель не будет найден в библиотеке компонентов даже в случае, если он там есть, а вновь разработанный решатель не сможет быть включен в библиотеку. Таким образом, идея многократного использования уже разработанных компонентов будет нарушена, что существенно повысит затраты на разработку такого решателя.

\textbf{Этап 2. Формирование коллектива sc-агентов, входящих в состав разрабатываемого решателя}

В случае, когда найти в библиотеке готовый решатель, удовлетворяющий всем предъявляемым требованиям, не представляется возможным, необходимо выделить и специфицировать все компоненты такого решателя.

Результатом данного этапа является перечень полностью специфицированных \textit{sc-агентов}, которые войдут в состав разрабатываемого решателя, с их иерархией вплоть до \textit{атомарных sc-агентов}. В рамках данного этапа очень важно проектировать коллектив агентов таким образом, чтобы максимально задействовать уже имеющиеся в библиотеке многократно используемые компоненты ostis-систем, а при отсутствии нужного компонента –- иметь возможность включить его в библиотеку после реализации.

При разработке перечня агентов (в том числе их спецификаций) необходимо соблюдать ряд принципов:

\begin{textitemize}
\item каждый разрабатываемый sc-агент должен быть по возможности предметно независим, т. е. во множество ключевых узлов данного sc-агента не должны входить понятия, имеющие отношение непосредственно к рассматриваемой предметной области. Исключение составляют понятия из общих предметных областей, которые носят междисциплинарный характер (например, отношение \textit{включение*} или понятие \textit{действие}). Данное правило также может быть нарушено в случае, если sc-агент является вспомогательным и ориентирован на обработку какого-либо конкретного класса объектов (например, sc-агенты, выполняющие арифметические вычисления, могут напрямую работать с конкретными отношениями \textit{сложение*} и \textit{умножение*} и т. п.). Всю необходимую для решения задачи информацию sc-агент должен извлекать из семантической окрестности соответствующего инициированного действия. Очевидно, что sc-агент, разработанный с учетом указанных требований, может быть использован при проектировании большего числа ostis-систем, чем в случае, если бы он был реализован с ориентацией на конкретную частную предметную область. После завершения разработки и отладки такой sc-агент должен быть включен в \textit{библиотеку многократно используемых абстрактных sc-агентов}, которая входит в состав \textit{библиотеки многкратно используемых компонентов решателей задач};
\item не стоит путать понятия sc-агент и агентная программа (в том числе агентная scp-программа). Взаимодействие sc-агентов осуществляется исключительно посредством спецификации информационных процессов в общей памяти, каждый sc-агент реагирует на некоторый класс событий в sc-памяти. Таким образом, каждому sc-агенту соответствует некоторое условие инициирования и одна агентная программа, которая запускается автоматически при возникновении в sc-памяти соответствующего условия инициирования. При этом в рамках данной программы могут сколько угодно раз вызываться различные подпрограммы. Однако не стоит путать инициирование sc-агента, которое осуществляется при появлении в sc-памяти соответствующей конструкции, и вызов подпрограммы другой программой, который предполагает явное указание вызываемой подпрограммы и перечня ее параметров;
\item каждый sc-агент должен самостоятельно проверять полноту соответствия своего условия инициирования текущему состоянию sc-памяти. В процессе решения какой-либо задачи может возникнуть ситуация, когда на появление одной и той же структуры среагировали несколько sc-агентов. В таком случае выполнение продолжают только те из них, условие инициирования которых полностью соответствует сложившейся ситуации. Остальные sc-агенты в данном случае прекращают выполнение и возвращаются в режим ожидания. Выполнение данного принципа достигается за счет тщательного уточнения спецификаций разрабатываемых sc-агентов. В общем случае условия инициирования у нескольких sc-агентов могут совпадать, например, в случае, когда одна и та же задача может быть решена разными способами и заранее неизвестно, какой из них приведет к желаемому результату;
% нужен наглядный пример
\item необходимо помнить, что неатомарный sc-агент с точки зрения других sc-агентов, не входящих в его состав, должен функционировать как целостный sc-агент (выполнять логически атомарные действия), что накладывает определенные требования на спецификации атомарных sc-агентов, входящих в его состав: как минимум, необходимо, чтобы в составе неатомарного sc-агента присутствовал хотя бы один атомарный sc-агент, условие инициирования которого полностью совпадает с условием инициирования данного неатомарного sc-агента;
\item при необходимости реализации нового sc-агента следует руководствоваться следующими принципами выделения атомарных абстрактных \textit{sc-агентов}:

\begin{textitemize}
    \item проектируемый sc-агент должен быть максимально независим от предметной области, что позволит в дальшейшем использовать его при разработке решателей максимально возможного числа ostis-систем. При этом универсальность предполагает не только минимизацию числа ключевых узлов sc-агента, но и выделение класса действий, выполняемых данным sc-агентом таким образом, чтобы имело смысл включить данный sc-агент в \textit{библиотеку многократно используемых абстрактных sc-агентов} и использовать его при разработке решателей других ostis-систем. Не следует искусственно увязывать ряд действий в один sc-агент и, наоборот, расчленять одно самодостаточное действие на поддействия: это вызовет сложности восприятия принципов работы sc-агента разработчиками и не позволит использовать sc-агент в ряде систем (например, в обучающих системах, которые должны объяснять ход решения пользователю);
    \item выполняемое данным sc-агентом действие должно быть логически целостным и завершенным. Следует помнить, что все sc-агенты взаимодействуют исключительно через общую sc-память и избегать ситуаций, в которых инициирование одного sc-агента осуществляется путем явной генерации известного условия инициирования другим \textit{sc-агентом} (т. е., по сути, явным непосредственным вызовом одного sc-агента другим);
    \item имеет смысл выделять в отдельные sc-агенты относительно крупные фрагменты реализации некоторого общего алгоритма, которые могут выполняться независимо друг от друга.
\end{textitemize}

\item при объединении sc-агентов в коллективы рекомендуется проектировать их таким образом, чтобы они могли быть использованы не только как часть рассматриваемого неатомарного абстрактного sc-агента. В случае, если это не представляется возможным и некоторые sc-агенты, будучи отделенными от коллектива, теряют смысл, необходимо указать данный факт при документировании рассматриваемых sc-агентов;
\item фактическим инициатором запуска sc-агента посредством общей памяти (автором соответствующей конструкции) может быть как непосредственно пользователь системы, так и другой sc-агент, что никак не должно отражаться в работе самого sc-агента.
\end{textitemize}

\textbf{Этап 3. Разработка алгоритмов атомарных sc-агентов}

В рамках данного этапа необходимо продумать алгоритм работы каждого разрабатываемого \textit{атомарного sc-агента}. Разработка алгоритма подразумевает выделение в нем логически целостных фрагментов, которые могут быть реализованы как отдельные \textit{scp-программы}, в том числе выполняемые параллельно. Таким образом, появляется необходимость говорить не только о \textit{библиотеке многократно используемых абстрактных sc-агентов}, но и о \textit{библиотеке многократно используемых программ обработки sc-текстов} на различных языках программирования, в том числе \textit{библиотеке многократно используемых scp-программ}. Благодаря этому часть scp-программ, реализующих алгоритм работы некоторого sc-агента, может быть заимствована из соответствующей библиотеки.

Важно помнить, что если в процессе работы \textit{sc-агент} генерирует в памяти какие-либо временные структуры, то при завершении работы он обязан удалять всю информацию, использование которой в системе более нецелесообразно (убрать за собой информационный мусор). Исключение составляют ситуации, когда подобная информация необходима нескольким \textit{sc-агентам} для решения одной задачи, однако после решения задачи информация становится бесполезной или избыточной и требует удаления. В данном случае может возникнуть ситуация, когда ни один из \textit{sc-агентов} не в состоянии удалить информационный мусор. В таком случае возникает необходимость говорить о включении в состав решателя специализированных \textit{sc-агентов}, задачей которых является выявление и уничтожение информационного мусора.

\textbf{Этап 4. Реализация scp-программ}

Конечным этапом непосредственно разработки является реализация специфицированных ранее \textit{scp-программ} или при необходимости программ, реализуемых на уровне платформы.

\textbf{Этап 5. Верификация разработанных компонентов}

Верификация разработанных компонентов может осуществляться как вручную, так и с использованием специфицированных средств, входящих в состав системы автоматизации проектирования решателей задач ostis-систем.

\textbf{Этап 6. Отладка разработанных компонентов. Исправление ошибок}
Этап отладки разработанных компонентов, в свою очередь, можно также условно разделить на более частные этапы:

\begin{textitemize}
    \item отладка отдельных scp-программ или программ, реализуемых на уровне платформы;
    \item отладка отдельных атомарных sc-агентов;
    \item отладка неатомарных sc-агентов, входящих в состав решателя задач;
    \item отладка всего решателя задач.
\end{textitemize}

\textbf{Этап 5} и \textbf{Этап 6} могут выполняться параллельно и повторяются до тех пор, пока разработанные компоненты не будут удовлетворять необходимым требованиям.

Методика построения и модификации решателей задач основана на онтологии деятельности разработчиков таких решателей.
% поправить исходя из того, что решатель задач не агент, а совокупность навыков
Решатель задач представляет собой \textit{абстрактный sc-агент}, в связи с чем разработка решателя сводится к разработке такого агента.

Фрагмент онтологии деятельности, направленной на построение и модификацию решателей задач:
\begin{SCn}
\scnheader{действие. разработать решатель задач ostis-системы}
\scneq{действие. разработать абстрактный sc-агент}
\begin{scnreltoset}{разбиение}
\scnitem{действие. разработать атомарный абстрактный sc-агент}
\begin{scnindent}
    \begin{scnrelfrom}{включение} 
        {действие. разработать платформенно-независимый атомарный абстрактный sc-агент}
    \end{scnrelfrom}
\end{scnindent}
\scnitem{действие. разработать неатомарный абстрактный sc-агент}
\end{scnreltoset}
\begin{scnrelfromlist}{абстрактное поддействие}
    \scnitem{действие. специфицировать абстрактный sc-агент}
    \scnitem{действие. найти в библиотеке абстрактный sc-агент, удовлетворяющий заданной спецификации}
    \scnitem{действие. верифицировать sc-агент}
    \scnitem{действие. отладить sc-агент}
\end{scnrelfromlist}

\scnheader{действие. разработать платформенно-независимый атомарный абстрактный sc-агент}
\begin{scnrelfromlist}{абстрактное поддействие}
    \scnitem{действие. декомпозировать платформенно-независимый атомарный абстрактный sc-агент на scp-программы}
    \scnitem{действие. разработать scp-программу}
\end{scnrelfromlist}

\scnheader{действие. разработать неатомарный абстрактный sc-агент}
\begin{scnrelfromlist}{абстрактное поддействие}
    \scnitem{действие. декомпозировать неатомарный абстрактный sc-агент на более частные}
    \scnitem{действие. разработать абстрактный sc-агент}
\end{scnrelfromlist}

\scnheader{действие. разработать scp-программу}
\begin{scnrelfromlist}{абстрактное поддействие}
    \scnitem{действие. специфицировать scp-программу}
    \scnitem{действие. найти в библиотеке scp-программу, удовлетворяющую заданной спецификации}
    \scnitem{действие. реализовать специфицированную scp-программу}
    \scnitem{действие. верифицировать scp-программу}
    \scnitem{действие. отладить scp-программу}
\end{scnrelfromlist}

\scnheader{действие. верифицировать sc-агент}
\begin{scnreltoset}{разбиение}
    \scnitem{действие. верифицировать атомарный sc-агент}
    \scnitem{действие. верифицировать неатомарный sc-агент}
\end{scnreltoset}

\scnheader{действие. отладить sc-агент}
\begin{scnreltoset}{разбиение}
    \scnitem{действие. отладить атомарный sc-агент}
    \scnitem{действие. отладить неатомарный sc-агент}
\end{scnreltoset}
\end{SCn}

Наличие такой онтологии позволяет:
\begin{textitemize}
    \item частично автоматизировать процесс построения и модификации решателей;
    \item повысить эффективность информационной поддержки разработчиков, поскольку данная онтология может быть включена в базу знаний Метасистемы OSTIS.
\end{textitemize}

\section{Логико-семантическая модель комплекса ostis-систем автоматизации проектирования решателей задач ostis-систем}

К числу задач системы автоматизации проектирования решателей задач ostis-систем относится техническая поддержка разработчиков решателей, в том числе -- обеспечение корректного и эффективного выполнения этапов, предусмотренных методикой проектирования решателей задач ostis-систем.

При разработке любых компонентов ostis-систем используются схожие принципы. Одним из основных принципов является принцип использования готовых компонентов различного рода, уже имеющихся в библиотеке многократно используемых компонентов ostis-систем, входящей в состав Метасистемы OSTIS.

Система автоматизации проектирования решателей задач сама по себе также является ostis-системой и имеет соответствующую структуру. Таким образом, модель данной системы включает sc-модель базы знаний, sc-модель объединенного решателя задач и sc-модель пользовательского интерфейса.

В рамках системы условно выделяются две подсистемы -- подсистема автоматизации проектирования агентов обработки знаний и подсистема автоматизации проектирования scp-программ.

Cистема может использоваться тремя способами:
\begin{textitemize}
    \item Как подсистема в рамках Метасистемы OSTIS. Данный вариант использования предполагает отладку необходимых компонентов в рамках метасистемы с последующим переносом их в дочернюю ostis-систему.
    \item Как самостоятельная ostis-система, предназначенная исключительно для разработки и отладки компонентов решателей задач. В этом случае проектируемые компоненты отлаживаются в рамках такой системы, а затем должны быть перенесены в дочернюю ostis-систему.
    \item Как подсистема в рамках дочерней ostis-системы. В таком варианте отладка компонентов осуществляется непосредственно в той же системе, в которой предполагается их использование, и дополнительного переноса не требуется.
\end{textitemize}

Независимо от выбранного способа использования системы, разработанные компоненты впоследствии могут быть включены в состав библиотеки многократно используемых компонентов ostis-систем.

Выделяются два принципиально разных уровня отладки решателя задач:
\begin{textitemize}
    \item отладка на уровне sc-агентов;
    \item отладка на уровне scp-программ.
\end{textitemize}

В случае отладки на уровне sc-агентов акт выполнения каждого агента считается неделимым и не может быть прерван. При этом может выполняться отладка как атомарных sc-агентов, так и неатомарных. Инициирование того или иного агента, в том числе входящего в состав неатомарного, осуществляется путем создания соответствующих конструкций в sc-памяти, таким образом, отладка может осуществляться на разных уровнях детализации агентов, вплоть до атомарных.

Система поддержки проектирования агентов может служить основой для моделирования систем агентов, использующих другие принципы коммуникации, например, непосредственный обмен сообщениями между агентами.

Отладка на уровне scp-программ осуществляется аналогично существующим современным подходам к отладке процедурных программ и предполагает возможность установки точек останова, пошагового выполнения программы и т. д.

Система автоматизации проектирования решателей задач и, соответственно, ее sc-модель, разделяется на две более частные:

\begin{SCn}
\scnheader{Система автоматизации проектирования решателей задач ostis-систем}
\begin{scnreltoset}{базовая декомпозиция}
\scnitem{Система автоматизации проектирования агентов обработки знаний}
\begin{scnindent}
    \begin{scnreltoset}{базовая декомпозиция}
        \scnitem{База знаний системы автоматизации проектирования агентов обработки знаний}
        \scnitem{Решатель задач системы автоматизации проектирования агентов обработки знаний}
        \scnitem{Пользовательский интерфейс системы автоматизации проектирования агентов обработки знаний}
    \end{scnreltoset}
\end{scnindent}
\scnitem{Система автоматизации проектирования scp-программ}
\begin{scnindent}
    \begin{scnreltoset}{базовая декомпозиция}
        \scnitem{База знаний системы автоматизации проектирования scp-программ}
        \scnitem{Решатель задач системы автоматизации проектирования scp-программ}
        \scnitem{Пользовательский интерфейс системы автоматизации проектирования scp-программ}
    \end{scnreltoset}
\end{scnindent}
\end{scnreltoset}
\end{SCn}

\subsection{Семантическая модель базы знаний системы автоматизации проектирования решателей задач ostis-систем}

База знаний системы автоматизации проектирования решателей задач ostis-систем включает в себя кроме Ядра и предметной области Базового языка программирования ostis-систем также описание ключевых понятий, связанных с верификацией и отладкой scp-программ.

Основные понятия, специфичные для базы знаний системы автоматизации проектирования scp-программ.
\begin{SCn}
\scnheader{точка останова*}
\scniselement{квазибинарное отношение}
\end{SCn}

Связки отношения \textit{точки останова*} связывают \textit{scp-программу} с некоторым множеством sc-переменных, соответствующих \textit{scp-операторам} в рамках этой программы. При генерации каждого \textit{scp-процесса}, соответствующего этой \textit{scp-программе}, все \textit{scp-операторы}, соответствующие таким переменным, будут добавлены во множество \textit{точка останова}, т. е. выполнение данного scp-процесса будет прерываться при достижении каждого из этих \textit{scp-операторов}.
Использование данного отношения приводит к указанию точек останова для всех \textit{scp-процессов}, формируемых на основе заданной \textit{\mbox{scp-программы}}. Для указания точки останова в рамках отдельно взятого \textit{scp-процесса} нужный scp-оператор явно включается во множество \textit{точка останова}.

\begin{SCn}
\scnheader{точка останова}
\scnrelto{включение}{scp-оператор}
\end{SCn}

Во множество \textit{точка останова} входят все \textit{scp-операторы}, являющиеся точками останова в рамках какого-либо \textit{scp-процесса}. Это означает, что в момент, когда в соответствии с переходами между \textit{scp-операторами} по связкам отношения \textit{последовательность действий*} указанный \textit{scp-оператор} должен стать \textit{активным действием}, он становится \textit{отложенным действием}, и, соответственно, выполнение всего \textit{scp-процесса} по данной ветке приостанавливается. Чтобы продолжить выполнение, необходимо удалить указанный \textit{\mbox{scp-оператор}} из множества \textit{отложенных действий} и добавить его во множество \textit{активных действий}.

Под \textit{некорректностью в scp-программе} понимается \textit{некорректная структура}, описывающая некорректность (не обязательно делающую невозможным выполнение соответствующих данной \textit{scp-программе scp-процессов}), выявленную в рамках какой-либо конкретной \textit{scp-программы}.

\begin{SCn}
\scnheader{некорректность в scp-программе}
\scnrelto{включение}{некорректная структура}
\scnrelfrom{включение}{ошибка в scp-программе}
\begin{scnrelfromlist}{включение}
    \scnitem{недостижимый scp-оператор}
    \scnitem{потенциально бесконечный цикл}
\end{scnrelfromlist}
\end{SCn}

Под \textit{ошибкой в scp-программе} понимается такая \textit{некорректность в scp-программе}, которая делает невозможным успешное выполнение любого \textit{scp-процесса}, соответствующего данной \textit{scp-программе}, или даже создание такого \textit{scp-процесса}.

\begin{SCn}
\scnheader{ошибка в scp-программе}
\begin{scnreltoset}{разбиение}
    \scnitem{синтаксическая ошибка в scp-программе}
    \begin{scnindent}
        \scnexplanation{Под \textit{синтаксической ошибкой в scp-программе} понимается \textit{ошибка в scp-программе}, в состав которой входит некоторая конструкция, не соответствующая синтаксису \textit{scp-программы} или какой-либо ее части, например, конкретного \textit{scp-оператора}.}
    \end{scnindent}
    \scnitem{семантическая ошибка в scp-программе}
    \begin{scnindent}
        \scnexplanation{Под \textit{семантической ошибкой в scp-программе} понимается \textit{ошибка в scp-программе}, в состав которой входит некоторая конструкция, корректная с точки зрения синтаксиса, но некорректная с семантической точки зрения, например, нарушающая логическую целостность \textit{scp-программы}.}
    \end{scnindent}
\end{scnreltoset}
\begin{scnreltoset}{разбиение}
    \scnitem{ошибка в scp-программе на уровне программы}
    \scnitem{ошибка в scp-программе на уровне множества параметров}
    \scnitem{ошибка в scp-программе на уровне множества операторов}
    \scnitem{ошибка в scp-программе на уровне оператора}
    \scnitem{ошибка в scp-программе на уровне операнда}
\end{scnreltoset}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне программы} описывает некорректный фрагмент, выявление которого требует анализа всей \textit{scp-программы} как единого целого, и не может быть выполнено путем анализа ее отдельных частей, например, конкретных \textit{scp-операторов}.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне программы}
\begin{scnrelfromlist}{включение}
    \scnitem{отсутствует scp-процесс, соответствующий данной scp-программе}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{не указана декомпозиция scp-процесса, соответствующего данной scp-программе}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
\end{scnrelfromlist}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне множества параметров} описывает некорректный фрагмент, для выявления которого достаточно анализа параметров некоторой \textit{scp-программы}, т. е. явным образом выделенных аргументов \textit{действия (scp-процессе)}, соответствующего данной scp-программе. К такого рода ошибкам относятся, например, неверное указание ролей этих аргументов в рамках данного действия.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне множества параметров}
\begin{scnrelfromlist}{включение}
    \scnitem{не указан тип параметра scp-программы}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{не указан порядковый номер параметра scp-программы}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
\end{scnrelfromlist}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне множества операторов} описывает некорректный фрагмент, для выявления которого достаточно анализа множества операторов некоторой \textit{scp-программы}, т. е. элементов декомпозиции \textit{действия (scp-процесса)}, соответствующего данной \textit{scp-программе}. К таким ошибкам относится, например, факт отсутствия \textit{начального оператора' scp-программы} или факт отсутствия в программе \textit{scp-оператора завершения выполнения программы}.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне множества операторов}
\begin{scnrelfromlist}{включение}
    \scnitem{декомпозиция scp-процесса не содержит ни одного элемента}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{отсутствует scp-оператор завершения выполнения программы}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{scp-оператор, к которому осуществляется переход, не является частью текущего scp-процесса}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{не указана последовательность действий после выполнения текущего scp-оператора}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{отсутствует начальный оператор scp-программы}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
\end{scnrelfromlist}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне оператора} описывает некорректный фрагмент, для выявления которого достаточно анализа одного конкретного \textit{scp-оператора}, при этом не важно, в состав какой \textit{scp-программы} он входит. К такого рода ошибкам относится, например, факт указания количества операндов \textit{scp-оператора}, не соответствующего спецификации соответствующего класса \textit{scp-операторов}.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне оператора}
\begin{scnrelfromlist}{включение}
    \scnitem{scp-оператор не принадлежит ни одному из атомарных классов scp-операторов}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{ни один операнд scp-оператора удаления не помечен как удаляемый sc-элемент}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{в scp-операторе поиска пятиэлементной конструкции совпадает второй и четвертый операнд}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{scp-оператор поиска не содержит ни одного операнда с заданным значением}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{scp-оператор поиска с формированием множеств не содержит ни одного операнда с атрибутом формируемое множество}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{атрибутом формируемое множество отмечен операнд, которому соответствует операнд с заданным значением}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{количество операндов scp-оператора не совпадает со спецификацией}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
\end{scnrelfromlist}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне операнда} описывает некорректный фрагмент, для выявления которого достаточно анализа одного конкретного операнда в рамках scp-программы, точнее sc-дуги принадлежности, связывающей указанный операнд и соответствующий \textit{scp-оператор}, при этом не важно, какой именно \textit{scp-оператор}. К такого рода ошибкам относится, например, факт отсутствия ролевого отношения, указывающего на номер операнда в рамках \textit{scp-оператора}.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне операнда}
\begin{scnrelfromlist}{включение}
    \scnitem{не указан номер операнда в рамках scp-оператора}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
\end{scnrelfromlist}

\scnheader{некорректность в scp-программе*}
\scniselement{бинарное отношение}
\scnrelfrom{первый домен}{некорректность в scp-программе}
\scnrelfrom{второй домен*}{scp-программа}
\end{SCn}

Отношение \textit{scp-программа поиска некорректности в scp-программе*} связывает \textit{класс некорректностей в scp-программе} и \textit{scp-программу}, которая может использоваться для выявления соответствующей некорректности в какой-либо другой \textit{scp-программе}. 

Указанная \textit{scp-программа} должна иметь единственный параметр, который является \textit{in-параметром’} и, в зависимости от соответствующего класса некорректностей в \textit{scp-программе}, обозначает:

\begin{textitemize}
    \item саму \textit{scp-программу} в случае выявления \textit{некорректности в scp-программе} вообще или \textit{ошибки в scp-программе на уровне программы};
    \item \textit{scp-процесс}, являющийся \textit{ключевым sc-элементом} данной \textit{scp-программы} в случае выявления ошибки в \textit{scp-программе на уровне множества параметров};
    \item \textit{множество операторов} данной \textit{scp-программы} в случае выявления \textit{ошибки в scp-программе на уровне множества операторов};
    \item \textit{знак конкретного scp-оператора} в случае выявления ошибки в \textit{scp-программе на уровне оператора};
    \item \textit{sc-дугу принадлежности} в случае выявления \textit{ошибки в scp-программе на уровне операнда}.
\end{textitemize}

Если в результате верификации \textit{scp-программы} выявлена некорректность, то формируется соответствующая \textit{структура} и генерируется связка отношения \textit{некорректность в scp-программе*}.

\subsection{Семантическая модель решателя задач системы автоматизации проектирования решателей задач ostis-систем}

\textit{\textbf{Семантическая модель решателя задач системы автоматизации проектирования агентов обработки знаний}}

\begin{SCn}
\scnheader{Решатель задач системы автоматизации проектирования агентов обработки знаний}
\begin{scnsubdividing}
    \scnitem{Множетсво методов решателя задач системы автоматизации проектирования агентов обработки знаний}
    \scnitem{Машина обработки знаний системы автоматизации проектирования агентов обработки знаний}
    \begin{scnindent}
        \begin{scnreltoset}{декомпозиция sc-агента}
            \scnitem{абстрактный sc-агент верификации sc-агентов}
            \begin{scnindent}
                \begin{scnreltoset}{декомпозиция sc-агента}
                    \scnitem{абстрактный sc-агент верификации спецификации sc-агента}
                    \scnitem{абстрактный sc-агент проверки неатомарного sc-агента на непротиворечивость его спецификации спецификациям более частных sc-агентов в его составе}
                \end{scnreltoset}
            \end{scnindent}
            \scnitem{абстрактный sc-агент отладки коллективов sc-агентов}
            \begin{scnindent}
                \begin{scnreltoset}{декомпозиция sc-агента}
                    \scnitem{абстрактный sc-агент поиска всех выполняющихся процессов, соответствующих заданному sc-агенту}
                    \scnitem{абстрактный sc-агент инициирования заданного sc-агента на заданных аргументах}
                    \scnitem{абстрактный sc-агент активации заданного sc-агента}
                    \scnitem{абстрактный sc-агент деактивации заданного sc-агента}
                    \scnitem{абстрактный sc-агент установки блокировки заданного типа для заданного процесса на заданный sc-элемент}
                    \scnitem{абстрактный sc-агент снятия всех блокировок заданного процесса}
                    \scnitem{абстрактный sc-агент снятия всех блокировок с заданного sc-элемента}
                \end{scnreltoset}
            \end{scnindent}
        \end{scnreltoset}
    \end{scnindent}
\end{scnsubdividing}
\end{SCn}

Единственным аргументом класса действий, соответствующего \textit{абстрактному sc-агенту поиска всех выполняющихся процессов, соответствующих заданному sc-агенту, абстрактному sc-агенту активации заданного sc-агента, абстрактному sc-агенту деактивации заданного sc-агента}, является знак этого \textit{sc-агента}.

Класс действий, соответствующий \textit{абстрактному sc-агенту инициирования заданного sc-агента на заданных аргументах}, имеет два аргумента. Первый аргумент является знаком инициируемого sc-агента, второй -- знаком связки, в которую под соответствующими атрибутами входят sc-элементы, которые станут аргументами соответствующего \textit{действия в sc-памяти}.

Класс действий, соответствующий \textit{абстрактному sc-агенту установки блокировки заданного типа на заданный sc-элемент}, имеет три аргумента. Первый аргумент является знаком класса блокировок, второй -- знаком процесса в sc-памяти, третий -- sc-элементом, на который должна быть установлена блокировка.

Единственным аргументом класса действий, соответствующего \textit{абстрактному sc-агенту снятия всех блокировок заданного процесса}, является знак этого \textit{процесса в sc-памяти}.

Единственным аргументом класса действий, соответствующего \textit{абстрактному sc-агенту снятия всех блокировок с заданного sc-элемента}, является знак этого \textit{sc-элемента}.


\textit{\textbf{Семантическая модель решателя задач системы автоматизации проектирования scp-программ}}

\begin{SCn}
\scnheader{Решатель задач системы автоматизации проектирования scp-программ}
\begin{scnsubdividing}
    \scnitem{Множетсво методов решателя задач системы автоматизации проектирования агентов обработки знаний}
    \scnitem{Машина обработки знаний системы автоматизации проектирования агентов обработки знаний}
    \begin{scnindent}
        \begin{scnreltoset}{декомпозиция sc-агента}
            \scnitem{абстрактный sc-агент верификации scp-программ}
            \scnitem{абстрактный sc-агент отладки scp-программ}
            \begin{scnindent}
                \begin{scnreltoset}{декомпозиция sc-агента}
                    \scnitem{абстрактный sc-агент запуска заданной scp-программы для заданного множества входных данных}
                    \scnitem{абстрактный sc-агент запуска заданной scp-программы для заданного множества входных данных в режиме пошагового выполнения}
                    \scnitem{абстрактный sc-агент поиска всех scp-операторов в рамках scp-программы}
                    \scnitem{абстрактный sc-агент поиска всех точек останова в рамках scp-процесса}
                    \scnitem{абстрактный sc-агент добавления точки останова в scp-программу}
                    \scnitem{абстрактный sc-агент удаления точки останова из scp-программы}
                    \scnitem{абстрактный sc-агент добавления точки останова в scp-процесс}
                    \scnitem{абстрактный sc-агент удаления точки останова из scp-процесса}
                    \scnitem{абстрактный sc-агент продолжения выполнения scp-процесса на один шаг}
                    \scnitem{абстрактный sc-агент продолжения выполнения scp-процесса до точки останова или завершения}
                    \scnitem{абстрактный sc-агент просмотра информации об scp-процессе}
                    \scnitem{абстрактный sc-агент просмотра информации об scp-операторе}
                \end{scnreltoset}
            \end{scnindent}
        \end{scnreltoset}
    \end{scnindent}
\end{scnsubdividing}
\end{SCn}

Алгоритм работы \textit{абстрактного sc-агента верификации scp-программ} сводится к поиску некорректностей в рамках \textit{scp-программы} на основе определений, соответствующих различным классам таких некорректностей, а также посредством запуска соответствующих данным классам некорректностей \textit{scp-программ поиска некорректности в scp-программе*}.

Результатом работы \textit{абстрактного sc-агента верификации scp-программ} является формирование в \textit{sc-памяти структур}, описывающих некорректности в исследуемой \textit{scp-программе}, если таковые имеются.

Единственным аргументом класса действий, соответствующего \textit{абстрактному sc-агенту верификации scp-программ}, является знак верифицируемой \textit{scp-программы}.

Классы действий, соответствующие \textit{абстрактному sc-агенту запуска заданной scp-программы для заданного множества входных данных} и \textit{абстрактному sc-агенту запуска заданной scp-программы для заданного множества входных данных в режиме пошагового выполнения}, имеют два аргумента. Первый аргумент является знаком запускаемой scp-программы, второй -- знаком связки, в которую под соответствующими атрибутами входят sc-элементы, которые станут аргументами соответствующего scp-процесса.

В режиме пошагового выполнения предполагается, что на каждом шаге инициируется выполнение всех scp-операторов в рамках заданного scp-процесса, для которых предыдущий scp-оператор стал прошлой сущностью (выполнился). В свою очередь, шаг заканчивается, когда все инициированные таким образом операторы закончат выполнение. Таким образом, в случае, если в рамках scp-программы есть параллельные ветви, то на одном шаге могут одновременно инициироваться два и более scp-оператора.

Классы действий, соответствующие \textit{абстрактному sc-агенту добавления точки останова в scp-программу, абстрактному sc-агенту удаления точки останова из scp-программы, абстрактному sc-агенту добавления точки останова в scp-процесс} и \textit{абстрактному sc-агенту удаления точки останова из scp-процесса}, имеют два аргумента. Первый аргумент является знаком scp-программы или scp-процесса соответственно, второй -- знаком scp-оператора, входящего в состав этой scp-программы или scp-процесса.

Единственным аргументом классов действий, соответствующих \textit{абстрактному sc-агенту поиска всех точек останова в рамках scp-процесса, абстрактному sc-агенту продолжения выполнения scp-процесса на один шаг, абстрактному sc-агенту продолжения выполнения scp-процесса до точки останова или завершения} и \textit{абстрактному sc-агенту просмотра информации об scp-процессе}, является знак scp-процесса, с которым будет выполнено соответствующее действие.

Единственным аргументом класса действий, соответствующего \textit{абстрактному sc-агенту поиска всех scp-операторов в рамках scp-программы}, является знак этой scp-программы.

Единственным аргументом класса действий, соответствующего \textit{абстрактному sc-агенту просмотра информации об scp-операторе}, является знак scp-оператора, входящего в состав некоторого scp-процесса. Результатом работы данного агента является структура, описывающая значения операндов данного scp-оператора, его атомарный тип и другую служебную информацию, полезную для разработчика.

\subsection{Семантическая модель пользовательского интерфейса системы автоматизации проектирования решателей задач ostis-систем}

Пользовательский интерфейс системы автоматизации проектирования решателей задач ostis-систем представлен набором интерфейсных команд, позволяющих пользователю инициировать деятельность нужного агента, входящего в состав этой системы.

\begin{SCn}
\scnheader{команда пользовательского интерфейса системы автоматизации проектирования решателей задач ostis-систем}
\begin{scnreltoset}{разбиение}
    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования агентов обработки знаний}
    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования программ языка SCP}
\end{scnreltoset}

\scnheader{команда пользовательского интерфейса системы автоматизации проектирования агентов обработки знаний}
\begin{scnreltoset}{разбиение}
    \scnitem{команда верификации sc-агентов}
    \begin{scnindent}
        \begin{scnreltoset}{разбиение}
            \scnitem{команда верификации спецификации sc-агента}
            \scnitem{команда верификации неатомарного sc-агента на непротиворечивость его спецификации спецификациям более частных sc-агентов в его составе}
        \end{scnreltoset}
    \end{scnindent}
    \scnitem{команда отладки коллективов sc-агентов}
    \begin{scnindent}
        \begin{scnreltoset}{разбиение}
            \scnitem{команда поиска всех выполняющихся процессов, соответствующих заданному sc-агенту}
            \scnitem{команда инициирования заданного sc-агента на заданных аргументах}
            \scnitem{команда активации заданного sc-агента}
            \scnitem{команда деактивации заданного sc-агента}
            \scnitem{команда установки блокировки заданного типа для заданного процесса на заданный sc-элемент}
            \scnitem{команда снятия всех блокировок заданного процесса}
            \scnitem{команда снятия всех блокировок с заданного sc-элемента}
        \end{scnreltoset}
    \end{scnindent}
\end{scnreltoset}

\scnheader{команда пользовательского интерфейса системы автоматизации проектирования scp-программ}
\begin{scnreltoset}{разбиение}
    \scnitem{команда верификации scp-программ}
    \scnitem{команда отладки scp-программ}
    \begin{scnindent}
        \begin{scnreltoset}{разбиение}
            \scnitem{команда запуска заданной scp-программы для заданного множества входных данных}
            \scnitem{команда запуска заданной scp-программы для заданного множества входных данных в режиме пошагового выполнения}
            \scnitem{команда поиска всех scp-операторов в рамках scp-программы}
            \scnitem{команда поиска всех точек останова в рамках scp-процесса}
            \scnitem{команда добавления точки останова в scp-программу}
            \scnitem{команда удаления точки останова из scp-программы}
            \scnitem{команда добавления точки останова в scp-процесс}
            \scnitem{команда удаления точки останова из scp-процесса}
            \scnitem{команда продолжения выполнения scp-процесса на один шаг}
            \scnitem{команда продолжения выполнения scp-процесса до точки останова или завершения}
            \scnitem{команда просмотра информации об scp-процессе}
            \scnitem{команда просмотра информации об scp-операторе}
        \end{scnreltoset}
    \end{scnindent}
\end{scnreltoset}

\end{SCn}

% \section{Логико-семантическая модель ostis-системы автоматизации проектирования программ Базового языка программирования ostis-систем}
% \section{Логико-семантическая модель ostis-системы автоматизации проектирования внутренних агентов ostis-систем, а также коллективов таких агентов}
\section{Многократно используемые компоненты решателей задач ostis-систем}

Библиотека многократно используемых компонентов решателей задач является важнейшим фрагментом Метасистемы OSTIS, обеспечивающим надежность проектируемых решателей задач и повышение скорости их разработки.

Библиотека включает:
\begin{textitemize}
\item множество компонентов решателей задач;
\item средства спецификации компонентов решателей задач;
\item средства поиска компонентов решателей задач на основе их спецификации.
\end{textitemize}

Если \textit{многократно используемый компонент решателей задач} является \textit{платформенно-зависимым многократно используемым компонентом ostis-системы}, то его интеграция производится в соответствии с инструкцией, предоставляемой разработчиком в зависимости от платформы, как и для любого компонента такого рода. В противном случае процесс интеграции можно конкретизировать в зависимости от подклассов данного типа компонентов. 

Рассмотрим классификацию многократно используемых компонентов решателей задач ostis-систем.

\begin{SCn}
\scnheader{многократно используемый компонент решателей задач}
\scnsuperset{программа}
\scnsuperset{пакет программ}
\scnsuperset{абстрактный sc-агент}
\scnsuperset{решатель задач ostis-системы}
\begin{scnindent}
    \scnnote{Целые решатели задач могут быть многократно используемыми компонентами в случае разработки интеллектуальных систем, назначение которых совпадает.}
\end{scnindent}

\scnheader{метод}
\scnidtf{программа}
\scnsuperset{программа на основе нейросетевых моделей}
\scnsuperset{программа на основе генетических алгоритмов}
\scnsuperset{императивная программа}
\begin{scnindent}
    \scnsuperset{процедурная программа}
    \scnsuperset{объектно-ориентированная программа}
\end{scnindent}
\scnsuperset{декларативная программа}
\begin{scnindent}
    \scnsuperset{логическая программа}
    \scnsuperset{функциональная программа}
\end{scnindent}
\scnsuperset{программа sc-агента}

\scnheader{абстрактный sc-агент}
\begin{scnsubdividing}
    \scnitem{неатомарный абстрактный sc-агент}
    \scnitem{атомарный абстрактный sc-агент}
\end{scnsubdividing}
\begin{scnsubdividing}
    \scnitem{внутренний абстрактный sc-агент}
    \scnitem{эффекторный абстрактный sc-агент}
    \scnitem{рецепторный абстрактный sc-агент}
\end{scnsubdividing}
\begin{scnsubdividing}
    \scnitem{абстрактный sc-агент, не реализуемый на Языке SCP}
    \scnitem{абстрактный sc-агент, реализуемый на Языке SCP}
\end{scnsubdividing}
\begin{scnsubdividing}
    \scnitem{абстрактный sc-агент интерпретации scp-программ}
    \scnitem{абстрактный программный sc-агент}
    \scnitem{абстрактный sc-метаагент}
\end{scnsubdividing}
\begin{scnsubdividing}
    \scnitem{платформенно-зависимый абстрактный sc-агент}
    \begin{scnindent}
        \scnsuperset{абстрактный sc-агент, не реализуемый на Языке SCP}
    \end{scnindent}
    \scnitem{платформенно-независимый абстрактный sc-агент}
\end{scnsubdividing}
\begin{scnsubdividing}
    \scnitem{абстрактный sc-агент информационного поиска}
    \scnitem{абстрактный sc-агент погружения интегрируемого знания в базу знаний}
    \scnitem{абстрактный sc-агент выравнивания онтологии интегрируемого знания с основной онтологией текущего состояния базы знаний}
    \scnitem{абстрактный sc-агент планирования решения явно сформулированных задач}
    \scnitem{абстрактный sc-агент логического вывода}
    \scnitem{абстрактный sc-агент верификации базы знаний}
    \scnitem{абстрактный sc-агент редактирования базы знаний}
    \scnitem{абстрактный sc-агент автоматизации деятельности разработчиков базы знаний}
\end{scnsubdividing}

Классификацию и описание решателей задач ostis-систем можно найти в \ref{sec_ps_ps} \nameref{sec_ps_ps};

\end{SCn}

Под \textit{многократно используемым абстрактным sc-агентом} подразумевается компонент, соответствующий некоторому \textit{абстрактному sc-агенту}, который может быть использован в других системах, возможно, в составе более сложных \textit{неатомарных абстрактных sc-агентов}. Указанный абстрактный sc-агент входит в соответствующую компоненту \textit{структуру} под атрибутом \textit{ключевой sc-элемент'}. Каждый \textit{многократно используемый абстрактный sc-агент} должен содержать всю информацию, необходимую для функционирования соответствующего \textit{sc-агента} в дочерней ostis-системе.

Таким образом, соответствующая \textit{многократно используемому абстрактному sc-агенту структура} формируется следующим образом:

\begin{textitemize}
    \item В нее включается \textit{sc-узел}, обозначающий соответствующий \textit{абстрактный sc-агент}, и вся его спецификация, т. е., как минимум, указание \textit{ключевых sc-элементов sc-агента*, условия инициирования и результат*, первичного условия инициирования*, sc-описание поведения sc-агента} и класса решаемых им задач;
    \item В случае, если входящий в \textit{многократно используемый sc-агент абстрактный sc-агент} рассматривается как \textit{неатомарный абстрактный sc-агент}, то \textit{многократно используемый sc-агент} будет содержать \textit{sc-узлы}, обозначающие все более частные \textit{абстрактные sc-агенты}, а также все их спецификации;
    \item Для каждого \textit{атомарного абстрактного sc-агента}, знак которого вошел в \textit{многократно используемый абстрактный sc-агент}, необходимо выбрать вариант его реализации (т. е. элемент класса \textit{платформенно-независимый абстрактный sc-агент} или \textit{платформенно-зависимый абстрактный sc-агент}, связанный с исходным \textit{атомарным абстрактным sc-агентом} связкой отношения \textit{включение*}) и включить в \textit{многократно используемый абстрактный sc-агент} sc-узел, обозначающий указанную реализацию, а также знаки всех программ, входящие во множество, связанное с указанной реализацией отношением \textit{программа sc-агента*}. Выбранная реализация включается в \textit{многократно используемый абстрактный sc-агент} под атрибутом \textit{ключевой sc-элемент'};
    \item В \textit{многократно используемый абстрактный sc-агент} включаются также все связки отношений, связывающие уже включенные в его состав sc-элементы, а также сами знаки этих отношений (например, \textit{включение*, программа sc-агента*} и т. д.).
\end{textitemize}

После того как \textit{многократно используемый абстрактный sc-агент} был скопирован в дочернюю ostis-систему, необходимо сгенерировать sc-узел, обозначающий конкретный \textit{sc-агент}, работающий в данной системе и принадлежащий выбранной реализации \textit{абстрактного sc-агента}, и добавить его во множество \textit{активных sc-агентов} при необходимости.

Под \textit{многократно используемой программой} подразумевается компонент, соответствующий программе, записанной на произвольном языке программирования, которая ориентирована на обработку \textit{структур}, хранящихся в памяти \textit{ostis-системы}. Приоритетным в данном случае является использование \textit{scp-программ} по причине их платформенной независимости, за исключением случаев проектирования некоторых компонентов интерфейса, когда полная платформенная независимость невозможна (например, при проектировании \textit{эффекторных sc-агентов и рецепторных sc-агентов}).

Также каждую \textit{scp-программу}, попавшую в \textit{дочернюю ostis-систему} при копировании \textit{многократно используемого комопнента решателя задач}, необходимо добавить во множество \textit{корректных scp-программ} (корректность верифицируется при попадании в библиотеку компонентов).

Для удобства работы с библиотекой многократно используемых компонентов необходимы так же средства автоматизации поиска компонентов на основе заданной спецификации, представляющие собой неатомарный sc-агент, который декомпозируется на более частные.

Ниже представлена структура такого агента:

\begin{Scn}
\scnheader{Средства автоматизации библиотеки многократно используемых компонентов решателей задач}
\begin{scnreltoset}{декомпозиция sc-агента}
    \scnitem{абстрактный sc-агент формирования неатомарного компонента из атомарных}
    \scnitem{абстрактный sc-агент поиска всех неатомарных компонентов, частью которых является заданный атомарный компонент}
    \scnitem{абстрактный sc-агент поиска всех сопутствующих компонентов}
    \scnitem{абстрактный sc-агент поиска sc-агента по условию инициирования}
    \scnitem{абстрактный sc-агент поиска sc-агента по результату работы}
    \scnitem{абстрактный sc-агент поиска scp-программы по входным/выходным параметрам}
    \scnitem{абстрактный sc-агент поиска sc-агентов, для которых элементы заданного множества являются ключевыми sc-элементами}
\end{scnreltoset}
\end{SCn}

Под \textit{неатомарным компонентом решателей задач} понимается такой компонент, в составе которого можно выделить другие компоненты, которые могут использоваться самостоятельно, отдельно от исходного компонента. Чаще всего в роли таких неатомарных компонентов выступают неатомарные sc-агенты, в составе которых могут быть выделены самодостаточные sc-агенты, которые могут быть использованы отдельно от исходного неатомарного, или scp-программы, которые являются общими для нескольких агентов и могут быть использованы не только в составе неатомарного sc-агента. Таким образом, задачей \textit{абстрактного sc-агента формирования неатомарного компонента из атомарных} является формирование структуры, содержащей в себе полный sc-текст неатомарного компонента, включая спецификации всех \mbox{sc-агентов} в его составе, а также тексты всех необходимых scp-программ. Формирование такой структуры необходимо для того, чтобы упростить процесс копирования указанного компонента в другие ostis-системы.

Под сопутствующим компонентом понимается компонент, который часто используется в ostis-системе одновременно с некоторым другим компонентом. Такая связь между компонентами задается явно при помощи отношения \textit{сопутствующий компонент*}. Примерами таких компонентов являются некоторый sc-агент и команда пользовательского интерфейса, позволяющая пользователю инициировать выполнение указанного агента с заданными аргументами. При этом sc-агент будет функционировать и без наличия в системе такой команды, однако для его инициирования придется сформировать соответствующую конструкцию в sc-памяти вручную.

\textit{абстрактный sc-агент поиска sc-агентов, для которых элементы заданного множества являются ключевыми sc-элементами} играет важную роль при внесении изменений в базу знаний, в частности, при переопределении каких-либо понятий. Указанный sc-агент позволяет выявить те sc-агенты, для которых могут потребоваться изменения в алгоритме работы в связи с изменением семантической трактовки каких-либо понятий.

Рассмотрим отношения необходимые для спецификации многократно используемого компонента решателя задач, его поиска и установки в дочернюю ostis-систему.

\begin{SCn}
\scnheader{отношение, специфицирующее многократно используемый компонент решателей задач ostis-систем}
\scnsubset{отношение, специфицирующее многократно используемый компонент ostis-систем}
\scnhaselement{первичное условие инициирования*}
\begin{scnindent}
    \scnexplanation{Связки отношения первичное условие инициирования* связывают между собой sc-узел, обозначающий абстрактный sc-агент и бинарную ориентированную пару, описывающую первичное условие инициирования данного абстрактного sc-агента, т.е. такой ситуации в sc-памяти, которая побуждает sc-агента перейти в активное состояние и начать проверку наличия своего полного условия инициирования.
    
    Первым компонентом данной ориентированной пары является знак некоторого подмножества понятия событие, например событие добавления выходящей sc-дуги, т.е. по сути конкретный тип события в sc-памяти.
    
    Вторым компонентом данной ориентированной пары является произвольный в общем случае sc-элемент, с которым непосредственно связан указанный тип события в sc-памяти, т.е., например, sc-элемент, из которого выходит либо в который входит генерируемая либо удаляемая sc-дуга, либо sc-ссылка, содержимое которой было изменено.
    
    После того, как в sc-памяти происходит некоторое событие, активизируются все активные sc-агенты, первичное условие инициирования* которых соответствует произошедшему событию.}
    \scnrelfrom{первый домен}{абстрактный sc-агент}
    \scnrelfrom{второй домен}{бинарная ориентированная пара}
\end{scnindent}
\scnhaselement{условие инициирования и результат*}
\begin{scnindent}
    \scnexplanation{Связки отношения условие инициирования и результат* связывают между собой sc-узел, обозначающий абстрактный sc-агент и бинарную ориентированную пару, связывающую условие инициирования данного абстрактного sc-агента и результаты выполнения данного экземпляров данного sc-агента в какой-либо конкретной системе.
    
    Указанную ориентированную пару можно рассматривать как логическую связку импликации, при этом на sc-переменные, присутствующие в обеих частях связки, неявно накладывается квантор всеобщности, на sc-переменные, присутствующие либо только в посылке, либо только в заключении неявно накладывается квантор существования.
    
    Первым компонентом указанной ориентированной пары является логическая формула, описывающая условие инициирования описываемого абстрактного sc-агента, то есть конструкции, наличие которой в sc-памяти побуждает sc-агент начать работу по изменению состояния sc-памяти. Данная логическая формула может быть как атомарной, так и неатомарной, в которой допускается использование любых связок логического языка.
    
    Вторым компонентом указанной ориентированной пары является логическая формула, описывающая возможные результаты выполнения описываемого абстрактного sc-агента, то есть описание произведенных им изменений состояния sc-памяти. Данная логическая формула может быть как атомарной, так и неатомарной, в которой допускается использование любых связок логического языка.}
    \scnrelfrom{первый домен}{абстрактный sc-агент}
    \scnrelfrom{второй домен}{бинарная ориентированная пара}
\end{scnindent}
\scnhaselement{эквивалентный компонент*}
\begin{scnindent}
    \scnhaselement{неориентированное отношение}
    \scnexplanation{Бинарное отношение связывающее функционально эквивалентные многократно используемые компоненты решателей задач.}
    \scnrelfrom{первый домен}{многократно используемый компонент решателей задач}
    \scnrelfrom{второй домен}{многократно используемый компонент решателей задач}
\end{scnindent}
\end{SCn}

% \section{Многократно используемые методы, хранимые в памяти ostis-систем и интерпретируемые их внутренними агентами}

\section{Многократно используемые внутренние агенты ostis-систем}

\begin{SCn}
\scnheader{внутренний абстрактный sc-агент}
\scnexplanation{Каждый \textbf{\textit{внутренний абстрактный sc-агент}} обозначает класс \textit{sc-агентов}, которые реагируют на события в \textit{sc-памяти} и осуществляют преобразования исключительно в рамках этой же \textit{sc-памяти}.}

% \scnheader{многократно используемый внутренний агент ostis-системы}
% \scnidtf{внутренний абстрактный sc-агент, являющийся многократно используемым компонентом ostis-системы}
\end{SCn}

%\input{author/references}