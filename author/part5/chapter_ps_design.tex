\chapauthor{Шункевич Д.В.\\Марковец В.С.}
\chapter{Методика и средства компонентного проектирования решателей задач ostis-систем}
\chapauthortoc{Шункевич Д.В.\\Марковец В.С.}
\label{chapter_ps_design}

\abstract{Аннотация к главе.}

В области разработки \textit{решателей задач} существует большое количество конкретных реализаций, однако вопросы совместимости различных решателей при решении одной задачи практически не рассматриваются. Гипотетически возможно существование универсального решателя задач, объединяющего в себе все известные способы и методы решения задач. Однако использование такого решателя в прикладных целях не является целесообразным. Таким образом, наиболее приемлемым вариантом становится создание библиотеки совместимых между собой компонентов, из которых впоследствии может быть скомпилирован решатель, удовлетворяющий необходимым требованиям.
% \section{Анализ подходов к решению проблем в области построения решателей задач}

% Можно выделить два основных исторически сложившихся подхода к построению решателей задач интеллектуальных систем.

% Первый подход предполагает наличие в системе фиксированного решателя (например, машины логического вывода), к которому впоследствии добавляется база знаний, наполнение которой определяется предметной областью, в которой должна работать система. Такие системы получили название «пустых» экспертных систем \cite{AIRefBookP11990} или «оболочек» (expert system shells, \cite{Jackson1998}). Данный подход, как правило, использовался для разработки относительно несложных систем и не имеет широкого применения.

% Второй подход, широко используемый в настоящее время, предполагает наличие программных средств доступа к информации, хранящейся в некоторой базе, совместимых с различными популярными языками программирования. Данный подход широко используется, например, в системах, построенных на основе стандартов W3C \cite{W3C2017}, которые будут подробнее рассмотрены ниже. Структура решателя, построенного на базе таких средств, определяется разработчиком в каждом конкретном случае и не фиксируется какими-либо стандартами. Такой подход обладает большей гибкостью, но отсутствие унификации в структуре и процессе разработки решателей приводит к отсутствию совместимости компонентов решателей, созданных разными разработчиками, большому количеству дублирований одних и тех же решений, повышению накладных расходов в процессе разработки и поддержки решателя.

% \subsection{Подходы к построению решателей задач, предлагаемые консорциумом W3C}

% При построении интеллектуальных систем различного назначения широко используются стандарты консорциума W3C, одной из задач которого является собственно разработка стандартов в области семантических технологий.

% Достаточно сложно выделить конкретные примеры широко используемых решателей, ориентированных на семантическое представление обрабатываемых знаний на основе стандартов W3C, поскольку отсутствуют общие принципы разработки таких решателей, и в каждом конкретном случае, как правило, разрабатывается свой частный решатель. В связи с этим имеет смысл перейти сразу к рассмотрению подходов к обработке знаний, связанных с таким представлением, выделению их достоинств и недостатков.

% Широко используется стандарт OWL 2 \cite{OWL} для семантического представления знаний и стандарт RDF \cite{RDF} для представления знаний в виде семантических сетей. Для непосредственно хранения RDF-троек используются дополнительно специфицируемые форматы, например, RDF/XML, RDF/JSON, N3 и др. Существует большое количество эффективных хранилищ, обеспечивающих хранение и доступ к данным в форматах RDF.

% Для осуществления доступа к данным, представленных в модели RDF, используется протокол и одноименный язык SPARQL \cite{SPARQL}, который в многом схож с языком SQL. Следующим шагом по отношению к языку SPARQL можно считать декларативный язык запросов Cypher, разработанный создателями хранилища Neo4j \cite{CYPHER}. В запросе на языке Cypher может задаваться граф-образец (the graph pattern to match), на основе которого будет осуществляться изоморфный поиск в хранилище.

% Рассмотренные языки SPARQL и Cypher обеспечивают исключительно доступ к хранимым знаниям, непосредственно обработка осуществляется выше, на уровне приложения, работающего с хранилищем знаний. Кроме того, язык SPARQL не предполагает средств редактирования уже имеющихся в системе знаний.

% Существует большое количество реализаций так называемых ризонеров (semantic reasoners), осуществляющих логический вывод на онтологиях, представленных в формате OWL 2, а также средств разработки и редактирования таких онтологий. Полный список таких средств, признанных консорциумом W3C, можно найти на сайте \cite{OWLImplementations}. Как видно из приведенной на нем таблицы, подавляющее большинство средств способно осуществлять только прямой логический вывод на основе отношений, описанных в онтологии.

% Можно сделать вывод о том, что в рамках консорциума разработаны эффективные средства представления знаний, доступа к ним и механизмы логического вывода на онтологиях, представленных в таком виде. Однако отсутствуют общие принципы построения решателей задач, ориентированных на такое представление, что порождает большое количество дублирований и значительно повышает трудоемкость разработки основанных на таком представлении приложений. 

% \subsection{Комплексные подходы к проектированию интеллектуальных систем различных классов и их компонентов}

% Одним из важнейших способов снижения сроков разработки компьютерных систем любых классов и устранения дублирований при разработке аналогичных решений является обеспечение возможности повторного использования различных компонентов таких систем и накопление библиотек таких компонентов. Отдельное внимание стоит также уделить средствам, обеспечивающим комплексный подход к проектированию интеллектуальных систем какого-либо класса и интеграции различных подходов к решению задач в рамках одной системы.

% Среди комплексных подходов к построению решателей задач, разрабатываемых русскоязычными авторами, можно выделить проект IACPaaS \cite{Gribova2015a,Gribova2011}, активно развивающийся в настоящее время. Целью данного проекта является разработка облачной платформы для построения на ее основе интеллектуальных сервисов различного назначения. В данном проекте активно используются библиотеки многократно используемых компонентов интеллектуальных систем. Конкретно для построения решателей задач, а также пользовательских интерфейсов таких систем используется многоагентный подход. Несмотря на близость некоторых технологических решений, реализуемых в проекте IACPaaS и в данной диссертационной работе, основной целью указанного проекта является предоставление пользователю большого числа разнородных сервисов, выбор которых осуществляется самим пользователем, в то время как в рамках данной диссертационной работы предполагается разработать общую формальную основу для интеграции различных моделей решения задач с целью их комбинирования при решении одной и той же комплексной задачи. Так, в данном проекте осуществляется построение отдельных решателей, ориентированных на решение конкретных классов задач и предполагается возможность последующего их использования клиентами. Однако данный проект не ставит целью решение таких проблем, как разработка комплексной модели решателя, удовлетворяющей изложенным выше требованиям; унификация различных подходов к решению задач на некоторой общей формальной основе; унификация деятельности разработчиков решателей и разработка единых принципов выделения многократно используемых компонентов решателей.

% Комплексные подходы к построению интеллектуальных систем различных классов активно развивались и развиваются в Новосибирске Ю. А. Загорулько и коллегами. Ряд работ по данному направлению был опубликован еще в конце 1980-х гг., например, \cite{Zhagorulko1987,Zhagorulko1988}, но имеются и современные разработки авторов в сфере проектирования интеллектуальных систем \cite{Zhagorulko2013b,Zhagorulko2016}. В частности, в работе \cite{Zhagorulko2016} высказывается тезис о том, что в процессе реализации интеллектуальных систем различных классов большую помощь разработчикам может оказать репозитарий – библиотека готовых к использованию методов принятия решений вместе с методикой и средствами их исполнения и композиции. Кроме этого, в работе \cite{Zhagorulko2013a} формулируется тезис о необходимости интеграции различных методов поддержки принятия решений для решения сложных задач.

% Задачи интеграции различных подходов, в том числе связанных с решением задач, исследуются также в работе \cite{Phylyppov2016} и других работах тех же авторов. В данной работе предлагается подход к построению единой платформы проведения интеллектуального анализа данных, включающей в себя объектно-ориентированные, а также нечеткие модели и программные инструментальные средства работы с ними, с использованием онтологического системного анализа.

% Компонентному проектированию интеллектуальных систем, основанных на знаниях, посвящена работа \cite{Borisov2014}, в которой обосновывается необходимость накопления и повторного использования различных компонентов интеллектуальных систем, предлагаются возможные решения данной проблемы с использованием онтологий.

% Состояние работ англоязычных авторов, посвященных вопросам решения задач в системах, основанных на знаниях, и актуальных на момент начала 1990-х гг., отражено в обзорных публикациях \cite{Dutta1993,Pau1990}. Более поздние англоязычные работы в данной области в основном ориентированы на решение конкретных частных задач в системах, построенных на основе стандартов W3C, о которых более подробно было сказано выше.

% Таким образом, можно сказать, что существует ряд конкретных разработок в направлении построения комплексных технологий разработки интеллектуальных систем различных классов, в том числе с использованием библиотек многократно используемых компонентов, однако проблемы, сформулированные в данной диссертационной работе, не решались или в полной мере не решены ни в одном из этих подходов. Во многом это обусловлено отсутствием унифицированной формальной основы для представления любых видов знаний, в том числе различного рода программ, отсутствием строгих принципов, регламентирующих процесс построения решателей задач, а также средств поддержки разработчиков таких решателей и их компонентов.

\section{Действия и методики проектирования решателей задач ostis-систем}

Методика построения и модификации решателей задач включает несколько этапов. 
\begin{enumerate}
    \item формирование требований и спецификация  решателя задач;
    \item формирование коллектива sc-агентов, входящих в состав разрабатываемого решателя;
    \item разработка алгоритмов атомарных sc-агентов;
    \item реализация scp-программ;
    \item верификация разработанных компонентов;
    \item отладка разработанных компонентов, исправление ошибок.
\end{enumerate}

Методика может быть применена как при разработке объединенных решателей, так и при разработке решателей частного вида, поскольку с формальной точки зрения все они трактуются как неатомарный абстрактный sc-агент.

\textbf{\textit{Этап 1. Формирование требований и спецификация  решателя задач}}

На данном этапе необходимо:
\begin{itemize}
\item четко выделить задачи, решение которых должен обеспечивать решатель задач;
\item продумать предполагаемые способы их решения и на основе данного анализа определить место будущего решателя в общей иерархии решателей.
\end{itemize}

Важность данного этапа заключается в том, что при правильной классификации существует вероятность того, что в составе библиотека многократно используемых компонентов ostis-систем уже есть реализованный вариант требуемого решателя. В противном случае, у разработчика появляется возможность включить разработанный решатель в библиотека многократно используемых компонентов ostis-систем для последующего использования. Данные факты обусловлены тем, что структура библиотеки компонентов решателей задач основана на семантической классификации таких решателей и, соответственно, их компонентов.

При недостаточно четкой спецификации и классификации разрабатываемого решателя повышается вероятность того, что подходящий решатель не будет найден в библиотеке компонентов даже в случае, если он там есть, а вновь разработанный решатель не сможет быть включен в библиотеку. Таким образом, идея многократного использования уже разработанных компонентов будет нарушена, что существенно повысит затраты на разработку такого решателя.

\textbf{\textit{Этап 2. Формирование коллектива sc-агентов, входящих в состав разрабатываемого решателя}}

В случае, когда найти в библиотеке готовый решатель, удовлетворяющий всем предъявляемым требованиям, не представляется возможным, необходимо выделить и специфицировать все компоненты такого решателя.

Результатом данного этапа является перечень полностью специфицированных \textit{sc-агентов}, которые войдут в состав разрабатываемого решателя, с их иерархией вплоть до \textit{атомарных sc-агентов}. В рамках данного этапа очень важно проектировать коллектив агентов таким образом, чтобы максимально задействовать уже имеющиеся в библиотеке многократно используемые компоненты ostis-систем, а при отсутствии нужного компонента –- иметь возможность включить его в библиотеку после реализации.

При разработке перечня агентов (в том числе их спецификаций) необходимо соблюдать ряд принципов:

\begin{itemize}
\item каждый разрабатываемый sc-агент должен быть по возможности предметно независим, т. е. во множество ключевых узлов данного sc-агента не должны входить понятия, имеющие отношение непосредственно к рассматриваемой предметной области. Исключение составляют понятия из общих предметных областей, которые носят междисциплинарный характер (например, отношение \textit{включение*} или понятие \textit{действие}). Данное правило также может быть нарушено в случае, если sc-агент является вспомогательным и ориентирован на обработку какого-либо конкретного класса объектов (например, sc-агенты, выполняющие арифметические вычисления, могут напрямую работать с конкретными отношениями \textit{сложение*} и \textit{умножение*} и т. п.). Всю необходимую для решения задачи информацию sc-агент должен извлекать из семантической окрестности соответствующего инициированного действия. Очевидно, что sc-агент, разработанный с учетом указанных требований, может быть использован при проектировании большего числа ostis-систем, чем в случае, если бы он был реализован с ориентацией на конкретную частную предметную область. После завершения разработки и отладки такой sc-агент должен быть включен в \textit{Библиотеку многократно используемых абстрактных sc-агентов};
\item не стоит путать понятия sc-агент и агентная программа (в том числе агентная scp-программа). Взаимодействие sc-агентов осуществляется исключительно посредством спецификации информационных процессов в общей памяти, каждый sc-агент реагирует на некоторый класс событий в sc-памяти. Таким образом, каждому sc-агенту соответствует некоторое условие инициирования и одна агентная программа, которая запускается автоматически при возникновении в sc-памяти соответствующего условия инициирования. При этом в рамках данной программы могут сколько угодно раз вызываться различные подпрограммы. Однако не стоит путать инициирование sc-агента, которое осуществляется при появлении в sc-памяти соответствующей конструкции, и вызов подпрограммы другой программой, который предполагает явное указание вызываемой подпрограммы и перечня ее параметров;
\item каждый sc-агент должен самостоятельно проверять полноту соответствия своего условия инициирования текущему состоянию sc-памяти. В процессе решения какой-либо задачи может возникнуть ситуация, когда на появление одной и той же структуры среагировали несколько sc-агентов. В таком случае выполнение продолжают только те из них, условие инициирования которых полностью соответствует сложившейся ситуации. Остальные sc-агенты в данном случае прекращают выполнение и возвращаются в режим ожидания. Выполнение данного принципа достигается за счет тщательного уточнения спецификаций разрабатываемых sc-агентов. В общем случае условия инициирования у нескольких sc-агентов могут совпадать, например, в случае, когда одна и та же задача может быть решена разными способами и заранее неизвестно, какой из них приведет к желаемому результату;
% нужен наглядный пример
\item необходимо помнить, что неатомарный sc-агент с точки зрения других sc-агентов, не входящих в его состав, должен функционировать как целостный sc-агент (выполнять логически атомарные действия), что накладывает определенные требования на спецификации атомарных sc-агентов, входящих в его состав: как минимум, необходимо, чтобы в составе неатомарного sc-агента присутствовал хотя бы один атомарный sc-агент, условие инициирования которого полностью совпадает с условием инициирования данного неатомарного sc-агента;
\item при необходимости реализации нового sc-агента следует руководствоваться следующими принципами выделения атомарных абстрактных \textit{sc-агентов}:

\begin{SCn}
\begin{scnindent}
    \begin{scnitemizeii}
        \item проектируемый sc-агент должен быть максимально независим от предметной области, что позволит в дальшейшем использовать его при разработке решателей максимально возможного числа ostis-систем. При этом универсальность предполагает не только минимизацию числа ключевых узлов sc-агента, но и выделение класса действий, выполняемых данным sc-агентом таким образом, чтобы имело смысл включить данный sc-агент в \textit{Библиотеку многократно используемых абстрактных sc-агентов} и использовать его при разработке решателей других ostis-систем. Не следует искусственно увязывать ряд действий в один sc-агент и, наоборот, расчленять одно самодостаточное действие на поддействия: это вызовет сложности восприятия принципов работы sc-агента разработчиками и не позволит использовать sc-агент в ряде систем (например, в обучающих системах, которые должны объяснять ход решения пользователю);
        % а как быть с неатомарными агентами? ведь в них по сути мы вызываем по порядку несколько sc-агентов 
        \item выполняемое данным sc-агентом действие должно быть логически целостным и завершенным. Следует помнить, что все sc-агенты взаимодействуют исключительно через общую sc-память и избегать ситуаций, в которых инициирование одного sc-агента осуществляется путем явной генерации известного условия инициирования другим \textit{sc-агентом} (т. е., по сути, явным непосредственным вызовом одного sc-агента другим);
        \item имеет смысл выделять в отдельные sc-агенты относительно крупные фрагменты реализации некоторого общего алгоритма, которые могут выполняться независимо друг от друга.
    \end{scnitemizeii}
\end{scnindent}
\end{SCn}

\item при объединении sc-агентов в коллективы рекомендуется проектировать их таким образом, чтобы они могли быть использованы не только как часть рассматриваемого неатомарного абстрактного sc-агента. В случае, если это не представляется возможным и некоторые sc-агенты, будучи отделенными от коллектива, теряют смысл, необходимо указать данный факт при документировании рассматриваемых sc-агентов;
\item фактическим инициатором запуска sc-агента посредством общей памяти (автором соответствующей конструкции) может быть как непосредственно пользователь системы, так и другой sc-агент, что никак не должно отражаться в работе самого sc-агента.
\end{itemize}

\textbf{\textit{Этап 3. Разработка алгоритмов атомарных sc-агентов}}

В рамках данного этапа необходимо продумать алгоритм работы каждого разрабатываемого \textit{атомарного sc-агента}. Разработка алгоритма подразумевает выделение в нем логически целостных фрагментов, которые могут быть реализованы как отдельные \textit{scp-программы}, в том числе выполняемые параллельно. Таким образом, появляется необходимость говорить не только о \textit{Библиотеке многократно используемых абстрактных sc-агентов}, но и о \textit{Библиотеке многократно используемых программ обработки sc-текстов} на различных языках программирования, в том числе \textit{Библиотеке многократно используемых scp-программ}. Благодаря этому часть scp-программ, реализующих алгоритм работы некоторого sc-агента, может быть заимствована из соответствующей библиотеки.

Важно помнить, что если в процессе работы \textit{sc-агент} генерирует в памяти какие-либо временные структуры, то при завершении работы он обязан удалять всю информацию, использование которой в системе более нецелесообразно (убрать за собой информационный мусор). Исключение составляют ситуации, когда подобная информация необходима нескольким \textit{sc-агентам} для решения одной задачи, однако после решения задачи информация становится бесполезной или избыточной и требует удаления. В данном случае может возникнуть ситуация, когда ни один из \textit{sc-агентов} не в состоянии удалить информационный мусор. В таком случае возникает необходимость говорить о включении в состав решателя специализированных \textit{sc-агентов}, задачей которых является выявление и уничтожение информационного мусора.

\textbf{\textit{Этап 4. Реализация scp-программ}}

Конечным этапом непосредственно разработки является реализация специфицированных ранее \textit{scp-программ} или при необходимости программ, реализуемых на уровне платформы.

\textbf{\textit{Этап 5. Верификация разработанных компонентов}}

Верификация разработанных компонентов может осуществляться как вручную, так и с использованием специфицированных средств, входящих в состав системы автоматизации проектирования решателей задач по Технологии OSTIS.

\textbf{\textit{Этап 6. Отладка разработанных компонентов. Исправление ошибок}}
Этап отладки разработанных компонентов, в свою очередь, можно также условно разделить на более частные этапы:

\begin{itemize}
    \item отладка отдельных scp-программ или программ, реализуемых на уровне платформы;
    \item отладка отдельных атомарных sc-агентов;
    \item неатомарных sc-агентов, входящих в состав решателя задач;
    \item отладка всего решателя задач.
\end{itemize}

\textit{Этап 5} и \textit{Этап 6} могут выполняться параллельно и повторяются до тех пор, пока разработанные компоненты не будут удовлетворять необходимым требованиям.

Методика построения и модификации решателей задач основана на онтологии деятельности разработчиков таких решателей.

Решатель задач представляет собой \textit{абстрактный sc-агент}, в связи с чем разработка решателя сводится к разработке такого агента.

Фрагмент онтологии деятельности, направленной на построение и модификацию решателей задач:
\begin{SCn}
\scnheader{действие. разработать решатель задач ostis-системы}
\scneq{действие. разработать абстрактный sc-агент}
\begin{scnreltoset}{разбиение}

\scnitem{действие. разработать атомарный абстрактный sc-агент}
\begin{scnindent}
\begin{scnrelfrom}{включение} {действие. разработать платформенно-независимый атомарный абстрактный sc-агент}
\end{scnrelfrom}
\end{scnindent}
\scnitem{действие. разработать неатомарный абстрактный sc-агент}
\end{scnreltoset}

\begin{scnrelfromlist}{абстрактное поддействие}
\scnitem{действие. специфицировать абстрактный sc-агент}
\scnitem{действие. найти в библиотеке абстрактный sc-агент, удовлетворяющий заданной спецификации}
\scnitem{действие. верифицировать sc-агент}
\scnitem{действие. отладить sc-агент}
\end{scnrelfromlist}

\scnheader{действие. разработать платформенно-независимый атомарный абстрактный sc-агент}

\begin{scnrelfromlist}{абстрактное поддействие}
\scnitem{действие. декомпозировать платформенно-независимый атомарный абстрактный sc-агент на scp-программы}
\scnitem{действие. разработать scp-программу}
\end{scnrelfromlist}

\scnheader{действие. разработать неатомарный абстрактный sc-агент}

\begin{scnrelfromlist}{абстрактное поддействие}
    \scnitem{действие. декомпозировать неатомарный абстрактный sc-агент на более частные}
    \scnitem{действие. разработать абстрактный sc-агент}
\end{scnrelfromlist}

\scnheader{действие. разработать scp-программу}

\begin{scnrelfromlist}{абстрактное поддействие}
    \scnitem{действие. специфицировать scp-программу}
    \scnitem{действие. найти в библиотеке scp-программу, удовлетворяющую заданной спецификации}
    \scnitem{действие. реализовать специфицированную scp-программу}
    \scnitem{действие. верифицировать scp-программу}
    \scnitem{действие. отладить scp-программу}
\end{scnrelfromlist}

\scnheader{действие. верифицировать sc-агент}
\begin{scnreltoset}{разбиение}
    \scnitem{действие. верифицировать атомарный sc-агент}
    \scnitem{действие. верифицировать неатомарный sc-агент}
\end{scnreltoset}

\scnheader{действие. отладить sc-агент}

\begin{scnreltoset}{разбиение}
    \scnitem{действие. отладить атомарный sc-агент}
    \scnitem{действие. отладить неатомарный sc-агент}
\end{scnreltoset}
\end{SCn}

Наличие такой онтологии позволяет:
\begin{itemize}
    \item частично автоматизировать процесс построения и модификации решателей;
    \item повысить эффективность информационной поддержки разработчиков, поскольку данная онтология может быть включена в базу знаний интеллектуальной метасистемы IMS.
\end{itemize}

\section{Логико-семантическая модель комплекса ostis-систем автоматизации проектирования решателей задач ostis-систем}

К числу задач системы автоматизации проектирования решателей задач относится техническая поддержка разработчиков решателей, в том числе -- обеспечение корректного и эффективного выполнения этапов, предусмотренных методикой проектирования решателей задач ostis-систем.

При разработке любых компонентов ostis-систем используются схожие принципы. Одним из основных принципов является принцип использования готовых компонентов различного рода, уже имеющихся в библиотеке многократно используемых компонентов ostis-систем, входящей в состав Метасистемы IMS.

Система автоматизации проектировани решателей задач сама по себе также является ostis-системой и имеет соответствующую структуру. Таким образом, модель данной системы включает sc-модель базы знаний, sc-модель объединенного решателя задач и sc-модель пользовательского интерфейса.

В рамках системы условно выделяются две подсистемы -- подсистема автоматизации проектирования агентов обработки знаний и подсистема автоматизации проектирования scp-программ.

% Формально модель такой системы задается следующим образом:

% \begin{equation}
%     M_{SYS} = \{M_{KB}, M_{IPS}, M_{UI}\},	
% \end{equation}
% где $M_{KB}$ – sc-модель базы знаний системы;

% $M_{IPS}$ – sc-модель объединенного решателя задач;

% $M_{UI}$ – sc-модель пользовательского интерфейса системы.

Cистема может использоваться тремя способами:
\begin{itemize}
    \item Как подсистема в рамках метасистемы поддержки проектирования компьютерных систем, управляемых знаниями (IMS). Данный вариант использования предполагает отладку необходимых компонентов в рамках метасистемы с последующим переносом их в дочернюю систему.
    \item Как самостоятельная ostis-система, предназначенная исключительно для разработки и отладки компонентов решателей задач. В этом случае проектируемые компоненты отлаживаются в рамках такой системы, а затем должны быть перенесены в дочернюю ostis-систему.
    \item Как подсистема в рамках дочерней ostis-системы. В таком варианте отладка компонентов осуществляется непосредственно в той же системе, в которой предполагается их использование, и дополнительного переноса не требуется.
\end{itemize}

Независимо от выбранного способа использования системы, разработанные компоненты впоследствии могут быть включены в состав библиотеки многократно используемых компонентов ostis-систем.

Выделяются два принципиально разных уровня отладки решателя задач:
\begin{itemize}
    \item отладка на уровне sc-агентов;
    \item отладка на уровне scp-программ.
\end{itemize}

В случае отладки на уровне sc-агентов акт выполнения каждого агента считается неделимым и не может быть прерван. При этом может выполняться отладка как атомарных sc-агентов, так и неатомарных. Инициирование того или иного агента, в том числе входящего в состав неатомарного, осуществляется путем создания соответствующих конструкций в sc-памяти, таким образом, отладка может осуществляться на разных уровнях детализации агентов, вплоть до атомарных.

Система поддержки проектирования агентов может служить основой для моделирования систем агентов, использующих другие принципы коммуникации, например, непосредственный обмен сообщениями между агентами.

Отладка на уровне scp-программ осуществляется аналогично существующим современным подходам к отладке процедурных программ и предполагает возможность установки точек останова, пошагового выполнения программы и т. д.

Система автоматизации проектирования решателей задач и, соответственно, ее sc-модель, разделяется на две более частные:

\begin{SCn}
\scnheader{Система автоматизации проектирования решателей задач по Технологии OSTIS}

\begin{scnreltoset}{базовая декомпозиция}
\scnitem{Система автоматизации проектирования агентов обработки знаний}
\begin{scnindent}
    \begin{scnreltoset}{базовая декомпозиция}
        \scnitem{База знаний системы автоматизации проектирования агентов обработки знаний}
        \scnitem{Решатель задач системы автоматизации проектирования агентов обработки знаний}
        \scnitem{Пользовательский интерфейс системы автоматизации проектирования агентов обработки знаний}
    \end{scnreltoset}
\end{scnindent}
\scnitem{Система автоматизации проектирования scp-программ}
\begin{scnindent}
    \begin{scnreltoset}{базовая декомпозиция}
        \scnitem{База знаний системы автоматизации проектирования scp-программ}
        \scnitem{Решатель задач системы автоматизации проектирования scp-программ}
        \scnitem{Пользовательский интерфейс системы автоматизации проектирования scp-программ}
    \end{scnreltoset}
\end{scnindent}
\end{scnreltoset}
\end{SCn}

\subsection{Семантическая модель базы знаний системы автоматизации проектирования решателей задач}

База знаний системы автоматизации проектирования решателей задач включает в себя кроме Ядра и расширений ядра sc-моделей баз знаний, предоставляемых на уровне Технологии OSTIS, и моделей предметных областей scp-программ и scp-интерпретатора также описание ключевых понятий, связанных с верификацией и отладкой scp-программ.

Основные понятия, специфичные для базы знаний системы автоматизации проектирования scp-программ.
\begin{SCn}
\scnheader{точка останова*}
\scniselement{квазибинарное отношение}
\end{SCn}

Связки отношения \textit{точки останова*} связывают \textit{scp-программу} с некоторым множеством sc-переменных, соответствующих \textit{scp-операторам} в рамках этой программы. При генерации каждого \textit{scp-процесса}, соответствующего этой \textit{scp-программе}, все \textit{scp-операторы}, соответствующие таким переменным, будут добавлены во множество \textit{точка останова}, т. е. выполнение данного scp-процесса будет прерываться при достижении каждого из этих \textit{scp-операторов}.
Использование данного отношения приводит к указанию точек останова для всех \textit{scp-процессов}, формируемых на основе заданной \textit{\mbox{scp-программы}}. Для указания точки останова в рамках отдельно взятого \textit{scp-процесса} нужный scp-оператор явно включается во множество \textit{точка останова}.

\begin{SCn}
\scnheader{точка останова}
\scnrelto{включение}{scp-оператор}
\end{SCn}

Во множество \textit{точка останова} входят все \textit{scp-операторы}, являющиеся точками останова в рамках какого-либо \textit{scp-процесса}. Это означает, что в момент, когда в соответствии с переходами между \textit{scp-операторами} по связкам отношения \textit{последовательность действий*} указанный \textit{scp-оператор} должен стать \textit{активным действием}, он становится \textit{отложенным действием}, и, соответственно, выполнение всего \textit{scp-процесса} по данной ветке приостанавливается. Чтобы продолжить выполнение, необходимо удалить указанный \textit{\mbox{scp-оператор}} из множества \textit{отложенных действий} и добавить его во множество \textit{активных действий}.

\begin{SCn}
\scnheader{некорректность в scp-программе}
\scnexplanation{Под \textit{некорректностью в scp-программе} понимается \textit{некорректная структура}, описывающая некорректность (не обязательно делающую невозможным выполнение соответствующих данной \textit{scp-программе scp-процессов}), выявленную в рамках какой-либо конкретной \textit{scp-программы}.}
\scnrelto{включение}{некорректная структура}
\scnrelfrom{включение}{ошибка в scp-программе}
\begin{scnrelfromlist}{включение}
    \scnitem{недостижимый scp-оператор}
    \scnitem{потенциально бесконечный цикл}
\end{scnrelfromlist}

\scnheader{ошибка в scp-программе}
\begin{scnindent}
    \scnexplanation{Под \textit{ошибкой в scp-программе} понимается такая \textit{некорректность в scp-программе}, которая делает невозможным успешное выполнение любого \textit{scp-процесса}, соответствующего данной \textit{scp-программе}, или даже создание такого \textit{scp-процесса}.}
\end{scnindent}
\begin{scnreltoset}{разбиение}
    \scnitem{синтаксическая ошибка в scp-программе}
    \begin{scnindent}
        \scnexplanation{Под \textit{синтаксической ошибкой в scp-программе} понимается \textit{ошибка в scp-программе}, в состав которой входит некоторая конструкция, не соответствующая синтаксису \textit{scp-программы} или какой-либо ее части, например, конкретного \textit{scp-оператора}.}
    \end{scnindent}
    \scnitem{семантическая ошибка в scp-программе}
    \begin{scnindent}
        \scnexplanation{Под \textit{семантической ошибкой в scp-программе} понимается \textit{ошибка в scp-программе}, в состав которой входит некоторая конструкция, корректная с точки зрения синтаксиса, но некорректная с семантической точки зрения, например, нарушающая логическую целостность \textit{scp-программы}.}
    \end{scnindent}
\end{scnreltoset}
\begin{scnreltoset}{разбиение}
    \scnitem{ошибка в scp-программе на уровне программы}
    \scnitem{ошибка в scp-программе на уровне множества параметров}
    \scnitem{ошибка в scp-программе на уровне множества операторов}
    \scnitem{ошибка в scp-программе на уровне оператора}
    \scnitem{ошибка в scp-программе на уровне операнда}
\end{scnreltoset}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне программы} описывает некорректный фрагмент, выявление которого требует анализа всей \textit{scp-программы} как единого целого, и не может быть выполнено путем анализа ее отдельных частей, например, конкретных \textit{scp-операторов}.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне программы}
\begin{scnrelfromlist}{включение}
    \scnitem{отсутствует scp-процесс, соответствующий данной scp-программе}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{не указана декомпозиция scp-процесса, соответствующего данной scp-программе}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
\end{scnrelfromlist}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне множества параметров} описывает некорректный фрагмент, для выявления которого достаточно анализа параметров некоторой \textit{scp-программы}, т. е. явным образом выделенных аргументов \textit{действия (scp-процессе)}, соответствующего данной scp-программе. К такого рода ошибкам относятся, например, неверное указание ролей этих аргументов в рамках данного действия.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне множества параметров}
\begin{scnrelfromlist}{включение}
    \scnitem{не указан тип параметра scp-программы}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{не указан порядковый номер параметра scp-программы}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
\end{scnrelfromlist}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне множества операторов} описывает некорректный фрагмент, для выявления которого достаточно анализа множества операторов некоторой \textit{scp-программы}, т. е. элементов декомпозиции \textit{действия (scp-процесса)}, соответствующего данной \textit{scp-программе}. К таким ошибкам относится, например, факт отсутствия \textit{начального оператора' scp-программы} или факт отсутствия в программе \textit{scp-оператора завершения выполнения программы}.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне множества операторов}
\begin{scnrelfromlist}{включение}
    \scnitem{декомпозиция scp-процесса не содержит ни одного элемента}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{отсутствует scp-оператор завершения выполнения программы}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{scp-оператор, к которому осуществляется переход, не является частью текущего scp-процесса}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{не указана последовательность действий после выполнения текущего scp-оператора}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{отсутствует начальный оператор scp-программы}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
\end{scnrelfromlist}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне оператора} описывает некорректный фрагмент, для выявления которого достаточно анализа одного конкретного \textit{scp-оператора}, при этом не важно, в состав какой \textit{scp-программы} он входит. К такого рода ошибкам относится, например, факт указания количества операндов \textit{scp-оператора}, не соответствующего спецификации соответствующего класса \textit{scp-операторов}.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне оператора}
\begin{scnrelfromlist}{включение}
    \scnitem{scp-оператор не принадлежит ни одному из атомарных классов scp-операторов}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{ни один операнд scp-оператора удаления не помечен как удаляемый sc-элемент}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{в scp-операторе поиска пятиэлементной конструкции совпадает второй и четвертый операнд}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{scp-оператор поиска не содержит ни одного операнда с заданным значением}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{scp-оператор поиска с формированием множеств не содержит ни одного операнда с атрибутом формируемое множество}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{атрибутом формируемое множество отмечен операнд, которому соответствует операнд с заданным значением}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
    \scnitem{количество операндов scp-оператора не совпадает со спецификацией}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
\end{scnrelfromlist}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне оператора} описывает некорректный фрагмент, для выявления которого достаточно анализа одного конкретного операнда в рамках scp-программы, точнее sc-дуги принадлежности, связывающей указанный операнд и соответствующий \textit{scp-оператор}, при этом не важно, какой именно \textit{scp-оператор}. К такого рода ошибкам относится, например, факт отсутствия ролевого отношения, указывающего на номер операнда в рамках \textit{scp-оператора}.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне операнда}
\begin{scnrelfromlist}{включение}
    \scnitem{не указан номер операнда в рамках scp-оператора}
    \begin{scnindent}
        \scniselement{синтаксическая ошибка в scp-программе}
    \end{scnindent}
\end{scnrelfromlist}

\scnheader{некорректность в scp-программе*}
\scniselement{бинарное отношение}
\scnrelfrom{первый домен}{некорректность в scp-программе}
\scnrelfrom{второй домен*}{scp-программа}
\end{SCn}

Отношение \textit{scp-программа поиска некорректности в scp-программе*} связывает \textit{класс некорректностей в scp-программе} и \textit{scp-программу}, которая может использоваться для выявления соответствующей некорректности в какой-либо другой \textit{scp-программе}. 

Указанная \textit{scp-программа} должна иметь единственный параметр, который является \textit{in-параметром’} и, в зависимости от соответствующего класса некорректностей в \textit{scp-программе}, обозначает:

\begin{itemize}
    \item саму \textit{scp-программу} в случае выявления \textit{некорректности в \mbox{scp-программе}} вообще или \textit{ошибки в scp-программе на уровне программы};
    \item \textit{scp-процесс}, являющийся \textit{ключевым sc-элементом} данной \textit{\mbox{scp-программы}} в случае выявления ошибки в \textit{scp-программе на уровне множества параметров};
    \item \textit{множество операторов} данной \textit{\mbox{scp-программы}} в случае выявления \textit{ошибки в scp-программе на уровне множества операторов};
    \item \textit{знак конкретного scp-оператора} в случае выявления ошибки в \textit{\mbox{scp-программе} на уровне оператора};
    \item \textit{sc-дугу принадлежности} в случае выявления \textit{ошибки в scp-программе на уровне операнда}.
\end{itemize}

Если в результате верификации \textit{scp-программы} выявлена некорректность, то формируется соответствующая \textit{структура} и генерируется связка отношения \textit{некорректность в scp-программе*}.

\subsection{Семантическая модель решателя задач системы автоматизации проектирования решателей задач}

\textit{\textbf{Семантическая модель решателя задач системы автоматизации проектирования агентов обработки знаний}}

\begin{SCn}
\scnheader{Решатель задач системы автоматизации проектирования агентов обработки знаний}
\begin{scnreltoset}{декомпозиция sc-агента}
    \scnitem{Абстрактный sc-агент верификации sc-агентов}
    \begin{scnindent}
        \begin{scnreltoset}{декомпозиция sc-агента}
            \scnitem{Абстрактный sc-агент верификации спецификации sc-агента}
            \scnitem{Абстрактный sc-агент проверки неатомарного sc-агента на непротиворечивость его спецификации спецификациям более частных sc-агентов в его составе}
        \end{scnreltoset}
    \end{scnindent}
    \scnitem{Абстрактный sc-агент отладки коллективов sc-агентов}
    \begin{scnindent}
        \begin{scnreltoset}{декомпозиция sc-агента}
            \scnitem{Абстрактный sc-агент поиска всех выполняющихся процессов, соответствующих заданному sc-агенту}
            \scnitem{Абстрактный sc-агент инициирования заданного sc-агента на заданных аргументах}
            \scnitem{Абстрактный sc-агент активации заданного sc-агента}
            \scnitem{Абстрактный sc-агент деактивации заданного sc-агента}
            \scnitem{Абстрактный sc-агент установки блокировки заданного типа для заданного процесса на заданный sc-элемент}
            \scnitem{Абстрактный sc-агент снятия всех блокировок заданного процесса}
            \scnitem{Абстрактный sc-агент снятия всех блокировок с заданного sc-элемента}
        \end{scnreltoset}
    \end{scnindent}
\end{scnreltoset}
\end{SCn}

Единственным аргументом класса действий, соответствующего \textit{Абстрактному sc-агенту поиска всех выполняющихся процессов, соответствующих заданному sc-агенту, Абстрактному sc-агенту активации заданного sc-агента, Абстрактному sc-агенту деактивации заданного sc-агента}, является знак этого \textit{sc-агента}.

Класс действий, соответствующий \textit{Абстрактному sc-агенту инициирования заданного sc-агента на заданных аргументах}, имеет два аргумента. Первый аргумент является знаком инициируемого sc-агента, второй -- знаком связки, в которую под соответствующими атрибутами входят sc-элементы, которые станут аргументами соответствующего \textit{действия в sc-памяти}.

Класс действий, соответствующий \textit{Абстрактному sc-агенту установки блокировки заданного типа на заданный sc-элемент}, имеет три аргумента. Первый аргумент является знаком класса блокировок, второй -- знаком процесса в sc-памяти, третий -- sc-элементом, на который должна быть установлена блокировка.

Единственным аргументом класса действий, соответствующего \textit{Абстрактному sc-агенту снятия всех блокировок заданного процесса}, является знак этого \textit{процесса в sc-памяти}.

Единственным аргументом класса действий, соответствующего \textit{Абстрактному sc-агенту снятия всех блокировок с заданного sc-элемента}, является знак этого \textit{sc-элемента}.


\textit{\textbf{Семантическая модель решателя задач системы автоматизации проектирования scp-программ}}

\begin{SCn}
\scnheader{Решатель задач системы автоматизации проектирования scp-программ}
\begin{scnreltoset}{декомпозиция sc-агента}
    \scnitem{Абстрактный sc-агент верификации scp-программ}
    \scnitem{Абстрактный sc-агент отладки scp-программ}
    \begin{scnindent}
        \begin{scnreltoset}{декомпозиция sc-агента}
            \scnitem{Абстрактный sc-агент запуска заданной scp-программы для заданного множества входных данных}
            \scnitem{Абстрактный sc-агент запуска заданной scp-программы для заданного множества входных данных в режиме пошагового выполнения}
            \scnitem{Абстрактный sc-агент поиска всех scp-операторов в рамках scp-программы}
            \scnitem{Абстрактный sc-агент поиска всех точек останова в рамках scp-процесса}
            \scnitem{Абстрактный sc-агент добавления точки останова в scp-программу}
            \scnitem{Абстрактный sc-агент удаления точки останова из scp-программы}
            \scnitem{Абстрактный sc-агент добавления точки останова в scp-процесс}
            \scnitem{Абстрактный sc-агент удаления точки останова из scp-процесса}
            \scnitem{Абстрактный sc-агент продолжения выполнения scp-процесса на один шаг}
            \scnitem{Абстрактный sc-агент продолжения выполнения scp-процесса до точки останова или завершения}
            \scnitem{Абстрактный sc-агент просмотра информации об scp-процессе}
            \scnitem{Абстрактный sc-агент просмотра информации об scp-операторе}
        \end{scnreltoset}
    \end{scnindent}
\end{scnreltoset}
\end{SCn}

Алгоритм работы \textit{Абстрактного sc-агента верификации scp-программ} сводится к поиску некорректностей в рамках \textit{scp-программы} на основе определений, соответствующих различным классам таких некорректностей, а также посредством запуска соответствующих данным классам некорректностей \textit{scp-программ поиска некорректности в scp-программе*}.

Результатом работы \textit{Абстрактного sc-агента верификации scp-программ} является формирование в \textit{sc-памяти структур}, описывающих некорректности в исследуемой \textit{scp-программе}, если таковые имеются.

Единственным аргументом класса действий, соответствующего \textit{Абстрактному sc-агенту верификации scp-программ}, является знак верифицируемой \textit{scp-программы}.

Классы действий, соответствующие \textit{Абстрактному sc-агенту запуска заданной scp-программы для заданного множества входных данных} и \textit{Абстрактному sc-агенту запуска заданной scp-программы для заданного множества входных данных в режиме пошагового выполнения}, имеют два аргумента. Первый аргумент является знаком запускаемой scp-программы, второй -- знаком связки, в которую под соответствующими атрибутами входят sc-элементы, которые станут аргументами соответствующего scp-процесса.

В режиме пошагового выполнения предполагается, что на каждом шаге инициируется выполнение всех scp-операторов в рамках заданного \mbox{scp-процесса}, для которых предыдущий scp-оператор стал прошлой сущностью (выполнился). В свою очередь, шаг заканчивается, когда все инициированные таким образом операторы закончат выполнение. Таким образом, в случае, если в рамках scp-программы есть параллельные ветви, то на одном шаге могут одновременно инициироваться два и более scp-оператора.

Классы действий, соответствующие \textit{Абстрактному sc-агенту добавления точки останова в scp-программу, Абстрактному sc-агенту удаления точки останова из scp-программы, Абстрактному sc-агенту добавления точки останова в scp-процесс} и \textit{Абстрактному sc-агенту удаления точки останова из scp-процесса}, имеют два аргумента. Первый аргумент является знаком \mbox{scp-программы} или scp-процесса соответственно, второй -- знаком \mbox{scp-оператора}, входящего в состав этой scp-программы или scp-процесса.

Единственным аргументом классов действий, соответствующих \textit{Абстрактному sc-агенту поиска всех точек останова в рамках scp-процесса, Абстрактному sc-агенту продолжения выполнения scp-процесса на один шаг, Абстрактному sc-агенту продолжения выполнения scp-процесса до точки останова или завершения} и \textit{Абстрактному sc-агенту просмотра информации об scp-процессе}, является знак scp-процесса, с которым будет выполнено соответствующее действие.

Единственным аргументом класса действий, соответствующего \textit{Абстрактному sc-агенту поиска всех scp-операторов в рамках scp-программы}, является знак этой scp-программы.

Единственным аргументом класса действий, соответствующего \textit{Абстрактному sc-агенту просмотра информации об scp-операторе}, является знак scp-оператора, входящего в состав некоторого scp-процесса. Результатом работы данного агента является структура, описывающая значения операндов данного scp-оператора, его атомарный тип и другую служебную информацию, полезную для разработчика.

\subsection{Семантическая модель пользовательского интерфейса системы автоматизации проектирования решателей задач}

Пользовательский интерфейс системы автоматизации проектирования решателей задач представлен набором интерфейсных команд, позволяющих пользователю инициировать деятельность нужного агента, входящего в состав этой системы.

\begin{SCn}
\scnheader{команда пользовательского интерфейса системы автоматизации проектирования решателей задач}
\begin{scnreltoset}{разбиение}
    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования агентов обработки знаний}
    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования программ языка SCP}
\end{scnreltoset}

\scnheader{команда пользовательского интерфейса системы автоматизации проектирования агентов обработки знаний}
\begin{scnreltoset}{разбиение}
    \scnitem{команда верификации sc-агентов}
    \begin{scnindent}
        \begin{scnreltoset}{разбиение}
            \scnitem{команда верификации спецификации sc-агента}
            \scnitem{команда верификации неатомарного sc-агента на непротиворечивость его спецификации спецификациям более частных sc-агентов в его составе}
        \end{scnreltoset}
    \end{scnindent}
    \scnitem{команда отладки коллективов sc-агентов}
    \begin{scnindent}
        \begin{scnreltoset}{разбиение}
            \scnitem{команда поиска всех выполняющихся процессов, соответствующих заданному sc-агенту}
            \scnitem{команда инициирования заданного sc-агента на заданных аргументах}
            \scnitem{команда активации заданного sc-агента}
            \scnitem{команда деактивации заданного sc-агента}
            \scnitem{команда установки блокировки заданного типа для заданного процесса на заданный sc-элемент}
            \scnitem{команда снятия всех блокировок заданного процесса}
            \scnitem{команда снятия всех блокировок с заданного sc-элемента}
        \end{scnreltoset}
    \end{scnindent}
\end{scnreltoset}

\scnheader{команда пользовательского интерфейса системы автоматизации проектирования scp-программ}
\begin{scnreltoset}{разбиение}
    \scnitem{команда верификации scp-программ}
    \scnitem{команда отладки scp-программ}
    \begin{scnindent}
        \begin{scnreltoset}{разбиение}
            \scnitem{команда запуска заданной scp-программы для заданного множества входных данных}
            \scnitem{команда запуска заданной scp-программы для заданного множества входных данных в режиме пошагового выполнения}
            \scnitem{команда поиска всех scp-операторов в рамках scp-программы}
            \scnitem{команда поиска всех точек останова в рамках scp-процесса}
            \scnitem{команда добавления точки останова в scp-программу}
            \scnitem{команда удаления точки останова из scp-программы}
            \scnitem{команда добавления точки останова в scp-процесс}
            \scnitem{команда удаления точки останова из scp-процесса}
            \scnitem{команда продолжения выполнения scp-процесса на один шаг}
            \scnitem{команда продолжения выполнения scp-процесса до точки останова или завершения}
            \scnitem{команда просмотра информации об scp-процессе}
            \scnitem{команда просмотра информации об scp-операторе}
        \end{scnreltoset}
    \end{scnindent}
\end{scnreltoset}

\end{SCn}

% \section{Логико-семантическая модель ostis-системы автоматизации проектирования программ Базового языка программирования ostis-систем}
% \section{Логико-семантическая модель ostis-системы автоматизации проектирования внутренних агентов ostis-систем, а также коллективов таких агентов}
\section{Многократно используемые компоненты решателей задач ostis-систем}

Рассмотрим классификацию многократно используемых компонентов решателей задач ostis-систем.

\begin{SCn}
\scnheader{многократно используемый компонент решателей задач}
\scnsuperset{программа}
\scnsuperset{пакет программ}
\scnsuperset{абстрактный sc-агент}
\scnsuperset{решатель задач ostis-системы}
\begin{scnindent}
    \scnnote{Целые решатели задач могут быть многократно используемыми компонентами в случае разработки интеллектуальных систем, назначение которых совпадает.}
\end{scnindent}

\scnheader{метод}
\scnidtf{программа}
\scnsuperset{программа на основе нейросетевых моделей}
\scnsuperset{программа на основе генетических алгоритмов}
\scnsuperset{императивная программа}
\begin{scnindent}
    \scnsuperset{процедурная программа}
    \scnsuperset{объектно-ориентированная программа}
\end{scnindent}
\scnsuperset{декларативная программа}
\begin{scnindent}
    \scnsuperset{логическая программа}
    \scnsuperset{функциональная программа}
\end{scnindent}
\scnsuperset{программа sc-агента}

\scnheader{абстрактный sc-агент}
\begin{scnsubdividing}
    \scnitem{неатомарный абстрактный sc-агент}
    \scnitem{атомарный абстрактный sc-агент}
\end{scnsubdividing}
\begin{scnsubdividing}
    \scnitem{внутренний абстрактный sc-агент}
    \scnitem{эффекторный абстрактный sc-агент}
    \scnitem{рецепторный абстрактный sc-агент}
\end{scnsubdividing}
\begin{scnsubdividing}
    \scnitem{абстрактный sc-агент, не реализуемый на Языке SCP}
    \scnitem{абстрактный sc-агент, реализуемый на Языке SCP}
\end{scnsubdividing}
\begin{scnsubdividing}
    \scnitem{абстрактный sc-агент интерпретации scp-программ}
    \scnitem{абстрактный программный sc-агент}
    \scnitem{абстрактный sc-метаагент}
\end{scnsubdividing}
\begin{scnsubdividing}
    \scnitem{платформенно-зависимый абстрактный sc-агент}
    \begin{scnindent}
        \scnsuperset{абстрактный sc-агент, не реализуемый на Языке SCP}
    \end{scnindent}
    \scnitem{платформенно-независимый абстрактный sc-агент}
\end{scnsubdividing}

\scnheader{решатель задач ostis-системы}
\scnsuperset{решатель задач с использованием хранимых методов}
\begin{scnindent}
    \scnsuperset{решатель задач на основе нейросетевых моделей}
    \scnsuperset{решатель задач на основе генетических алгоритмов}
    \scnsuperset{решатель задач на основе императивных программ}
    \begin{scnindent}
        \scnsuperset{решатель задач на основе процедурных программ}
        \scnsuperset{решатель задач на основе объектно-ориентированных программ}
    \end{scnindent}
    \scnsuperset{решатель задач на основе декларативных программ}
    \begin{scnindent}
        \scnsuperset{решатель задач на основе логических программ}
        \scnsuperset{решатель задач на основе функциональных программ}
    \end{scnindent}
\end{scnindent}
\scnsuperset{решатель задач в условиях, когда метод решения задач данного класса в текущий момент времени не известен}
\begin{scnindent}
    \scnsuperset{решатель, реализующий стратегию поиска путей решения задачи в глубину}
    \scnsuperset{решатель, реализующий стратегию поиска путей решения задачи в ширину}
    \scnsuperset{решатель, реализующий стратегию проб и ошибок}
    \scnsuperset{решатель, реализующий стратегию разбиения задачи на подзадачи}
    \scnsuperset{решатель, реализующий стратегию решения задач по аналогии}
    \scnsuperset{решатель, реализующий концепцию интеллектуального пакета программ}
\end{scnindent}
% \scnsuperset{машина информационного поиска}
% \begin{scnindent}
%     \scnsuperset{машина информационного поиска информации, удовлетворяющей заданной спецификации}
%     \scnsuperset{машина информационного поиска информации, не удовлетворяющей заданной спецификации}
%     \scnsuperset{машина, выявляющая отсутствие информации, удовлетворяющей заданной спецификации}
% \end{scnindent}
% \scnsuperset{решатель явно сформулированных задач}
% \begin{scnindent}
%     \scnsuperset{машина поиска значений заданного множества величин}
%     \scnsuperset{машина установления истинности заданного логического высказывания в рамках заданной формальной теории}
%     \scnsuperset{машина формирования способа решения указанной задачи}
%     \begin{scnindent}
%         \scnsuperset{машина формирования доказательства заданного высказывания в рамках заданной формальной теории}
%     \end{scnindent}
%     \scnsuperset{машина верификации ответа на указанную задачу}
%     \scnsuperset{машина верификации способа решения указанной задачи}
%     \begin{scnindent}
%         \scnsuperset{машина верификации доказательства заданного высказывания в рамках заданной формальной теории}
%     \end{scnindent}
% \end{scnindent}
% \scnsuperset{машина классификации сущностей}
% \begin{scnindent}
%     \scnsuperset{машина соотнесения сущности с одним из заданного множества классов}
%     \scnsuperset{машина разделения множества сущностей на классы по заданному множеству признаков}
% \end{scnindent}
% \scnsuperset{машина синтеза естественно-языковых текстов}
% \scnsuperset{машина анализа естественно-языковых текстов}
% \begin{scnindent}
%     \scnsuperset{машина распознавания естественно-языковых текстов}
%     \scnsuperset{машина верификации естественно-языковых текстов}
% \end{scnindent}
% \scnsuperset{машина синтеза сигналов}
% \begin{scnindent}
%     \scnsuperset{машина синтеза речи}
% \end{scnindent}
% \scnsuperset{машина анализа сигналов}
% \begin{scnindent}
%     \scnsuperset{машина анализа речи}
%     \begin{scnindent}
%         \scnsuperset{машина распознавания речи}
%     \end{scnindent}
% \end{scnindent}
% \scnsuperset{машина обработки мультимедийных данных}
% \begin{scnindent}
%     \scnsuperset{машина анализа изображений}
%     \begin{scnindent}
%         \scnsuperset{машина распознавания изображений}
%     \end{scnindent}
% \end{scnindent}
% \scnsuperset{решатель задач IMS}
% \scnsuperset{решатель задач вспомогательной компьютерной системы}
% \begin{scnindent}
%     \scnsuperset{решатель задач интерфейса компьютерной системы}
%     \begin{scnindent}
%         \scnsuperset{решатель задач пользовательского интерфейса компьютерной системы}
%         \scnsuperset{решатель задач интерфейса компьютерной системы с другими компьютерными системами}
%         \scnsuperset{решатель задач интерфейса компьютерной системы с окружающей средой}
%     \end{scnindent}
%     \scnsuperset{решатель задач подсистемы поддержки проектирования компонентов определенного класса}
%     \begin{scnindent}
%         \scnsuperset{решатель задач подсистемы поддержки проектирования баз знаний}
%         \begin{scnindent}
%             \scnsuperset{машина повышения качества базы знаний}
%             \begin{scnindent}
%                 \scnsuperset{машина верификации базы знаний}
%                 \begin{scnindent}
%                     \scnsuperset{машина поиска и устранения некорректностей}
%                     \scnsuperset{машина поиска и устранения неполноты}
%                 \end{scnindent}
%                 \scnsuperset{машина оптимизации базы знаний}
%                 \scnsuperset{машина выявления и устранения информационного мусора}
%             \end{scnindent}
%         \end{scnindent}
%         \scnsuperset{решатель задач подсистемы поддержки проектирования решателей}
%         \begin{scnindent}
%             \scnsuperset{решатель задач подсистемы поддержки проектирования программ обработки знаний}
%             \scnsuperset{решатель задач подсистемы поддержки проектирования агентов обработки знаний}
%         \end{scnindent}
%     \end{scnindent}
%     \scnsuperset{решатель задач подсистемы управления проектирования компьютерных систем и их компонентов}
% \end{scnindent}
% \scnsuperset{решатель задач самостоятельной компьютерной системы}
\end{SCn}

Рассмотрим отношения необходимые для спецификации многократно используемого компонента решателя задач, его поиска и установки в дочернюю ostis-систему.

\begin{SCn}
\scnheader{отношение, специфицирующее многократно используемый компонент решателей задач ostis-систем}
\scnsubset{отношение, специфицирующее многократно используемый компонент ostis-систем}
\scnhaselement{первичное условие инициирования*}
\begin{scnindent}
    \scnexplanation{Связки отношения первичное условие инициирования* связывают между собой sc-узел, обозначающий абстрактный sc-агент и бинарную ориентированную пару, описывающую первичное условие инициирования данного абстрактного sc-агента, т.е. такой ситуации в sc-памяти, которая побуждает sc-агента перейти в активное состояние и начать проверку наличия своего полного условия инициирования.
    
    Первым компонентом данной ориентированной пары является знак некоторого подмножества понятия событие, например событие добавления выходящей sc-дуги, т.е. по сути конкретный тип события в sc-памяти.
    
    Вторым компонентом данной ориентированной пары является произвольный в общем случае sc-элемент, с которым непосредственно связан указанный тип события в sc-памяти, т.е., например, sc-элемент, из которого выходит либо в который входит генерируемая либо удаляемая sc-дуга, либо sc-ссылка, содержимое которой было изменено.
    
    После того, как в sc-памяти происходит некоторое событие, активизируются все активные sc-агенты, первичное условие инициирования* которых соответствует произошедшему событию.}
    \scnrelfrom{первый домен}{абстрактный sc-агент}
    \scnrelfrom{второй домен}{бинарная ориентированная пара}
\end{scnindent}
\scnhaselement{условие инициирования и результат*}
\begin{scnindent}
    \scnexplanation{Связки отношения условие инициирования и результат* связывают между собой sc-узел, обозначающий абстрактный sc-агент и бинарную ориентированную пару, связывающую условие инициирования данного абстрактного sc-агента и результаты выполнения данного экземпляров данного sc-агента в какой-либо конкретной системе.
    
    Указанную ориентированную пару можно рассматривать как логическую связку импликации, при этом на sc-переменные, присутствующие в обеих частях связки, неявно накладывается квантор всеобщности, на sc-переменные, присутствующие либо только в посылке, либо только в заключении неявно накладывается квантор существования.
    
    Первым компонентом указанной ориентированной пары является логическая формула, описывающая условие инициирования описываемого абстрактного sc-агента, то есть конструкции, наличие которой в sc-памяти побуждает sc-агент начать работу по изменению состояния sc-памяти. Данная логическая формула может быть как атомарной, так и неатомарной, в которой допускается использование любых связок логического языка.
    
    Вторым компонентом указанной ориентированной пары является логическая формула, описывающая возможные результаты выполнения описываемого абстрактного sc-агента, то есть описание произведенных им изменений состояния sc-памяти. Данная логическая формула может быть как атомарной, так и неатомарной, в которой допускается использование любых связок логического языка.}
    \scnrelfrom{первый домен}{абстрактный sc-агент}
    \scnrelfrom{второй домен}{бинарная ориентированная пара}
\end{scnindent}
\scnhaselement{эквивалентный компонент*}
\begin{scnindent}
    \scnhaselement{неориентированное отношение}
    \scnexplanation{Бинарное отношение связывающее функционально эквивалентные многократно используемые компоненты решателей задач.}
    \scnrelfrom{первый домен}{многократно используемый компонент решателей задач}
    \scnrelfrom{второй домен}{многократно используемый компонент решателей задач}
\end{scnindent}
\end{SCn}

% \section{Многократно используемые методы, хранимые в памяти ostis-систем и интерпретируемые их внутренними агентами}

\section{Многократно используемые внутренние агенты ostis-систем}

\begin{SCn}
\scnheader{внутренний абстрактный sc-агент}
\scnexplanation{Каждый \textbf{\textit{внутренний абстрактный sc-агент}} обозначает класс \textit{sc-агентов}, которые реагируют на события в \textit{sc-памяти} и осуществляют преобразования исключительно в рамках этой же \textit{sc-памяти}.}

% \scnheader{многократно используемый внутренний агент ostis-системы}
% \scnidtf{внутренний абстрактный sc-агент, являющийся многократно используемым компонентом ostis-системы}
\end{SCn}

%\input{author/references}