\chapter{Методика и средства компонентного проектирования решателей задач ostis-систем}
\chapauthortoc{Шункевич Д.В.\\Марковец В.С.}
\label{chapter_ps_design}

\vspace{-7\baselineskip}

\begin{SCn}

\begin{scnrelfromlist}{автор}
	\scnitem{Шункевич Д.~В.}
	\scnitem{Марковец В.~С.}	
\end{scnrelfromlist}

\bigskip

\abstract{В главе рассматривается методика построения и модификации \textit{решателей задач} \textit{ostis-систем}, модель системы автоматизации проектирования \textit{решателей задач}, а также принципы организации \textit{библиотеки многократно используемых компонентов решателей задач ostis-систем}.}

\bigskip

\begin{scnrelfromlist}{подраздел}
    \scnitem{\ref{sec_ps_design_methodology}~\nameref{sec_ps_design_methodology}}
    \scnitem{\ref{sec_auto_sys_for_des_ps}~\nameref{sec_auto_sys_for_des_ps}}
    \scnitem{\ref{sec_ps_components}~\nameref{sec_ps_components}}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Методика построения и модификации машины обработки знаний ostis-систем}
	\scnitem{Система автоматизации проектирования решателей задач ostis-систем}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{ключевое понятие}
    \scnitem{решатель задач ostis-системы}
%    \scnitem{sc-агент}
%    \scnitem{scp-программа}
%    \scnitem{база знаний}
%    \scnitem{точка останова*}
    \scnitem{точка останова}
%    \scnitem{некорректность в scp-программе*}
    \scnitem{некорректность в scp-программе}
    \scnitem{ошибка в scp-программе}
%    \scnitem{Метасистема OSTIS}
%    \scnitem{библиотека многократно используемых компонентов ostis-систем}
%    \scnitem{Решатель задач системы автоматизации проектирования агентов обработки знаний}
%    \scnitem{Решатель задач системы автоматизации проектирования scp-программ}
%    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования решателей задач ostis-систем}
%    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования агентов обработки знаний}
%    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования scp-программ}
%    \scnitem{библиотека многократно используемых компонентов решателей задач}
    \scnitem{многократно используемый компонент решателей задач}
%    \scnitem{метод}
%    \scnitem{Средства автоматизации библиотеки многократно используемых компонентов решателей задач}
%    \scnitem{отношение, специфицирующее многократно используемый компонент решателей задач ostis-систем}
%    \scnitem{Решатель задач библиотеки многократно используемых компонентов решателей задач}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{библиографическая ссылка}
	\scnitem{\scncite{Shunkevich2013}}
	\scnitem{\scncite{Shunkevich2015}}
	\scnitem{\scncite{Shunkevich2015a}}
	\scnitem{\scncite{Golenkov2015}}
	\scnitem{\scncite{Shunkevich2018}}
	\scnitem{\scncite{Borisov2014}}
	\scnitem{\scncite{Gribova2015a}}
\end{scnrelfromlist}
\end{SCn}

\section*{Введение в Главу \ref{chapter_ps_design}}

В области разработки \textit{решателей задач} существует большое количество конкретных реализаций, однако вопросы совместимости различных решателей задачи и их компонентов практически не рассматриваются. Гипотетически возможно существование универсального решателя задач, объединяющего в себе все известные способы и методы решения задач. Однако использование такого решателя в прикладных целях не является целесообразным. Таким образом, наиболее приемлемым вариантом становится создание библиотеки совместимых между собой компонентов (см. \textit{\ref{ostis_library_section}~\nameref{ostis_library_section}}), из которых впоследствии может быть собран решатель, удовлетворяющий необходимым требованиям.

Как показано в \textit{Главе \ref{chapter_situation_management} \nameref{chapter_situation_management}}, \textit{решатель задач ostis-системы} представляет собой иерархическую систему \textit{навыков}, которыми владеет ostis-система на текущий момент. В свою очередь, \textit{навык} представляет собой некоторый \textit{метод} решения задач заданного класса и соответствующую ему систему \textit{sc-агентов} (\textit{машину обработки знаний} частного вида), обеспечивающих интерпретацию данного метода. В связи с этим методика проектирования решателей задач ostis-систем фактически сводится к методике проектирования баз знаний ostis-систем (см. \textit{Главу \ref{chapter_kb_design}~\nameref{chapter_kb_design}}) и методике проектирования машин обработки знаний ostis-систем, которая детально рассматривается в данной главе.

Вопросам разработки \textit{решателей задач ostis-систем} посвящен ряд работ, таких как 
\scncite{Shunkevich2013}, \scncite{Shunkevich2015}, \scncite{Golenkov2015}, \scncite{Shunkevich2015a}, \scncite{Shunkevich2018}. Среди других известных работ, посвященных вопросам компонентного проектирования решателей задач в целом, стоит отметить работы \scncite{Borisov2014}, \scncite{Gribova2015a}, в которых, однако, не уделяется внимание разработке комплексной методики проектирования решателей задач, которой посвящена данная глава.

\section{Действия и методики проектирования решателей задач ostis-систем}
\label{sec_ps_design_methodology}
\begin{SCn}
\bigskip

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Методика построения и модификации машины обработки знаний ostis-систем}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{ключевое понятие}
    \scnitem{решатель задач ostis-системы}
    \scnitem{sc-агент}
    \scnitem{scp-программа}
\end{scnrelfromlist}

\end{SCn}

Основу любого решателя задач составляет система sc-агентов, то есть \textit{машина обработки знаний ostis-системы}, в связи с этим целесообразно рассмотреть более детально процесс проектирования \textit{машин обработки знаний ostis-систем}. Приведенная методика разработана с учетом того, что каждая \textit{машина обработки знаний ostis-систем} представляет собой иерархический коллектив sc-агентов.

Построение же общей методики проектирования решателей задач ostis-систем требует также уточнения принципов разработки \textit{методов} решения задач, которые, в свою очередь, тесно пересекаются с общими принципами разработки баз знаний ostis-систем (см. \textit{Главу \ref{chapter_kb_design} \nameref{chapter_kb_design}}). Рассмотрим более подробно \textit{Методику построения и модификации машин обработки знаний ostis-систем}.

\textit{Методика построения и модификации машин обработки знаний ostis-систем} включает несколько этапов:
\begin{textitemize}
    \item формирование требований к машине обработки знаний и ее формальная спецификация;
    \item формирование коллектива sc-агентов, входящих в состав разрабатываемой машины;
    \item разработка алгоритмов атомарных sc-агентов;
    \item реализация программ sc-агентов;
    \item верификация разработанных компонентов;
    \item отладка разработанных компонентов, исправление ошибок.
\end{textitemize}

Предлагаемая методика может быть применена как при разработке \textit{машины обработки знаний} объединенных \textit{решателей задач}, так и при разработке \textit{машины обработки знаний} \textit{решателей задач} частного вида, поскольку с формальной точки зрения все такие машины трактуются как \textit{неатомарные абстрактные sc-агенты}.

\textbf{Этап 1. Формирование требований к машине обработки знаний и ее формальная спецификация}

На данном этапе необходимо:
\begin{textitemize}
\item четко выделить задачи, решение которых должен обеспечивать \textit{решатель задач};
\item продумать предполагаемые способы их решения и на основе данного анализа определить место будущей машины обработки знаний \textit{решателя задач} в общей иерархии \textit{решателей задач}.
\end{textitemize}

Важность данного этапа заключается в том, что при правильной классификации существует вероятность того, что в составе \textit{библиотеки многократно используемых компонентов решателей задач ostis-систем} уже есть реализованный вариант требуемой машины обработки знаний. В противном случае, у разработчика появляется возможность включить разработанную машину в \textit{библиотеку многократно используемых компонентов решателей задач ostis-систем} для последующего использования. Данные факты обусловлены тем, что структура \textit{библиотеки многократно используемых компонентов решателей задач ostis-систем} основана на семантической классификации \textit{решателей задач} и, соответственно, их компонентов.

При недостаточно четкой спецификации и классификации разрабатываемого \textit{решателя задач} повышается вероятность того, что подходящая машина обработки знаний не будет найдена в библиотеке компонентов даже в случае, если она там есть, а вновь разработанный \textit{решатель задач} не сможет быть включен в библиотеку. Таким образом, принцип многократного использования уже разработанных компонентов будет нарушен, что существенно повысит затраты на разработку.

\textbf{Этап 2. Формирование коллектива sc-агентов, входящих в состав разрабатываемой машины обработки знаний}

В случае, когда найти в библиотеке готовую машину обработки знаний, удовлетворяющую всем предъявляемым требованиям, не удалось, необходимо выделить (то есть собственно определить множество требуемых компонентов) и специфицировать все ее компоненты.

Результатом данного этапа является перечень полностью специфицированных \textit{абстрактных sc-агентов}, которые войдут в состав разрабатываемой машины обработки знаний, с их иерархией вплоть до \textit{атомарных абстрактных sc-агентов}. В рамках данного этапа очень важно проектировать коллектив агентов таким образом, чтобы максимально задействовать уже имеющиеся в библиотеке многократно используемые компоненты ostis-систем, а при отсутствии нужного компонента --- иметь возможность включить его в библиотеку после реализации.

При разработке перечня sc-агентов (в том числе их спецификаций) необходимо соблюдать ряд принципов:

\begin{textitemize}
\item каждый разрабатываемый sc-агент должен быть, по возможности, предметно независим, то есть во множество ключевых узлов данного sc-агента не должны входить понятия, имеющие отношение непосредственно к рассматриваемой предметной области. Исключение составляют понятия из общих предметных областей, которые носят междисциплинарный характер (например, отношение \textit{включение*} или понятие \textit{действие}, см. \textit{Главу \ref{chapter_top_ontologies} \nameref{chapter_top_ontologies}}). Данное правило также может быть нарушено в случае, если sc-агент является вспомогательным и ориентирован на обработку какого-либо конкретного класса объектов (например, sc-агенты, выполняющие арифметические вычисления, могут напрямую работать с конкретными отношениями \textit{сложение*} и \textit{умножение*} и тому подобное). Всю необходимую для решения задачи информацию sc-агент должен извлекать из семантической окрестности соответствующего инициированного действия. Разработанный с учетом указанных требований sc-агент может быть использован при проектировании большего числа ostis-систем, чем в случае, если бы он был реализован с ориентацией на конкретную предметную область. После завершения разработки и отладки такой sc-агент должен быть включен в \textit{библиотеку многократно используемых абстрактных sc-агентов}, которая входит в состав \textit{библиотеки многократно используемых компонентов решателей задач ostis-систем};
\item не стоит путать понятия sc-агент и \textit{агентная программа} (в том числе \textit{агентная scp-программа}). Взаимодействие sc-агентов осуществляется исключительно посредством спецификации информационных процессов в общей памяти, каждый sc-агент реагирует на некоторый класс событий в sc-памяти. Таким образом, каждому sc-агенту соответствует некоторое условие инициирования и одна агентная программа, которая запускается автоматически при возникновении в sc-памяти соответствующего условия инициирования. При этом в рамках данной программы могут сколько угодно раз вызываться различные подпрограммы. Однако не стоит путать инициирование sc-агента, которое осуществляется при появлении в sc-памяти соответствующей конструкции, и вызов подпрограммы другой программой, который предполагает явное указание вызываемой подпрограммы и перечня ее параметров;
\item каждый sc-агент должен самостоятельно проверять полноту соответствия своего условия инициирования текущему состоянию sc-памяти. В процессе решения какой-либо задачи может возникнуть ситуация, когда на появление одной и той же структуры среагировали несколько sc-агентов. В таком случае выполнение продолжают только те из них, условие инициирования которых полностью соответствует сложившейся ситуации. Остальные sc-агенты в данном случае прекращают выполнение и возвращаются в режим ожидания. Выполнение данного принципа достигается за счет тщательного уточнения спецификаций разрабатываемых sc-агентов. В общем случае условия инициирования у нескольких sc-агентов могут совпадать, например, в случае, когда одна и та же задача может быть решена разными способами и заранее неизвестно, какой из них приведет к желаемому результату;
% нужен наглядный пример
\item необходимо помнить, что неатомарный sc-агент с точки зрения других sc-агентов, не входящих в его состав, должен функционировать как целостный sc-агент (выполнять логически атомарные действия), что накладывает определенные требования на спецификации атомарных sc-агентов, входящих в его состав: как минимум, необходимо, чтобы в составе неатомарного sc-агента присутствовал хотя бы один атомарный sc-агент, условие инициирования которого полностью совпадает с условием инициирования данного неатомарного sc-агента;
\item при необходимости реализации нового sc-агента следует руководствоваться следующими принципами выделения атомарных абстрактных \textit{sc-агентов}:

\begin{textitemize}
    \item проектируемый sc-агент должен быть максимально независим от предметной области, что позволит в дальнейшем использовать его при разработке \textit{решателей задач} максимально возможного числа ostis-систем. При этом универсальность предполагает не только минимизацию числа ключевых узлов sc-агента, но и выделение класса действий, выполняемых данным sc-агентом таким образом, чтобы имело смысл включить данный sc-агент в \textit{библиотеку многократно используемых абстрактных sc-агентов} и использовать его при разработке \textit{решателей задач} других ostis-систем. Не следует искусственно увязывать ряд действий в один sc-агент и, наоборот, расчленять одно самодостаточное действие на поддействия: это вызовет сложности восприятия принципов работы sc-агента разработчиками и не позволит использовать sc-агент в ряде систем (например, в обучающих системах, которые должны объяснять ход решения пользователю, см. \textit{Главу \ref{chapter_learning_systems} \nameref{chapter_learning_systems}});
    \item выполняемое данным sc-агентом действие должно быть логически целостным и завершенным. Следует помнить, что все sc-агенты взаимодействуют исключительно через общую sc-память, и избегать ситуаций, в которых инициирование одного sc-агента осуществляется путем явной генерации известного условия инициирования другим \textit{sc-агентом} (то есть, по сути, явным непосредственным вызовом одного sc-агента другим);
    \item имеет смысл выделять в отдельные sc-агенты относительно крупные фрагменты реализации некоторого общего алгоритма, которые могут выполняться независимо друг от друга.
\end{textitemize}

\item при объединении sc-агентов в коллективы рекомендуется проектировать их таким образом, чтобы они могли быть использованы не только как часть рассматриваемого \textit{неатомарного абстрактного sc-агента}. В случае, если это не представляется возможным и некоторые sc-агенты, будучи отделенными от коллектива, теряют \textit{смысл}, необходимо указать данный факт при документировании рассматриваемых sc-агентов;
\item фактическим инициатором запуска sc-агента посредством общей памяти (автором соответствующей конструкции) может быть как непосредственно пользователь системы, так и другой sc-агент, что никак не должно отражаться в работе самого sc-агента.
\end{textitemize}

\textbf{Этап 3. Разработка алгоритмов атомарных sc-агентов}

В рамках данного этапа необходимо продумать алгоритм работы каждого разрабатываемого \textit{атомарного sc-агента}. Разработка алгоритма подразумевает выделение в нем логически целостных фрагментов, которые могут быть реализованы как отдельные \textit{scp-программы}, в том числе выполняемые параллельно. Таким образом, появляется необходимость говорить не только о \textit{библиотеке многократно используемых абстрактных sc-агентов}, но и о \textit{библиотеке многократно используемых программ обработки sc-текстов} на различных языках программирования, в том числе \textit{библиотеке многократно используемых scp-программ}. Благодаря этому часть scp-программ, реализующих алгоритм работы некоторого sc-агента, может быть заимствована из соответствующей библиотеки.

Важно помнить, что если в процессе работы \textit{sc-агент} генерирует в памяти какие-либо временные структуры, то при завершении работы он обязан удалять всю информацию, использование которой в системе более нецелесообразно (убрать за собой информационный мусор). Исключение составляют ситуации, когда подобная информация необходима нескольким \textit{sc-агентам} для решения одной задачи, однако после решения задачи информация становится бесполезной или избыточной и требует удаления. В данном случае может возникнуть ситуация, когда ни один из \textit{sc-агентов} не в состоянии удалить информационный мусор. В таком случае возникает необходимость говорить о включении в состав \textit{решателя задач} специализированных \textit{sc-агентов}, задачей которых является выявление и уничтожение информационного мусора.

\textbf{Этап 4. Реализация программ агентов}

Конечным этапом непосредственно разработки является реализация специфицированных ранее \textit{scp-программ} или при необходимости программ, реализуемых на уровне \textit{ostis-платформы}.

\textbf{Этап 5. Верификация разработанных компонентов}

Верификация разработанных компонентов может осуществляться как вручную, так и с использованием специфицированных средств, входящих в состав системы автоматизации проектирования \textit{решателей задач} \textit{ostis-систем}.

\textbf{Этап 6. Отладка разработанных компонентов. Исправление ошибок}

Этап отладки разработанных компонентов, в свою очередь, можно также условно разделить на более частные этапы:

\begin{textitemize}
    \item отладка отдельных scp-программ или программ, реализуемых на уровне платформы;
    \item отладка отдельных атомарных sc-агентов;
    \item отладка неатомарных sc-агентов, входящих в состав машины обработки знаний;
    \item отладка всей машины обработки знаний.
\end{textitemize}

\textbf{Этап 5} и \textbf{Этап 6} могут выполняться параллельно и повторяются до тех пор, пока разработанные компоненты не будут удовлетворять необходимым требованиям.

\textit{Методика построения и модификации машин обработки знаний ostis-систем} основана на онтологии деятельности разработчиков машин обработки знаний.

Каждый \textit{решатель задач ostis-системы} представляет собой совокупность навыков, а машина обработки знаний --- совокупность интерпретаторов навыков, составляющих некоторый \textit{решатель задач ostis-системы}, то есть его операционную семантику. Таким образом \textit{машина обработки знаний} представляет собой \textit{абстрактный sc-агент}, в связи с чем разработка машины сводится к разработке такого агента.

Рассмотрим фрагмент онтологии деятельности, направленной на построение и модификацию машин обработки знаний, записанный в \textit{SCn-коде}:

\begin{SCn}
\scnheader{действие. разработать машину обработки знаний ostis-системы}
\scnsubset{действие. разработать абстрактный sc-агент}
\begin{scnrelfromset}{разбиение}
\scnitem{действие. разработать атомарный абстрактный sc-агент}
\begin{scnindent}
        \scnsuperset{действие. разработать платформенно-независимый атомарный абстрактный sc-агент}
\end{scnindent}
\scnitem{действие. разработать неатомарный абстрактный sc-агент}
\end{scnrelfromset}
\begin{scnrelfromlist}{обобщенное поддействие}
    \scnitem{действие. специфицировать абстрактный sc-агент}
    \scnitem{действие. найти в библиотеке абстрактный sc-агент, удовлетворяющий заданной спецификации}
    \scnitem{действие. верифицировать sc-агент}
    \scnitem{действие. отладить sc-агент}
\end{scnrelfromlist}

\scnheader{действие. разработать платформенно-независимый атомарный абстрактный sc-агент}
\begin{scnrelfromlist}{обобщенное поддействие}
    \scnitem{действие. декомпозировать платформенно-независимый атомарный абстрактный sc-агент на scp-программы}
    \scnitem{действие. разработать scp-программу}
\end{scnrelfromlist}

\scnheader{действие. разработать неатомарный абстрактный sc-агент}
\begin{scnrelfromlist}{обобщенное поддействие}
    \scnitem{действие. декомпозировать неатомарный абстрактный sc-агент}
    \scnitem{действие. разработать абстрактный sc-агент}
\end{scnrelfromlist}

\scnheader{действие. разработать scp-программу}
\begin{scnrelfromlist}{обобщенное поддействие}
    \scnitem{действие. специфицировать scp-программу}
    \scnitem{действие. найти в библиотеке scp-программу, удовлетворяющую заданной спецификации}
    \scnitem{действие. реализовать специфицированную scp-программу}
    \scnitem{действие. верифицировать scp-программу}
    \scnitem{действие. отладить scp-программу}
\end{scnrelfromlist}

\scnheader{действие. верифицировать sc-агент}
\begin{scnrelfromset}{разбиение}
    \scnitem{действие. верифицировать атомарный sc-агент}
    \scnitem{действие. верифицировать неатомарный sc-агент}
\end{scnrelfromset}

\scnheader{действие. отладить sc-агент}
\begin{scnrelfromset}{разбиение}
    \scnitem{действие. отладить атомарный sc-агент}
    \scnitem{действие. отладить неатомарный sc-агент}
\end{scnrelfromset}
\end{SCn}

Наличие такой онтологии позволяет:
\begin{textitemize}
    \item частично автоматизировать процесс построения и модификации машины обработки знаний при помощи соответствующей \textit{Системы автоматизации проектирования решателей задач ostis-систем};
    \item повысить эффективность информационной поддержки разработчиков, поскольку данная онтология включена в базу знаний \textit{Метасистемы OSTIS}.
\end{textitemize}

\section{Логико-семантическая модель комплекса ostis-систем автоматизации проектирования решателей задач ostis-систем}
\begin{SCn}
\bigskip

\begin{scnrelfromlist}{ключевой знак}
    \scnitem{Метасистема OSTIS}
    \scnitem{Система автоматизации проектирования решателей задач ostis-систем}
    \scnitem{Решатель задач системы автоматизации проектирования агентов обработки знаний}
    \scnitem{Решатель задач системы автоматизации проектирования scp-программ}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{ключевое понятие}
    \scnitem{решатель задач ostis-системы}
    \scnitem{sc-агент}
    \scnitem{база знаний}
    \scnitem{scp-программа}
    \scnitem{точка останова*}
    \scnitem{точка останова}
    \scnitem{некорректность в scp-программе*}
    \scnitem{некорректность в scp-программе}
    \scnitem{ошибка в scp-программе}
    \scnitem{библиотека многократно используемых компонентов ostis-систем}
    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования решателей задач ostis-систем}
    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования агентов обработки знаний}
    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования scp-программ}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{подраздел}
    \scnitem{\ref{sub_sec_kb_ps_des_auto_sys}~\nameref{sub_sec_kb_ps_des_auto_sys}}
    \scnitem{\ref{sub_sec_ps_ps_des_auto_sys}~\nameref{sub_sec_ps_ps_des_auto_sys}}
    \scnitem{\ref{sub_sec_interface_ps_des_auto_sys}~\nameref{sub_sec_interface_ps_des_auto_sys}}
\end{scnrelfromlist}

\end{SCn}
\label{sec_auto_sys_for_des_ps}

К числу задач системы автоматизации проектирования \textit{решателей задач} \textit{ostis-систем} относится техническая поддержка разработчиков решателей, в том числе --- обеспечение корректного и эффективного выполнения этапов, предусмотренных \textit{Методикой проектирования машины обработки знаний ostis-систем}.

При разработке любых компонентов ostis-систем используются схожие принципы. Одним из основных принципов является принцип использования готовых компонентов различного рода, уже имеющихся в библиотеке многократно используемых компонентов ostis-систем, входящей в состав \textit{Метасистемы OSTIS}.

\textit{Система автоматизации проектирования решателей задач ostis-систем} сама по себе также является ostis-системой и имеет соответствующую структуру. Таким образом, модель данной системы включает \textit{sc-модель базы знаний}, \textit{sc-модель объединенного решателя задач} и \textit{sc-модель пользовательского интерфейса}.

В рамках данной системы условно выделяются две подсистемы -- подсистема автоматизации проектирования агентов обработки знаний (sc-агентов) и подсистема автоматизации проектирования scp-программ.

Cистема может использоваться тремя способами:
\begin{textitemize}
    \item Как подсистема в рамках \textit{Метасистемы OSTIS}. Данный вариант использования предполагает отладку необходимых компонентов в рамках \textit{Метасистемы OSTIS} с последующим переносом их в \textit{дочернюю ostis-систему} (см. \textit{\ref{ostis_library_section}~\nameref{ostis_library_section}}).
    \item Как самостоятельная ostis-система, предназначенная исключительно для разработки и отладки компонентов решателей задач. В этом случае проектируемые компоненты отлаживаются в рамках такой системы, а затем должны быть перенесены в дочернюю ostis-систему.
    \item Как подсистема в рамках дочерней ostis-системы. В таком варианте отладка компонентов осуществляется непосредственно в той же системе, в которой предполагается их использование, и дополнительного переноса не требуется.
\end{textitemize}

Независимо от выбранного способа использования системы, разработанные компоненты впоследствии могут быть включены в состав \textit{библиотеки многократно используемых компонентов ostis-систем}.

Выделяются два принципиально разных уровня отладки \textit{решателя задач}:
\begin{textitemize}
    \item отладка на уровне sc-агентов;
    \item отладка на уровне scp-программ.
\end{textitemize}

В случае отладки на уровне sc-агентов акт выполнения каждого агента считается неделимым и не может быть прерван. При этом может выполняться отладка как атомарных sc-агентов, так и неатомарных. Инициирование того или иного агента, в том числе входящего в состав неатомарного, осуществляется путем создания соответствующих конструкций в sc-памяти, таким образом, отладка может осуществляться на разных уровнях детализации агентов, вплоть до атомарных.

Система поддержки проектирования агентов может служить основой для моделирования систем агентов, использующих другие принципы коммуникации, например, непосредственный обмен сообщениями между агентами.

Отладка на уровне \textit{scp-программ} осуществляется аналогично существующим современным подходам к отладке процедурных программ и предполагает возможность установки точек останова, пошагового выполнения программы и так далее.

Система автоматизации проектирования \textit{решателей задач} и, соответственно, ее sc-модель, разделяется на две более частные:

\begin{SCn}
\scnheader{Система автоматизации проектирования решателей задач ostis-систем}
\begin{scnrelfromset}{базовая декомпозиция}
\scnitem{Система автоматизации проектирования агентов обработки знаний}
\begin{scnindent}
    \begin{scnrelfromset}{базовая декомпозиция}
        \scnitem{База знаний системы автоматизации проектирования агентов обработки знаний}
        \scnitem{Решатель задач системы автоматизации проектирования агентов обработки знаний}
        \scnitem{Пользовательский интерфейс системы автоматизации проектирования агентов обработки знаний}
    \end{scnrelfromset}
\end{scnindent}
\scnitem{Система автоматизации проектирования scp-программ}
\begin{scnindent}
    \begin{scnrelfromset}{базовая декомпозиция}
        \scnitem{База знаний системы автоматизации проектирования scp-программ}
        \scnitem{Решатель задач системы автоматизации проектирования scp-программ}
        \scnitem{Пользовательский интерфейс системы автоматизации проектирования scp-программ}
    \end{scnrelfromset}
\end{scnindent}
\end{scnrelfromset}
\end{SCn}

\subsection{Семантическая модель базы знаний системы автоматизации проектирования решателей задач ostis-систем}
\begin{SCn}
\bigskip

\begin{scnrelfromlist}{ключевое понятие}
    \scnitem{база знаний}
    \scnitem{решатель задач ostis-системы}
    \scnitem{scp-программа}
    \scnitem{точка останова*}
    \scnitem{точка останова}
    \scnitem{некорректность в scp-программе*}
    \scnitem{некорректность в scp-программе}
    \scnitem{ошибка в scp-программе}
\end{scnrelfromlist}
\end{SCn}
\label{sub_sec_kb_ps_des_auto_sys}
\textit{База знаний системы автоматизации проектирования решателей задач ostis-систем} включает в себя кроме Ядра баз знаний ostis-систем и Предметной области Базового языка программирования ostis-систем (см. \textit{\ref{sec_ps_scp}~\nameref{sec_ps_scp}}) также описание ключевых понятий, связанных с верификацией и отладкой \textit{scp-программ}.

Рассмотрим основные понятия, специфичные для базы знаний системы автоматизации проектирования scp-программ.

Связки отношения \textbf{\textit{точки останова*}} связывают \textit{scp-программу} с некоторым множеством sc-переменных, соответствующих \textit{scp-операторам} в рамках этой программы. При генерации каждого \textit{scp-процесса}, соответствующего этой \textit{scp-программе}, все \textit{scp-операторы}, соответствующие таким переменным, будут добавлены во множество \textit{точка останова}, то есть выполнение данного scp-процесса будет прерываться при достижении каждого из этих \textit{scp-операторов}.
Использование данного отношения приводит к указанию точек останова для всех \textit{scp-процессов}, формируемых на основе заданной \textit{\mbox{scp-программы}}. Для указания точки останова в рамках отдельно взятого \textit{scp-процесса} нужный scp-оператор явно включается во множество \textit{точка останова}.

\begin{SCn}
	\scnheader{точка останова*}
	\scniselement{квазибинарное отношение}
\end{SCn}

Во множество \textbf{\textit{точка останова}} входят все \textit{scp-операторы}, являющиеся точками останова в рамках какого-либо \textit{scp-процесса}. Это означает, что в момент, когда в соответствии с переходами между \textit{scp-операторами} по связкам отношения \textit{последовательность действий*} указанный \textit{scp-оператор} должен стать \textit{активным действием}, он становится \textit{отложенным действием}, и, соответственно, выполнение всего \textit{scp-процесса} по данной ветке приостанавливается. Чтобы продолжить выполнение, необходимо удалить указанный \textit{\mbox{scp-оператор}} из множества \textit{отложенных действий} и добавить его во множество \textit{активных действий}.

\begin{SCn}
	\scnheader{точка останова}
	\scnsubset{scp-оператор}
\end{SCn}

Под \textit{некорректностью в scp-программе} понимается \textit{некорректная структура}, описывающая некорректность (не обязательно делающую невозможным выполнение соответствующих данной \textit{scp-программе scp-процессов}), выявленную в рамках какой-либо конкретной \textit{scp-программы}.

\begin{SCn}
\scnheader{некорректность в scp-программе}
\scnsubset{некорректная структура}
\scnsuperset{ошибка в scp-программе}
\scnsuperset{недостижимый scp-оператор}
\scnsuperset{потенциально бесконечный цикл}
\end{SCn}

Под \textit{ошибкой в scp-программе} понимается такая \textit{некорректность в scp-программе}, которая делает невозможным успешное выполнение любого \textit{scp-процесса}, соответствующего данной \textit{scp-программе}, или даже создание такого \textit{scp-процесса}.

\begin{SCn}
\scnheader{ошибка в scp-программе}
\begin{scnrelfromset}{разбиение}
    \scnitem{синтаксическая ошибка в scp-программе}
    \begin{scnindent}
        \scnexplanation{Под \textit{синтаксической ошибкой в scp-программе} понимается \textit{ошибка в scp-программе}, в состав которой входит некоторая конструкция, не соответствующая синтаксису \textit{scp-программы} или какой-либо ее части, например, конкретного \textit{scp-оператора}.}
    \end{scnindent}
    \scnitem{семантическая ошибка в scp-программе}
    \begin{scnindent}
        \scnexplanation{Под \textit{семантической ошибкой в scp-программе} понимается \textit{ошибка в scp-программе}, в состав которой входит некоторая конструкция, корректная с точки зрения синтаксиса, но некорректная с семантической точки зрения, например, нарушающая логическую целостность \textit{scp-программы}.}
    \end{scnindent}
\end{scnrelfromset}
\begin{scnrelfromset}{разбиение}
    \scnitem{ошибка в scp-программе на уровне программы}
    \scnitem{ошибка в scp-программе на уровне множества параметров}
    \scnitem{ошибка в scp-программе на уровне множества операторов}
    \scnitem{ошибка в scp-программе на уровне оператора}
    \scnitem{ошибка в scp-программе на уровне операнда}
\end{scnrelfromset}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне программы} описывает некорректный фрагмент, выявление которого требует анализа всей \textit{scp-программы} как единого целого, и не может быть выполнено путем анализа ее отдельных частей, например, конкретных \textit{scp-операторов}.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне программы}
\scnsuperset{отсутствует scp-процесс, соответствующий данной scp-программе}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\scnsuperset{не указана декомпозиция scp-процесса, соответствующего данной scp-программе}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне множества параметров} описывает некорректный фрагмент, для выявления которого достаточно анализа параметров некоторой \textit{scp-программы}, то есть явным образом выделенных аргументов \textit{действия (scp-процессе)}, соответствующего данной scp-программе. К такого рода ошибкам относятся, например, неверное указание ролей этих аргументов в рамках данного действия.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне множества параметров}
\scnsuperset{не указан тип параметра scp-программы}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\scnsuperset{не указан порядковый номер параметра scp-программы}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне множества операторов} описывает некорректный фрагмент, для выявления которого достаточно анализа множества операторов некоторой \textit{scp-программы}, то есть элементов декомпозиции \textit{действия (scp-процесса)}, соответствующего данной \textit{scp-программе}. К таким ошибкам относится, например, факт отсутствия \textit{начального оператора' scp-программы} или факт отсутствия в программе \textit{scp-оператора завершения выполнения программы}.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне множества операторов}
\scnsuperset{декомпозиция scp-процесса не содержит ни одного элемента}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\scnsuperset{отсутствует scp-оператор завершения выполнения программы}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\scnsuperset{scp-оператор, к которому осуществляется переход, не является частью текущего scp-процесса}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\scnsuperset{не указана последовательность действий после выполнения текущего scp-оператора}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\scnsuperset{отсутствует начальный оператор scp-программы}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне оператора} описывает некорректный фрагмент, для выявления которого достаточно анализа одного конкретного \textit{scp-оператора}, при этом не важно, в состав какой \textit{scp-программы} он входит. К такого рода ошибкам относится, например, факт указания количества операндов \textit{scp-оператора}, не соответствующего спецификации соответствующего класса \textit{scp-операторов}.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне оператора}
\scnsuperset{scp-оператор не принадлежит ни одному из атомарных классов scp-операторов}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\scnsuperset{ни один операнд scp-оператора удаления не помечен как удаляемый sc-элемент}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\scnsuperset{в scp-операторе поиска пятиэлементной конструкции совпадает второй и четвертый операнд}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\scnsuperset{scp-оператор поиска не содержит ни одного операнда с заданным значением}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\scnsuperset{scp-оператор поиска с формированием множеств не содержит ни одного операнда с атрибутом формируемое множество}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\scnsuperset{атрибутом формируемое множество отмечен операнд, которому соответствует операнд с заданным значением}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\scnsuperset{количество операндов scp-оператора не совпадает со спецификацией}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}
\end{SCn}

Каждая \textit{ошибка в scp-программе на уровне операнда} описывает некорректный фрагмент, для выявления которого достаточно анализа одного конкретного операнда в рамках scp-программы, точнее sc-дуги принадлежности, связывающей указанный операнд и соответствующий \textit{scp-оператор}, при этом не важно, какой именно \textit{scp-оператор}. К такого рода ошибкам относится, например, факт отсутствия ролевого отношения, указывающего на номер операнда в рамках \textit{scp-оператора}.

\begin{SCn}
\scnheader{ошибка в scp-программе на уровне операнда}
\scnsuperset{не указан номер операнда в рамках scp-оператора}
\begin{scnindent}
    \scniselement{синтаксическая ошибка в scp-программе}
\end{scnindent}

\scnheader{некорректность в scp-программе*}
\scniselement{бинарное отношение}
\scnrelfrom{первый домен}{некорректность в scp-программе}
\scnrelfrom{второй домен*}{scp-программа}
\end{SCn}

Отношение \textit{scp-программа поиска некорректности в scp-программе*} связывает \textit{класс некорректностей в scp-программе} и \textit{scp-программу}, которая может использоваться для выявления соответствующей некорректности в какой-либо другой \textit{scp-программе}. 

Указанная \textit{scp-программа} должна иметь единственный параметр, который является \textit{in-параметром’} и, в зависимости от соответствующего класса некорректностей в \textit{scp-программе}, обозначает:

\begin{textitemize}
    \item саму \textit{scp-программу} в случае выявления \textit{некорректности в scp-программе} вообще или \textit{ошибки в scp-программе на уровне программы};
    \item \textit{scp-процесс}, являющийся \textit{ключевым sc-элементом} данной \textit{scp-программы} в случае выявления ошибки в \textit{scp-программе на уровне множества параметров};
    \item \textit{множество операторов} данной \textit{scp-программы} в случае выявления \textit{ошибки в scp-программе на уровне множества операторов};
    \item \textit{знак конкретного scp-оператора} в случае выявления ошибки в \textit{scp-программе на уровне оператора};
    \item \textit{sc-дугу принадлежности} в случае выявления \textit{ошибки в scp-программе на уровне операнда}.
\end{textitemize}

Если в результате верификации \textit{scp-программы} выявлена некорректность, то формируется соответствующая \textit{структура} и генерируется связка отношения \textit{некорректность в scp-программе*}.

\subsection{Семантическая модель решателя задач системы автоматизации проектирования решателей задач ostis-систем}
\begin{SCn}
\bigskip

\begin{scnrelfromlist}{ключевое понятие}
    \scnitem{Решатель задач системы автоматизации проектирования агентов обработки знаний}
    \scnitem{Решатель задач системы автоматизации проектирования scp-программ}
\end{scnrelfromlist}
\end{SCn}
\label{sub_sec_ps_ps_des_auto_sys}

\begin{SCn}
\scnheader{Решатель задач системы автоматизации проектирования агентов обработки знаний}
\begin{scnrelfromset}{декомпозиция}
    \scnitem{Множеcтво методов решателя задач системы автоматизации проектирования агентов обработки знаний}
    \scnitem{Машина обработки знаний системы автоматизации проектирования агентов обработки знаний}
    \begin{scnindent}
        \begin{scnrelfromset}{декомпозиция абстрактного sc-агента}
            \scnitem{Абстрактный sc-агент верификации sc-агентов}
            \begin{scnindent}
                \begin{scnrelfromset}{декомпозиция абстрактного sc-агента}
                    \scnitem{Абстрактный sc-агент верификации спецификации sc-агента}
                    \scnitem{Абстрактный sc-агент проверки неатомарного sc-агента на непротиворечивость его спецификации спецификациям более частных sc-агентов в его составе}
                \end{scnrelfromset}
            \end{scnindent}
            \scnitem{Абстрактный sc-агент отладки коллективов sc-агентов}
            \begin{scnindent}
                \begin{scnrelfromset}{декомпозиция абстрактного sc-агента}
                    \scnitem{Абстрактный sc-агент поиска всех выполняющихся процессов, соответствующих заданному sc-агенту}
                    \scnitem{Абстрактный sc-агент инициирования заданного sc-агента на заданных аргументах}
                    \scnitem{Абстрактный sc-агент активации заданного sc-агента}
                    \scnitem{Абстрактный sc-агент деактивации заданного sc-агента}
                    \scnitem{Абстрактный sc-агент установки блокировки заданного типа для заданного процесса на заданный sc-элемент}
                    \scnitem{Абстрактный sc-агент снятия всех блокировок заданного процесса}
                    \scnitem{Абстрактный sc-агент снятия всех блокировок с заданного sc-элемента}
                \end{scnrelfromset}
            \end{scnindent}
        \end{scnrelfromset}
    \end{scnindent}
\end{scnrelfromset}
\end{SCn}

Единственным аргументом класса действий, соответствующего \textit{Абстрактному sc-агенту поиска всех выполняющихся процессов, соответствующих заданному sc-агенту}, \textit{Абстрактному sc-агенту активации заданного sc-агента}, \textit{Абстрактному sc-агенту деактивации заданного sc-агента}, является знак этого \textit{sc-агента}.

Класс действий, соответствующий \textit{Абстрактному sc-агенту инициирования заданного sc-агента на заданных аргументах}, имеет два аргумента. Первый аргумент является знаком инициируемого sc-агента, второй --- знаком связки, в которую под соответствующими атрибутами входят sc-элементы, которые станут аргументами соответствующего \textit{действия в sc-памяти}.

Класс действий, соответствующий \textit{Абстрактному sc-агенту установки блокировки заданного типа на заданный sc-элемент}, имеет три аргумента. Первый аргумент является знаком класса блокировок, второй --- знаком процесса в sc-памяти, третий --- sc-элементом, на который должна быть установлена блокировка.

Единственным аргументом класса действий, соответствующего \textit{Абстрактному sc-агенту снятия всех блокировок заданного процесса}, является знак этого \textit{процесса в sc-памяти}.

Единственным аргументом класса действий, соответствующего \textit{Абстрактному sc-агенту снятия всех блокировок с заданного sc-элемента}, является знак этого \textit{sc-элемента}.

\begin{SCn}
\scnheader{Решатель задач системы автоматизации проектирования scp-программ}
\begin{scnrelfromset}{декомпозиция}
    \scnitem{Множество методов решателя задач системы автоматизации проектирования агентов обработки знаний}
    \scnitem{Машина обработки знаний системы автоматизации проектирования агентов обработки знаний}
    \begin{scnindent}
        \begin{scnrelfromset}{декомпозиция абстрактного sc-агента}
            \scnitem{Абстрактный sc-агент верификации scp-программ}
            \scnitem{Абстрактный sc-агент отладки scp-программ}
            \begin{scnindent}
                \begin{scnrelfromset}{декомпозиция абстрактного sc-агента}
                    \scnitem{Абстрактный sc-агент запуска заданной scp-программы для заданного множества входных данных}
                    \scnitem{Абстрактный sc-агент запуска заданной scp-программы для заданного множества входных данных в режиме пошагового выполнения}
                    \scnitem{Абстрактный sc-агент поиска всех scp-операторов в рамках scp-программы}
                    \scnitem{Абстрактный sc-агент поиска всех точек останова в рамках scp-процесса}
                    \scnitem{Абстрактный sc-агент добавления точки останова в scp-программу}
                    \scnitem{Абстрактный sc-агент удаления точки останова из scp-программы}
                    \scnitem{Абстрактный sc-агент добавления точки останова в scp-процесс}
                    \scnitem{Абстрактный sc-агент удаления точки останова из scp-процесса}
                    \scnitem{Абстрактный sc-агент продолжения выполнения scp-процесса на один шаг}
                    \scnitem{Абстрактный sc-агент продолжения выполнения scp-процесса до точки останова или завершения}
                    \scnitem{Абстрактный sc-агент просмотра информации об scp-процессе}
                    \scnitem{Абстрактный sc-агент просмотра информации об scp-операторе}
                \end{scnrelfromset}
            \end{scnindent}
        \end{scnrelfromset}
    \end{scnindent}
\end{scnrelfromset}
\end{SCn}

Алгоритм работы \textit{абстрактного sc-агента верификации scp-программ} сводится к поиску некорректностей в рамках \textit{scp-программы} на основе определений, соответствующих различным классам таких некорректностей, а также посредством запуска соответствующих данным классам некорректностей \textit{scp-программ поиска некорректности в scp-программе*}.

Результатом работы \textit{абстрактного sc-агента верификации scp-программ} является формирование в \textit{sc-памяти структур}, описывающих некорректности в исследуемой \textit{scp-программе}, если таковые имеются.

Единственным аргументом класса действий, соответствующего \textit{абстрактному sc-агенту верификации scp-программ}, является знак верифицируемой \textit{scp-программы}.

Классы действий, соответствующие \textit{абстрактному sc-агенту запуска заданной scp-программы для заданного множества входных данных} и \textit{абстрактному sc-агенту запуска заданной scp-программы для заданного множества входных данных в режиме пошагового выполнения}, имеют два аргумента. Первый аргумент является знаком запускаемой scp-программы, второй --- знаком связки, в которую под соответствующими атрибутами входят sc-элементы, которые станут аргументами соответствующего scp-процесса.

В режиме пошагового выполнения предполагается, что на каждом шаге инициируется выполнение всех scp-операторов в рамках заданного scp-процесса, для которых предыдущий scp-оператор стал прошлой сущностью (выполнился). В свою очередь, шаг заканчивается, когда все инициированные таким образом операторы закончат выполнение. Таким образом, в случае, если в рамках scp-программы есть параллельные ветви, то на одном шаге могут одновременно инициироваться два и более scp-оператора.

Классы действий, соответствующие \textit{абстрактному sc-агенту добавления точки останова в scp-программу, абстрактному sc-агенту удаления точки останова из scp-программы, абстрактному sc-агенту добавления точки останова в scp-процесс} и \textit{абстрактному sc-агенту удаления точки останова из scp-процесса}, имеют два аргумента. Первый аргумент является знаком scp-программы или scp-процесса соответственно, второй --- знаком scp-оператора, входящего в состав этой scp-программы или scp-процесса.

Единственным аргументом классов действий, соответствующих \textit{абстрактному sc-агенту поиска всех точек останова в рамках scp-процесса, абстрактному sc-агенту продолжения выполнения scp-процесса на один шаг, абстрактному sc-агенту продолжения выполнения scp-процесса до точки останова или завершения} и \textit{абстрактному sc-агенту просмотра информации об scp-процессе}, является знак scp-процесса, с которым будет выполнено соответствующее действие.

Единственным аргументом класса действий, соответствующего \textit{абстрактному sc-агенту поиска всех scp-операторов в рамках scp-программы}, является знак этой scp-программы.

Единственным аргументом класса действий, соответствующего \textit{абстрактному sc-агенту просмотра информации об scp-операторе}, является знак scp-оператора, входящего в состав некоторого scp-процесса. Результатом работы данного агента является структура, описывающая значения операндов данного scp-оператора, его атомарный тип и другую служебную информацию, полезную для разработчика.

\subsection{Семантическая модель пользовательского интерфейса системы автоматизации проектирования решателей задач ostis-систем}
\begin{SCn}
\bigskip

\begin{scnrelfromlist}{ключевое понятие}
    \scnitem{решатель задач ostis-системы}
    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования решателей задач ostis-систем}
    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования агентов обработки знаний}
    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования scp-программ}
\end{scnrelfromlist}
\end{SCn}
\label{sub_sec_interface_ps_des_auto_sys}
\textit{пользовательский интерфейс системы автоматизации проектирования решателей задач ostis-систем} представлен набором интерфейсных команд, позволяющих пользователю инициировать деятельность нужного агента, входящего в состав этой системы.

\begin{SCn}
\scnheader{команда пользовательского интерфейса системы автоматизации проектирования решателей задач ostis-систем}
\begin{scnrelfromset}{разбиение}
    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования агентов обработки знаний}
    \scnitem{команда пользовательского интерфейса системы автоматизации проектирования программ языка SCP}
\end{scnrelfromset}

\scnheader{команда пользовательского интерфейса системы автоматизации проектирования агентов обработки знаний}
\begin{scnrelfromset}{разбиение}
    \scnitem{команда верификации sc-агентов}
    \begin{scnindent}
        \begin{scnrelfromset}{разбиение}
            \scnitem{команда верификации спецификации sc-агента}
            \scnitem{команда верификации неатомарного sc-агента на непротиворечивость его спецификации спецификациям более частных sc-агентов в его составе}
        \end{scnrelfromset}
    \end{scnindent}
    \scnitem{команда отладки коллективов sc-агентов}
    \begin{scnindent}
        \begin{scnrelfromset}{разбиение}
            \scnitem{команда поиска всех выполняющихся процессов, соответствующих заданному sc-агенту}
            \scnitem{команда инициирования заданного sc-агента на заданных аргументах}
            \scnitem{команда активации заданного sc-агента}
            \scnitem{команда деактивации заданного sc-агента}
            \scnitem{команда установки блокировки заданного типа для заданного процесса на заданный sc-элемент}
            \scnitem{команда снятия всех блокировок заданного процесса}
            \scnitem{команда снятия всех блокировок с заданного sc-элемента}
        \end{scnrelfromset}
    \end{scnindent}
\end{scnrelfromset}

\scnheader{команда пользовательского интерфейса системы автоматизации проектирования scp-программ}
\begin{scnrelfromset}{разбиение}
    \scnitem{команда верификации scp-программ}
    \scnitem{команда отладки scp-программ}
    \begin{scnindent}
        \begin{scnrelfromset}{разбиение}
            \scnitem{команда запуска заданной scp-программы для заданного множества входных данных}
            \scnitem{команда запуска заданной scp-программы для заданного множества входных данных в режиме пошагового выполнения}
            \scnitem{команда поиска всех scp-операторов в рамках scp-программы}
            \scnitem{команда поиска всех точек останова в рамках scp-процесса}
            \scnitem{команда добавления точки останова в scp-программу}
            \scnitem{команда удаления точки останова из scp-программы}
            \scnitem{команда добавления точки останова в scp-процесс}
            \scnitem{команда удаления точки останова из scp-процесса}
            \scnitem{команда продолжения выполнения scp-процесса на один шаг}
            \scnitem{команда продолжения выполнения scp-процесса до точки останова или завершения}
            \scnitem{команда просмотра информации об scp-процессе}
            \scnitem{команда просмотра информации об scp-операторе}
        \end{scnrelfromset}
    \end{scnindent}
\end{scnrelfromset}

\end{SCn}

% \section{Логико-семантическая модель ostis-системы автоматизации проектирования программ Базового языка программирования ostis-систем}
% \section{Логико-семантическая модель ostis-системы автоматизации проектирования внутренних агентов ostis-систем, а также коллективов таких агентов}
\section{Многократно используемые компоненты решателей задач ostis-систем}
\label{sec_ps_components}

\begin{SCn}
\bigskip

\begin{scnrelfromlist}{ключевое понятие}
    \scnitem{решатель задач ostis-системы}
    \scnitem{библиотека многократно используемых компонентов решателей задач}
    \scnitem{многократно используемый компонент решателей задач}
    \scnitem{метод}
    \scnitem{Средства автоматизации библиотеки многократно используемых компонентов решателей задач}
    \scnitem{отношение, специфицирующее многократно используемый компонент решателей задач ostis-систем}
    \scnitem{Решатель задач библиотеки многократно используемых компонентов решателей задач}
\end{scnrelfromlist}

\end{SCn}


% СМОТРИТЕ \scncite{Zalivako2012}, \scncite{Shunkevich2013}

\textbf{\textit{Библиотека многократно используемых компонентов решателей задач в составе Метасистемы OSTIS}} является важнейшим фрагментом Метасистемы OSTIS, обеспечивающим надежность проектируемых решателей задач и повышение скорости их разработки.

Библиотека включает:
\begin{textitemize}
\item множество компонентов решателей задач;
\item средства спецификации компонентов решателей задач;
\item средства поиска компонентов решателей задач на основе их спецификации, уточняющие общие средства поиска компонентов в рамках библиотеки, рассмотренные в \textit{\ref{ostis_library_section}~\nameref{ostis_library_section}}.
\end{textitemize}

\begin{SCn}
\scnheader{библиотека многократно используемых компонентов решателей задач ostis-систем}
\begin{scnrelfromset}{обобщенная декомпозиция}
    \scnitem{база знаний библиотеки многократно используемых компонентов решателей задач ostis-систем}
    \begin{scnindent}
        \scntext{примечание}{База знаний представляет собой иерархию многократно используемых компонентов решателей задач ostis-систем и их спецификацию.}
    \end{scnindent}
    \scnitem{решатель задач библиотеки многократно используемых компонентов решателей задач ostis-систем}
    \begin{scnindent}
        \scntext{примечание}{Решатель задач позволяет осуществлять поиск компонентов решателей задач, находить зависимости таких компонентов, конфликты между компонентами.}
    \end{scnindent}
    \scnitem{интерфейс библиотеки многократно используемых компонентов решателей задач ostis-систем}
    \begin{scnindent}
        \scntext{примечание}{Интерфейс библиотеки позволяет подключиться к библиотеке и получить доступ к компонентам хранящимся в ней и к ее функционалу.}
    \end{scnindent}
\end{scnrelfromset}
\end{SCn}

Если \textit{многократно используемый компонент решателей задач} является \textit{платформенно-зависимым многократно используемым компонентом ostis-системы}, то его интеграция производится в соответствии с инструкцией, предоставляемой разработчиком в зависимости от платформы, как и для любого компонента такого рода. В противном случае процесс интеграции можно конкретизировать в зависимости от подклассов данного типа компонентов. 

Рассмотрим классификацию многократно используемых компонентов решателей задач ostis-систем.

\begin{SCn}
\scnheader{многократно используемый компонент решателей задач ostis-систем}
\scnsuperset{метод}
\scnsuperset{пакет программ}
\scnsuperset{абстрактный sc-агент}
\scnsuperset{решатель задач ostis-системы}
\begin{scnindent}
    \scnnote{Целые решатели задач могут быть многократно используемыми компонентами в случае разработки интеллектуальных систем, назначение которых совпадает.}
\end{scnindent}

\scnheader{абстрактный sc-агент}
\begin{scnsubdividing}
    \scnitem{абстрактный sc-агент информационного поиска}
    \scnitem{абстрактный sc-агент погружения интегрируемого знания в базу знаний}
    \scnitem{абстрактный sc-агент выравнивания онтологии интегрируемого знания с основной онтологией текущего состояния базы знаний}
    \scnitem{абстрактный sc-агент планирования решения явно сформулированных задач}
    \scnitem{абстрактный sc-агент логического вывода}
    \scnitem{абстрактный sc-агент верификации базы знаний}
    \scnitem{абстрактный sc-агент редактирования базы знаний}
    \scnitem{абстрактный sc-агент автоматизации деятельности разработчиков базы знаний}
\end{scnsubdividing}

\end{SCn}

Классификация решателей задач ostis-систем подробно рассмотрена в \textit{\ref{sec_ps_ps} \nameref{sec_ps_ps}}.

Под \textit{многократно используемым абстрактным sc-агентом} подразумевается компонент, соответствующий некоторому \textit{абстрактному sc-агенту}, который может быть использован в решателях задач других ostis-систем, возможно, в составе более сложных \textit{неатомарных абстрактных sc-агентов}. Спецификация многократно используемого \textit{абстрактного sc-агента} должна содержать всю информацию, необходимую для функционирования соответствующего \textit{sc-агента} в дочерней ostis-системе.

Таким образом, указанная спецификация формируется следующим образом:

\begin{textitemize}
    \item В нее включается \textit{sc-узел}, обозначающий соответствующий \textit{абстрактный sc-агент}, и вся его спецификация, то есть, как минимум, указание \textit{ключевых sc-элементов sc-агента*}, \textit{условия инициирования и результат*}, \textit{первичного условия инициирования*}, \textit{sc-описание поведения sc-агента} и класса решаемых им задач;
    \item В случае, если специфицируется многократно используемый \textit{абстрактный sc-агент}, который рассматривается как \textit{неатомарный абстрактный sc-агент}, то его спецификация  будет содержать \textit{sc-узлы}, обозначающие все более частные \textit{абстрактные sc-агенты}, а также все их спецификации;
    \item Для каждого \textit{атомарного абстрактного sc-агента}, знак которого вошел в такую спецификацию, необходимо выбрать вариант его реализации (то есть элемент класса \textit{платформенно-независимый абстрактный sc-агент} или \textit{платформенно-зависимый абстрактный sc-агент}, связанный с исходным \textit{атомарным абстрактным sc-агентом} связкой отношения \textit{включение*}) и включить в указанную спецификацию sc-узел, обозначающий указанную реализацию, а также знаки всех программ, входящие во множество, связанное с указанной реализацией отношением \textit{программа sc-агента*};
    \item В спецификацию компонента включаются также все связки отношений, связывающие уже включенные в его состав sc-элементы, а также сами знаки этих отношений (например, \textit{включение*}, \textit{программа sc-агента*} и так далее).
\end{textitemize}

После того как многократно используемый \textit{абстрактный sc-агент} был скопирован в дочернюю ostis-систему, необходимо сгенерировать sc-узел, обозначающий конкретный \textit{sc-агент}, работающий в данной системе и принадлежащий выбранной реализации \textit{абстрактного sc-агента}, и добавить его во множество \textit{активных sc-агентов} при необходимости.

Под \textit{многократно используемой программой} подразумевается компонент, соответствующий программе, записанной на произвольном языке программирования, которая ориентирована на обработку \textit{структур}, хранящихся в памяти \textit{ostis-системы}. Приоритетным в данном случае является использование \textit{scp-программ} по причине их платформенной независимости, за исключением случаев проектирования некоторых компонентов интерфейса, когда полная платформенная независимость невозможна (например, при проектировании \textit{эффекторных sc-агентов и рецепторных sc-агентов}).

Также каждую \textit{scp-программу}, попавшую в \textit{дочернюю ostis-систему} при копировании \textit{многократно используемого комопнента решателя задач ostis-систем}, необходимо добавить во множество \textit{корректных scp-программ} (корректность верифицируется при попадании в библиотеку компонентов).

Для удобства работы с библиотекой многократно используемых компонентов необходимы также средства автоматизации поиска компонентов на основе заданной спецификации, представляющие собой \textit{решатель задач ostis-системы} частного вида.

Ниже представлена структура такого \textit{решателя задач}:

\begin{SCn}
\scnheader{Средства автоматизации библиотеки многократно используемых компонентов решателей задач ostis-систем}
\begin{scnrelfromset}{декомпозиция}
	\scnitem{Множество методов, входящих в состав средств автоматизации библиотеки многократно используемых компонентов решателей задач ostis-систем}
	\scnitem{Машина обработки знаний библиотеки многократно используемых компонентов решателей задач ostis-систем}
	\begin{scnindent}
	\begin{scnrelfromset}{декомпозиция абстрактного sc-агента}
	    \scnitem{Абстрактный sc-агент формирования неатомарного компонента решателей задач ostis-систем из атомарных}
	    \scnitem{Абстрактный sc-агент поиска всех неатомарных компонентов, частью которых является заданный атомарный компонент}
	    \scnitem{Абстрактный sc-агент поиска всех сопутствующих компонентов}
	    \scnitem{Абстрактный sc-агент поиска sc-агента по условию инициирования}
	    \scnitem{Абстрактный sc-агент поиска sc-агента по результату работы}
	    \scnitem{Абстрактный sc-агент поиска scp-программы по входным/выходным параметрам}
	    \scnitem{Абстрактный sc-агент поиска sc-агентов, для которых элементы заданного множества являются ключевыми sc-элементами}
   	\end{scnrelfromset}
    \end{scnindent}
\end{scnrelfromset}
\end{SCn}

Под \textit{неатомарным компонентом решателей задач ostis-систем} понимается такой компонент, в составе которого можно выделить другие компоненты, которые могут использоваться самостоятельно, отдельно от исходного компонента. Чаще всего в роли таких неатомарных компонентов выступают неатомарные sc-агенты, в составе которых могут быть выделены самодостаточные sc-агенты, которые могут быть использованы отдельно от исходного неатомарного, или scp-программы, которые являются общими для нескольких агентов и могут быть использованы не только в составе неатомарного sc-агента. Таким образом, задачей \textit{Абстрактного sc-агента формирования неатомарного компонента решателей задач ostis-систем из атомарных} является формирование структуры, содержащей в себе полный sc-текст неатомарного компонента, включая спецификации всех \mbox{sc-агентов} в его составе, а также тексты всех необходимых scp-программ. Формирование такой структуры необходимо для того, чтобы упростить процесс копирования указанного компонента в другие ostis-системы.

Под сопутствующим компонентом понимается компонент, который часто используется в ostis-системе одновременно с некоторым другим компонентом (см. \textit{\ref{ostis_library_section}~\nameref{ostis_library_section}})

\textit{Абстрактный sc-агент поиска sc-агентов, для которых элементы заданного множества являются ключевыми sc-элементами} играет важную роль при внесении изменений в базу знаний, в частности, при переопределении каких-либо понятий. Указанный sc-агент позволяет выявить те sc-агенты, для которых могут потребоваться изменения в алгоритме работы в связи с изменением семантической трактовки каких-либо понятий.

Рассмотрим отношения необходимые для спецификации многократно используемого компонента \textit{решателя задач}, его поиска и установки в дочернюю ostis-систему.

\begin{SCn}
\scnheader{отношение, специфицирующее многократно используемый компонент решателей задач ostis-систем}
\scnsubset{отношение, специфицирующее многократно используемый компонент ostis-систем}
\scnhaselement{первичное условие инициирования*}
\begin{scnindent}
    \scnexplanation{Связки отношения первичное условие инициирования* связывают между собой sc-узел, обозначающий абстрактный sc-агент и бинарную ориентированную пару, описывающую первичное условие инициирования данного абстрактного sc-агента, то есть такой ситуации в sc-памяти, которая побуждает sc-агента перейти в активное состояние и начать проверку наличия своего полного условия инициирования.
    
    Первым компонентом данной ориентированной пары является знак некоторого подмножества понятия событие, например событие добавления выходящей sc-дуги, то есть по сути конкретный тип события в sc-памяти.
    
    Вторым компонентом данной ориентированной пары является произвольный в общем случае sc-элемент, с которым непосредственно связан указанный тип события в sc-памяти, то есть, например, sc-элемент, из которого выходит либо в который входит генерируемая либо удаляемая sc-дуга, либо файл ostis-системы, содержимое которого было изменено.
    
    После того, как в sc-памяти происходит некоторое событие, активизируются все активные sc-агенты, первичное условие инициирования* которых соответствует произошедшему событию.}
    \scnrelfrom{первый домен}{абстрактный sc-агент}
    \scnrelfrom{второй домен}{бинарная ориентированная пара}
\end{scnindent}
\scnhaselement{условие инициирования и результат*}
\begin{scnindent}
    \scnexplanation{Связки отношения условие инициирования и результат* связывают между собой sc-узел, обозначающий абстрактный sc-агент и бинарную ориентированную пару, связывающую условие инициирования данного абстрактного sc-агента и результаты выполнения экземпляров данного sc-агента в какой-либо конкретной системе.
    
    Указанную ориентированную пару можно рассматривать как логическую связку импликации, при этом на sc-переменные, присутствующие в обеих частях связки, неявно накладывается квантор всеобщности, на sc-переменные, присутствующие либо только в посылке, либо только в заключении неявно накладывается квантор существования.
    
    Первым компонентом указанной ориентированной пары является логическая формула, описывающая условие инициирования описываемого абстрактного sc-агента, то есть конструкции, наличие которой в sc-памяти побуждает sc-агент начать работу по изменению состояния sc-памяти. Данная логическая формула может быть как атомарной, так и неатомарной, в которой допускается использование любых связок логического языка.
    
    Вторым компонентом указанной ориентированной пары является логическая формула, описывающая возможные результаты выполнения описываемого абстрактного sc-агента, то есть описание произведенных им изменений состояния sc-памяти. Данная логическая формула может быть как атомарной, так и неатомарной, в которой допускается использование любых связок логического языка.}
    \scnrelfrom{первый домен}{абстрактный sc-агент}
    \scnrelfrom{второй домен}{бинарная ориентированная пара}
\end{scnindent}
\end{SCn}

\section*{Заключение к Главе \ref{chapter_ps_design}}

В данной главе предложена \textit{Методика построения и модификации машины обработки знаний ostis-систем}, которая включает несколько этапов:
\begin{textitemize}
    \item формирование требований и спецификация \textit{машины обработки знаний};
    \item формирование коллектива sc-агентов, входящих в состав разрабатываемой машины;
    \item разработка алгоритмов атомарных sc-агентов;
    \item реализация scp-программ;
    \item верификация разработанных компонентов;
    \item отладка разработанных компонентов, исправление ошибок.
\end{textitemize}

\textit{Методика построения и модификации машины обработки знаний ostis-систем} основана на онтологии деятельности разработчиков \textit{машины обработки знаний}. Наличие такой онтологии позволяет:
\begin{textitemize}
    \item частично автоматизировать процесс построения и модификации \textit{машины обработки знаний};
    \item повысить эффективность информационной поддержки разработчиков, поскольку данная онтология может быть включена в \textit{Базу знаний Метасистемы OSTIS}.
\end{textitemize}

Также предложена модель \textit{Системы автоматизации проектирования решателей задач ostis-систем}. Cистема может использоваться тремя способами:
\begin{textitemize}
    \item Как подсистема в рамках \textit{Метасистемы OSTIS}. Данный вариант использования предполагает отладку необходимых компонентов в рамках метасистемы с последующим переносом их в \textit{дочернюю ostis-систему}.
    \item Как \textit{самостоятельная ostis-система}, предназначенная исключительно для разработки и отладки компонентов решателей задач. В этом случае проектируемые компоненты отлаживаются в рамках такой системы, а затем должны быть перенесены в дочернюю ostis-систему.
    \item Как подсистема в рамках дочерней ostis-системы. В таком варианте отладка компонентов осуществляется непосредственно в той же системе, в которой предполагается их использование, и дополнительного переноса не требуется.
\end{textitemize}

Рассмотрены многократно используемые компоненты \textit{решателей задач ostis-систем} и соответствующая им библиотека.

В дальнейшем планируется уточнение принципов и разработка соответствующей методики проектирования \textit{методов} решения задач.

%\input{author/references}