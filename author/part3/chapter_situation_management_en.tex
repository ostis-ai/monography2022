\chapter*{Агентно-ориентированные модели гибридных решателей задач ostis-систем}

\section*{Введение}

Одним из ключевых компонентов \textit{интеллектуальной системы}, обеспечивающим возможность решать широкий круг \textit{задач}, является \textit{решатель задач}. Их особенностью по сравнению с другими современными \textit{программными системами} является необходимость решать \textit{задачи} в условиях, когда необходимые сведения не локализованы явно в \textit{базе знаний} \textit{интеллектуальной системы} и должны быть найдены в процессе решения \textit{задачи} на основании каких-либо критериев. 

Говоря другими словами, если в традиционных системах при решении задачи всегда подразумевается, что есть некоторые локализованные исходные данные ("дано") и некоторое описание желаемого результата ("что требуется"), то в \textit{интеллектуальной системе} в качестве исходных данных при решении большого числа \textit{задач} выступает вся имеющаяся на текущий момент в системе информация, то есть вся \textit{база знаний}. Кроме того, при невозможности решения задачи в текущем состоянии базы знаний интеллектуальная система должна иметь возможность понять, чего именно не хватает для продолжения процесса решения и попытаться добыть недостающие сведения во внешней среде (например, запросить у пользователя).

К настоящему времени в рамках различных направлений \textit{Искусственного интеллекта} разработано большое количество различных \textit{моделей решения задач}, каждая из которых позволяет решать задачи определенного класса. Расширение областей применения \textit{интеллектуальных систем} требует от них возможности решать так называемые \textit{комплексные задачи}, решение каждой из которых требует комбинирования нескольких моделей решения задач, при этом априори неизвестно, в каком порядке и сколько раз будет применяться так или иная модель. \textit{решатели задач}, в рамках которых комбинируются несколько \textit{моделей решения задач}, получили название \textit{гибридных решателей задач}, а интеллектуальные системы, в рамках которых комбинируются различные \textit{виды знаний} и различные \textit{модели решения задач} -- \textit{гибридных интеллектуальных систем} (см. \scncite{Kolesnikov2001}).

Повышение эффективности разработки и эксплуатации \textit{гибридных интеллектуальных систем} требует унификации моделей представления различных \textit{видов знаний} и \textit{моделей обработки знаний}, которая бы позволила легко интегрировать на ее основе компоненты, соответствующие различным моделям решения задач.

\section*{Современное состояние, проблемы в области разработки гибридных решателей задач и предлагаемый подход к их решению}

\subsection*{Современное состояние технологий разработки решателей задач и требования, предъявляемые к гибридным решателям задач}

Существующее многообразие подходов к решению \textit{задач} в \textit{компьютерных системах} можно разделить на два класса:
\begin{textitemize}
	\item \textbf{решение задач с использованием хранимых программ.} В данном случае предполагается, что в системе заранее присутствует программа решения задачи заданного класса и решение сводится к поиску такой программы и интерпретации ее на заданных входных данных. К системам, ориентированным на такой подход к решению задач, относятся в том числе системы, использующие:
	\begin{textitemize}
		\item программы, написанные на языках программирования, относящихся как к императивной, так и к декларативной парадигме, в том числе логических и функциональных (см. \scncite{Pratt2002});
		\item реализации генетических алгоритмов (см. \scncite{Gladkov2006}, \scncite{Emelyanov2003});
		\item нейросетевые модели обработки знаний (см. \scncite{Berkinblit1993},\newline \scncite{Golovko2001}, \scncite{Gorban1996}).
	\end{textitemize}	
	\vspace{-2\parskip}
	Следует отметить, что даже в случае использования хранимой \textit{программы} решение \textit{задачи} далеко не всегда тривиально, поскольку, во-первых, требуется найти такую хранимую \textit{программу} на основе некоторой спецификации, во-вторых, обеспечить ее интерпретацию.
	\vspace{\parskip}
	\item \textbf{решение задач в условиях, когда программа решения не известна.} В этом случае предполагается, что в системе необязательно присутствует готовая \textit{программа} решения для \textit{класса задач}, которому принадлежит некоторая сформулированная задача, подлежащая решению. В связи с этим необходимо применять дополнительные методы поиска путей решения задачи, не рассчитанные на какой-либо узкий \textit{класс задач} (например, разбиение задачи на подзадачи, методы поиска решений в глубину и ширину, метод случайного поиска решения и метод проб и ошибок, метод деления пополам и другие), а также различные модели \textit{логического вывода}: классические дедуктивные (см. \scncite{Vagin2008}), индуктивные (см. \scncite{Khulick2001}, \scncite{Polya1975}), абдуктивные (см. \scncite{Vagin2008}); модели, основанные на \textit{нечетких логиках} (см. \scncite{Batyrshin2001}, \scncite{Demenkov2005}, \scncite{Pospelov1989}), \textit{логике умолчаний} (см. \scncite{Reiter1980}), \textit{темпоральной логике} (см. \scncite{Eremeev1997}), и многие другие.
\end{textitemize}

Подробный обзор \textit{решателей задач}, разработанных в период до 1982 года, таких как \textit{GPS}, \textit{STRIPS}, \textit{QA3}, \textit{ПРИЗ} (см. \scncite{Kachro1988}), \textit{ППР} приведен в книге \scncite{Ephymov1982}. Среди современных работ, исследующих вопросы применения \textit{моделей решения задач}, не ориентированных на конкретную предметную область, можно выделить \scncite{Raghovsky2011}. Среди наиболее заметных представителей класса \textit{интеллектуальных решателей задач}, разработанных в более поздний период, можно отметить \textit{Компьютерный решатель математических задач} (см. \scncite{Podkholzyn2008}), \textit{Решатель задач по планиметрии НИЦ ЭВТ} (см. \scncite{Khurbatov2016}), \textit{Программный комплекс ``УДАВ''} (см. \scncite{Vladimirov2010}). 

Отдельного внимания заслуживают популярные в настоящее время \textit{системы компьютерной алгебры}, такие как \textit{Wolfram Mathematica}, \textit{Maple}, \textit{MathCAD} и другие. Указанные программные комплексы обладают мощной функциональностью как для проведения различного рода вычислений и экспериментов, так и для построения на их основе систем различного назначения, например обучающих.

Однако при всем многообразии решаемых рассмотренными системами \textit{задач} множество \textit{классов задач} ограничивается имеющимся в системе набором жестко заданных приемов и алгоритмов решения \textit{задач}, явно используемых при решении той или иной \textit{задачи}. В то же время построение сложных систем, например, систем комплексной автоматизации, невозможно без обеспечения согласованного использования различных \textit{видов знаний} и \textit{моделей решения задач} в рамках одной системы при решении одной и той же \textit{комплексной задачи}. Кроме того, становится актуальной \textit{задача} поддержки такой системы в состоянии, соответствующем текущему уровню развития технологий, дополнения ее более совершенными \textit{моделями} и \textit{методами решения задач}. При этом очевидно, что подобная реконфигурация системы должна осуществляться \myuline{непосредственно в процессе эксплуатации системы}, а не требовать каждый раз, например, полной остановки всего производства или отдельных его частей.

Сказанное выше позволяет сформулировать требования \textit{гибридному решателю задач}:
\begin{textitemize}
	\item в каждый момент времени \textit{решатель задач} должен обеспечивать решение задач из оговоренного класса за оговоренное время, при этом результат решения задачи должен удовлетворять некоторым известным требованиям. Другими словами, как и в случае современных \textit{компьютерных систем}, корректность результатов решения задач на этапе разработки системы должна верифицироваться специальными методами, в том числе для этого могут быть использованы такие современные подходы, как \textit{unit-тестирование}, \textit{тестирование методом «черного ящика}» и другие. Более детально рассмотрим положения, уточняющие сформулированное требование:
	\begin{textitemize}
		\item для явно сформулированных \textit{задач} система всегда должна давать какой-либо ответ за оговоренное время, при этом ответ может быть отрицательным (система не смогла решить поставленную задачу), возможно, с объяснением причин, по которым решение в текущий момент оказалось невозможным. Одним из факторов безуспешности решения является выход за рамки установленного промежутка времени;
		\item если явно сформулированная \textit{задача} решена, то все \textit{информационные процессы}, направленные на ее решение, должны быть уничтожены. Особенно актуальным данное требование становится в ситуации, когда для решения одной и той же задачи параллельно используются сразу несколько подходов и заранее неизвестно, какой из них приведет к результату раньше других;
		\item после решения задачи вся временная информация, сгенерированная в процессе решения этой \textit{задачи} и имеющая ценность только в контексте решения указанной \textit{задачи}, должна быть удалена из памяти;
	\end{textitemize}
	
	\item \textit{\textbf{гибридный решатель}} должен обеспечивать возможность \textbf{согласованного использования различных моделей решения задач} при решении одной и той же \textit{комплексной задачи} в случае необходимости;
	
	\item \textit{решатель задач} должен быть легко \textbf{модифицируемым}, то есть трудоемкость внесения изменений в уже разработанный \textit{решатель задач} должна быть минимальна. Путями повышения модифицируемости \textit{решателя задач} являются обеспечение локальности вносимых изменений, в том числе -- за счет стратификации \textit{решателя задач} на независимые уровни и обеспечение максимальной независимости компонентов \textit{решателя задач} друг от друга, а также наличие готовых компонентов, которые могут быть встроены в \textit{решатель задач} при необходимости. При этом внесение изменений должно осуществляться \myuline{непосредственно в процессе эксплуатации системы};
	
	\item для того чтобы \textit{интеллектуальная система} имела возможность анализировать и оптимизировать имеющийся \textit{решатель задач}, интегрировать в его состав новые компоненты (в том числе самостоятельно), оценивать важность тех или иных компонентов и применимость их для решения той или иной задачи, спецификация \textit{решателя задач} должна быть описана языком, понятным системе, например, при помощи тех же средств, что и обрабатываемые \textit{знания}. Другими словами, \textit{интеллектуальная система} и, соответственно, \textit{решатель задач} должны обладать \textit{рефлексивностью}.
\end{textitemize}

Несмотря на то что в настоящее время существует большое число \textit{моделей решения задач}, многие из которых реализованы и успешно используются на практике в различных системах, остается актуальной проблема низкой согласованности принципов, лежащих в основе реализации таких моделей, и отсутствия единой унифицированной основы для реализации и интеграции различных \textit{моделей решения задач}, что приводит к тому, что:

\begin{textitemize}
	\item затруднена возможность одновременного использования различных \textit{моделей решения задач} в рамках одной системы при решении одной и той же комплексной задачи; практически невозможно комбинировать различные модели с целью решения \textit{задачи}, для которой априори отсутствует \textit{алгоритм} ее решения;
	\item практически невозможно использовать технические решения, реализованные в одной системе, в других системах, то есть возможности использования компонентного подхода при построении \textit{решателей задач} сильно ограничены. Как следствие, велико количество дублирований аналогичных решений в разных системах;
	\item фактически отсутствуют комплексные методики и средства построения \textit{решателей задач}, которые бы обеспечивали возможность проектирования, реализации и отладки \textit{решателей задач} различного вида.
\end{textitemize}

Следствиями указанных проблем являются:

\begin{textitemize}
\item высокая трудоемкость разработки каждого \textit{решателя задач}, увеличение сроков их разработки, а значит, и увеличение затрат на разработку и поддержку соответствующих \textit{интеллектуальных систем};
\item высокая трудоемкость внесения изменений в уже разработанные \textit{решатели задач}, то есть отсутствует или сильно затруднена возможность дополнения уже разработанного \textit{решателя задач} новыми компонентами и внесения изменений в уже существующие компоненты в процессе эксплуатации системы. Таким образом, высока трудоемкость поддержки разработанных \textit{решателей задач};
\item высокий уровень профессиональных требований к разработчикам \textit{решателей задач}, что обусловлено, в частности:
	\begin{textitemize}
	\item высокой сложностью существующих формализмов в области решения \textit{задач}, рассчитанных на их интерпретацию \textit{компьютерной системой}, а не человеком;
	\item отсутствием возможности рассматривать разрабатываемые \textit{решатели задач} на разных уровнях детализации, выделения на каждом уровне достаточно независимых компонентов, что затрудняет процесс проектирования, тестирования и отладки таких \textit{решателей задач}, а также снижает эффективность попыток объединения разработчиков \textit{решателей задач} в коллективы по причине увеличения накладных расходов на согласование их деятельности;
	\item низким уровнем информационной поддержки разработчиков и автоматизации их \textit{деятельности}.
\end{textitemize}
\end{textitemize}

Для решения перечисленных проблем необходимо разработать комплекс моделей, методики и средств разработки \textit{гибридных решателей задач}, удовлетворяющих перечисленным ранее требованиям.

Исторически сложились два основных подхода к построению \textit{решателей задач} \textit{интеллектуальных компьютерных систем}.

Первый подход предполагает наличие в системе фиксированного \textit{решателя задач} (например, машины логического вывода), к которому впоследствии добавляется \textit{база знаний}, наполнение которой определяется \textit{предметной областью}, в которой должна работать система. Такие системы получили название "пустых"{} \textit{экспертных систем} (см. \scncite{AIRefBookP11990}) или "оболочек"{} (expert system shells, см. \scncite{Jackson1998}). Данный подход, как правило, использовался для разработки относительно несложных систем и в настоящее время не имеет широкого применения.

Второй подход, широко используемый в настоящее время, предполагает наличие программных средств доступа к информации, хранящейся в некоторой базе, совместимых с различными популярными \textit{языками программирования}. Данный подход широко используется, например, в системах, построенных на основе стандартов \textit{W3C} (см. \scncite{W3C}), таких как \textit{RDF} (см. \scncite{RDF}), \textit{OWL} (см. \scncite{OWL}), \textit{SPARQL} (см. \scncite{SPARQL}), а также \textit{графовых с.у.б.д.}, таких как \textit{Neo4j} (см. \scncite{Neo4j}). Структура \textit{решателя задач}, построенного на базе таких средств, определяется разработчиком в каждом конкретном случае и не фиксируется какими-либо стандартами. Такой подход обладает большей гибкостью, но отсутствие унификации в структуре и процессе разработки \textit{решателей задач} приводит к отсутствию совместимости компонентов \textit{решателей задач}, созданных разными разработчиками, большому количеству дублирований одних и тех же решений, повышению накладных расходов в процессе разработки и поддержки \textit{решателя задач}. Также существует большое количество реализаций так называемых \textit{ризонеров} (semantic reasoners), осуществляющих \textit{логический вывод} на \textit{онтологиях}, представленных в формате \textit{OWL 2}, а также средств разработки и редактирования таких \textit{онтологий}. Полный список таких средств, признанных консорциумом \textit{W3C}, можно найти на сайте \scncite{OWLImplementations}. Как видно из приведенной на нем таблицы, подавляющее большинство средств способно осуществлять только прямой \textit{логический вывод} на основе \textit{отношений}, описанных в \textit{онтологии}.

Среди комплексных подходов к построению \textit{решателей задач}, разрабатываемых русскоязычными авторами, можно выделить проект \textit{IACPaaS} (см. \scncite{Gribova2015a},  \scncite{Gribova2011}), активно развивающийся в настоящее время. Целью данного проекта является разработка облачной платформы для построения на ее основе \textit{интеллектуальных сервисов} различного назначения. В данном проекте активно используются \textit{библиотеки многократно используемых компонентов интеллектуальных систем}. Конкретно для построения \textit{решателей задач}, а также \textit{пользовательских интерфейсов} таких систем используется \textit{многоагентный подход}. Несмотря на близость некоторых технологических решений, реализуемых в проекте \textit{IACPaaS} и в рамках \textit{Технологии OSTIS}, основной целью указанного проекта является предоставление пользователю большого числа разнородных сервисов, выбор которых осуществляется самим пользователем, в то время как одним из ключевых принципов \textit{Технологии OSTIS} является разработка общей формальной основы для интеграции различных \textit{моделей решения задач} с целью их комбинирования при решении одной и той же \textit{комплексной задачи}.

Задачи интеграции различных подходов, в том числе связанных с решением задач, исследуются также в работе \scncite{Phylyppov2016} и других работах тех же авторов.

Компонентному проектированию \textit{интеллектуальных систем, основанных на знаниях}, посвящена работа \scncite{Borisov2014}, в которой обосновывается необходимость накопления и повторного использования различных компонентов \textit{интеллектуальных систем}, предлагаются возможные решения данной проблемы с использованием \textit{онтологий}.

Состояние работ англоязычных авторов, посвященных вопросам решения задач в \textit{системах, основанных на знаниях}, и актуальных на момент начала 1990-х годах, отражено в обзорных публикациях \scncite{Dutta1993}, \scncite{Pau1990}. Более поздние англоязычные работы в данной области в основном ориентированы на решение конкретных частных \textit{задач} в системах, построенных на основе стандартов \textit{W3C}, о которых более подробно было сказано выше.

Таким образом, можно сказать, что существует ряд конкретных разработок в направлении построения \textit{комплексных технологий разработки интеллектуальных систем} различных классов, в том числе с использованием \textit{библиотек многократно используемых компонентов}, однако проблема разработки комплексной технологии построения \textit{гибридных решателей задач} в рамках рассмотренных подходов не решена. Во многом это обусловлено отсутствием унифицированной формальной основы для представления любых \textit{видов знаний}, в том числе различного рода программ, отсутствием строгих принципов, регламентирующих процесс построения \textit{решателей задач}, а также средств поддержки разработчиков таких \textit{решателей задач} и их компонентов.

\subsection*{Предлагаемый подход к разработке гибридных решателей задач ostis-систем и обработке информации в ostis-системах}
\label{subsec_ps_proposed_approach}

Рассмотрим принципы, лежащие в основе предлагаемого подхода к разработке \textit{гибридных решателей задач}:

\begin{textitemize}
\item в качестве основы для построения модели гибридного \textit{решателя задач} предлагается использовать \textit{многоагентный подход}. Данный подход позволяет обеспечить основу для построения параллельных асинхронных систем, имеющих распределенную архитектуру, повысить модифицируемость и производительность разработанных \textit{решателей задач};
\item процесс решения любой \textit{задачи} предлагается декомпозировать на \textit{логически атомарные действия}, что также позволит обеспечить совместимость и модифицируемость \textit{решателей задач};
\item \textit{решатель задач} (как объединенный, так и \textit{решатель задач} частного вида) предлагается рассматривать как иерархическую систему, состоящую из нескольких взаимосвязанных уровней. Такой подход позволяет обеспечить возможность проектирования, отладки и верификации компонентов на разных уровнях независимо от других уровней, что существенно упрощает задачу построения \textit{решателя задач} за счет снижения накладных расходов;
\item предлагается записывать \myuline{всю} информацию о решателе и решаемых им задачах при помощи \textit{SC-кода} в той же \textit{базе знаний}, что и собственно предметные \textit{знания} системы. В общем случае такая информация включает: 

	\begin{textitemize}
	\item \textit{спецификацию агентов}, входящих в состав \textit{решателя задач}; 
	\item \textit{спецификацию методов}, интерпретируемых \textit{агентами} \textit{решателя задач}; 
	\item спецификацию всех \textit{информационных процессов}, выполняемых агентами в \textit{семантической памяти}, в том числе -- конструкции, обеспечивающие синхронизацию выполнения параллельных процессов;
	\item спецификацию всех \textit{задач}, на решение которых направлены указанные \textit{информационные процессы}. 
	\end{textitemize}

Описание всей указанной информации в единой семантической  памяти позволит, во-первых, обеспечить независимость разрабатываемых \textit{решателей задач} от \textit{ostis-платформы}, во-вторых, обеспечить возможность системы анализировать происходящие в ней процессы, оптимизировать и синхронизировать их выполнение, то есть обеспечить \textit{рефлексивность} проектируемых \textit{интеллектуальных систем}.
\end{textitemize}

Ориентация на \textit{многоагентный подход} как основу для построения \textit{гибридных решателей задач} обусловлена следующими основными преимуществами такого подхода (см. \scncite{Wooldridge2009}):
\begin{textitemize}
\item автономность (независимость) \textit{агентов} в рамках такой системы, что позволяет локализовать изменения, вносимые в \textit{решатель задач} при его эволюции, и снизить соответствующие трудозатраты, а также обеспечить устойчивость такой системы к отказам некоторых агентов;
\item децентрализация обработки, то есть отсутствие единого контролирующего центра, что также позволяет локализовать вносимые в \textit{решатель задач} изменения;
\item возможность параллельной работы разных \textit{информационных процессов}, соответствующих как одному \textit{агенту}, так и разным агентам, как следствие, -- возможность распределенного решения задач. Однако возможность параллельного выполнения \textit{информационных процессов} подразумевает наличие средств синхронизации такого выполнения, разработка которых является отдельной задачей и подробно рассматривается ниже;
\item активность \textit{агентов} и \textit{многоагентной системы} в целом, дающая возможность при общении с такой системой не указывать явно способ решения поставленной \textit{задачи}, а формулировать задачу в \textbf{декларативном ключе}.
\end{textitemize}

Построение модели \textit{многоагентной системы} требует уточнения модели каждого компонента, входящего в ее состав, а именно:
\begin{textitemize}
\item \textbf{модель собственно агента}, входящего в состав такой системы, включая классификацию таких \textit{агентов} и набор понятий, характеризующих каждый агент в рамках системы. В настоящее время наиболее популярной является модель \textit{BDI} (belief-desire-intention), в рамках которой предполагается описывать на соответствующих языках "убеждения"{}, "желания"{} и "намерения"{} каждого агента системы;
\item \textbf{модель среды}, в рамках которой находятся агенты, на события в которой они реагируют и в рамках которой могут осуществлять некоторые преобразования. Обзор разновидностей сред для многоагентных систем приводится в работе \scncite{Weyns2007};
\item \textbf{модель коммуникации агентов}, в рамках которой уточняется язык взаимодействия \textit{агентов} (структура и классификация сообщений) и способ передачи сообщений между \textit{агентами}.
\end{textitemize}

В свою очередь, для разработки модели коммуникации \textit{агентов} необходимо отдельно уточнить каждый из ее компонентов:

\begin{textitemize}
\item \textbf{Принципы обмена сообщениями между агентами}, то есть то, каким образом эти сообщения передаются от \textit{агента} к \textit{агенту};
\item \textbf{Классификацию, семантику и прагматику таких сообщений}, то есть \textit{смысл} передаваемой информации и цель такого взаимодействия. В настоящее время стандартами, описывающими структуру передаваемых агентами сообщений, являются \textit{Agent Communication Language} (\textit{ACL}) (см. \scncite{ACL}), разработанный сообществом \textit{FIPA}, язык \textit{KQML} (см. \scncite{Finin1994}). Указанные стандарты уточняют базовые компоненты каждого сообщения (кодировка, язык сообщения, используемую онтологию понятий, получателя, отправителя и так далее), не ограничивая при этом \textit{смысл} сообщения в целом. Также для коммуникации между агентами используется язык \textit{KIF}, предназначенный для обмена \textit{знаниями} между любыми программными компонентами (см. \scncite{KIF}); 
\item \textbf{Принципы координации деятельности агентов}
В литературе рассматривается большое число вариантов координации деятельности \textit{агентов}. В работе \scncite{Hartung2008} предлагается выделить агенты более высокого уровня (\textit{метаагенты}), \textit{задачей} которых является сбор информации от \textit{агентов} нижнего уровня и их координация, схожие идеи высказываются в работе \scncite{Sims2008}. В работах \scncite{Excelente-Toledo2004}, \scncite{NagendraPrasad1999} предлагаются варианты автоматического выбора оптимального механизма координации \textit{агентов} для достижения общей цели. Предлагаются также социально-психологические модели координации деятельности \textit{агентов}, например, на основе некоторых общих "законов"{} (см. \scncite{Vasconcelos2009}) или эмоций (см. \scncite{Rumbell2012}). В работе \scncite{Gorodetsky2015} предложен вариант онтологии коллективного поведения автономных \textit{агентов}.
\end{textitemize}

К основным недостаткам большинства популярных современных средств построения \textit{многагентных систем} (см. \scncite{Bordini2007}, \scncite{Castillo2014}, \scncite{EVE}, \scncite{GAMA},	\scncite{GOAL}, \scncite{Evertsz2004}, \scncite{JADE}, \scncite{Boissier2013}) можно отнести следующие:
\begin{textitemize}
\item жесткая ориентация большинства средств на модель \textit{BDI} приводит к существенным накладным расходам, связанным с необходимостью выражения конкретной практической \textit{задачи} в системе понятий \textit{BDI}. В то же время ориентация на модель \textit{BDI} неявно провоцирует искусственное разделение языков, описывающих собственно компоненты \textit{BDI} и знания \textit{агента} о внешней среде, что приводит к отсутствию \textit{унификации представления} и, соответственно, дополнительным накладным расходам;
\item большинство современных средств построения \textit{многоагентных систем} ориентированы на представление \textit{знаний} \textit{агента} при помощи узкоспециализированных языков, зачастую не предназначенных для представления \textit{знаний} в широком смысле. Речь при этом идет как о знаниях агента о себе самом, так и \textit{знаниях} о внешней среде. В некоторых подходах вначале строится онтология, для создания которой, однако, часто используются средства с низкой выразительной способностью, не предназначенные для построения \textit{онтологий} (см. \scncite{Evertsz2004}, \scncite{JADE}). В конечном итоге такой подход приводит к сильной ограниченности возможностей построенных \textit{многоагентных систем} и их несовместимости;
\item абсолютное большинство современных средств предполагает, что взаимодействие \textit{агентов} осуществляется путем обмена сообщениями непосредственно от \textit{агента} к \textit{агенту} или посредством специальных коммуникационных центров (см. \scncite{Omicini1999}), например, в случае взаимодействия \textit{агентов} в глобальной сети. Такой подход обладает существенным недостатком, связанным с тем, что в этом случае каждый \textit{агент} системы должен иметь достаточно полную информацию о других агентах в системе, что приводит к дополнительным затратам ресурсов, кроме того, добавление или удаление одного или нескольких \textit{агентов} приводит к необходимости оповещения об этом других \textit{агентов}. Данная проблема решается путем организации общения агентов по принципу "доски объявлений"{} (см. \scncite{Jagannathan1989}), предполагающему, что сообщения помещаются в некоторую общую для всех агентов область, при этом каждый \textit{агент} в общем случае может не знать, какому из агентов адресовано сообщение и от какого из \textit{агентов} получено то или иное сообщение. Кроме того, в построенной таким образом системе легче обеспечивается параллельное решение несвязанных друг с другом \textit{задач}, поскольку сообщения, относящиеся к одной \textit{задаче}, будут игнорироваться агентами, решающими другую задачу. Однако данный подход не исключает проблему, связанную с необходимостью разработки специализированного языка взаимодействия \textit{агентов}, который в общем случае не связан с языком, на котором описываются \textit{знания} \textit{агента} о решаемых \textit{задачах} и окружающей среде;
\item многие средства построения \textit{многоагентных систем} построены таким образом, что логический уровень взаимодействия \textit{агентов} жестко привязан к физическому уровню реализации \textit{многоагентной системы}. Например, при передаче сообщений от агента к агенту разработчику \textit{многоагентной системы} необходимо помимо семантически значимой информации указывать ip-адрес компьютера, на котором расположен \textit{агент-получатель}, кодировку, с помощью которой закодирован текст сообщения, и другую техническую информацию, обусловленную исключительно особенностями текущей реализации средств;
\item в большинстве подходов среда, с которой взаимодействуют \textit{агенты}, уточняется отдельно разработчиком для каждой \textit{многоагентной системы}, что с одной стороны, расширяет возможности применения соответствующих средств, но, с другой стороны, приводит к существенным накладным расходам и несовместимости таких многоагентных систем. Кроме того, в ряде случаев разработчик также обязан учитывать особенности технической реализации средств разработки в плане их стыковки с предполагаемой средой, в роли которой может выступать, например, локальная или глобальная сеть.
\end{textitemize}

Перечисленные недостатки предполагается устранять за счет использования следующих принципов:
\begin{textitemize}
\item коммуникацию агентов предлагается осуществлять по принципу \textit{"доски объявлений"{}}, однако в отличие от классического подхода в роли сообщений выступают спецификации в общей семантической памяти выполняемых \textit{агентами} \textit{действий}, направленных на решение каких-либо задач, а в роли среды коммуникации выступает сама эта \textit{семантическая память}. Такой подход позволяет: 
	\begin{textitemize}
	\item исключить необходимость разработки специализированного языка для обмена сообщениями;
	\item обеспечить "обезличенность"{} общения, то есть каждый из \textit{агентов} в общем случае не знает, какие еще агенты есть в системе, кем сформулирован и кому адресован тот или иной запрос. Таким образом, добавление или удаление агентов в систему не приводит к изменениям в других \textit{агентах}, что обеспечивает модифицируемость всей системы;
	\item агентам, в том числе конечному пользователю, формулировать задачи в \textit{декларативном ключе}, то есть не указывать для каждой задачи способ ее решения. Таким образом, агенту заранее не нужно знать, каким образом система решит ту или иную задачу, достаточно лишь специфицировать конечный результат;
	\item сделать средства коммуникации \textit{агентов} и синхронизации их деятельности более понятными разработчику и пользователю системы, не требующими изучения специальных низкоуровневых типов данных и форматов сообщений. Таким образом повышается доступность предлагаемых решений широкому кругу разработчиков.
	\end{textitemize}
\vspace{-2\parskip}
Следует отметить, что такой подход позволяет при необходимости организовать обмен сообщениями между \textit{агентами} напрямую и, таким образом, может являться основой для моделирования многоагентных систем, предполагающих другие способы взаимодействия между \textit{агентами}.
\vspace{\parskip}
\item в роли внешней среды для агентов выступает та же \textit{семантическая память}, в которой формулируются задачи и посредством которой осуществляется взаимодействие \textit{агентов}. Такой подход обеспечивает унификацию среды для различных систем \textit{агентов}, что, в свою очередь, обеспечивает их совместимость;
\item спецификация каждого агента описывается средствами \textit{SC-кода} в \textit{базе знаний}, что позволяет:
	\begin{textitemize}
	\item минимизировать число специализированных средств, необходимых для спецификации агентов, как языковых, так и инструментальных;
	\item с одной стороны -- минимизировать необходимую в общем случае спецификацию агента, которая включает условие его инициирования и \textit{программу}, описывающую алгоритм работы \textit{агента}, с другой стороны -- обеспечить возможность произвольного расширения спецификации для каждого конкретного случая, в том числе возможность реализации модели \textit{BDI} и других;
	\end{textitemize}
\item синхронизацию деятельности \textit{агентов} предполагается осуществлять на уровне выполняемых ими процессов, направленных на решений тех или иных задач в \textit{семантической памяти}. Таким образом, каждый агент трактуется как некий абстрактный процессор, способный решать задачи определенного класса. При таком подходе необходимо решить задачу обеспечения взаимодействия параллельных асинхронных процессов в общей \textit{семантической памяти}, для решения которой можно заимствовать и адаптировать решения, применяемые в традиционной \textit{линейной памяти}. При этом вводится дополнительный класс агентов -- \textit{метаагенты}, задачей которых является решение возникающих проблемных ситуаций, таких как \textit{взаимоблокировки};
\item каждый \textit{информационный процесс} в любой момент времени имеет ассоциативный доступ к необходимым фрагментам \textit{базы знаний}, хранящейся в семантической памяти, за исключением фрагментов, заблокированных другими процессами в соответствии  с рассмотренным ниже механизмом синхронизации. Таким образом, с одной стороны, исключается необходимость хранения каждым агентом информации о внешней среде, с другой стороны, каждый \textit{агент}, как и в классических \textit{многоагентных системах}, обладает только частью всей информации, необходимой для решения задачи. 
	
Важно отметить, что в общем случае невозможно априори предсказать, какие именно знания, модели и способы решения задач понадобятся системе для решения конкретной задачи. В связи с этим необходимо обеспечить, с одной стороны, возможность доступа ко всем необходимым фрагментам \textit{базы знаний} (в пределе -- ко всей \textit{базе знаний}), с другой стороны -- иметь возможность локализовать область поиска пути решения \textit{задачи}, например, рамками одной \textit{предметной области}.
	
Каждый из \textit{агентов} обладает набором ключевых элементов (как правило, понятий), которые он использует в качестве отправных точек при ассоциативном поиске в рамках \textit{базы знаний}. Набор таких элементов для каждого \textit{агента} уточняется на этапах проектирования \textit{решателя задач}. Уменьшение числа ключевых элементов \textit{агента} делает его более универсальным, однако снижает эффективность его работы за счет необходимости выполнения дополнительных операций.
\end{textitemize}

Кроме \textit{многоагентного подхода}, в основу принципов решения задачи в рамках \textit{Технологии OSTIS} предлагается положить ряд идей, связанных с концепцией \textit{ситуационного управления}, рассмотренной в работе \textit{Д.А. Поспелова} \scncite{Pospelov1986}. До настоящего времени попытки реализации указанной концепции, несмотря на ее актуальность и востребованность, сводились к частным решениям для конкретных \textit{классов задач} и, к сожалению, не получили широкого распространения. В значительной степени это обусловлено отсутствием универсальной унифицированной основы, которая бы позволила на ее базе создавать языки ситуационного управления в применении к конкретным предметным областям и, что еще более важно, повторно использовать фрагменты описаний на таких языках.

Данную проблему можно решить используя предлагаемый в рамках \textit{Технологии OSTIS} \textit{SC-код} и семейство \textit{онтологий верхнего уровня}, разработанных на его основе. В частности, реализации идей ситуационного управления способствуют такие принципы, как:
\begin{textitemize}
	\item \textit{SC-код} как базовый язык для описания любой информации в \textit{базе знаний} и, соответственно, для построения языков ситуационного управления на его основе;
	\item \textit{Базовая денотационная семантика \textit{SC-кода}}, которая позволяет обеспечить возможность формального уточнения всех используемых понятий в виде формального набора \textit{онтологий}, что позволяет обеспечить совместимость разрабатываемых систем и возможность повторного использования их компонентов;
	\item \textit{агентно-ориентированный подход} к обработке информации, предполагающий реакцию \textit{агентов} на возникновение в \textit{базе знаний} определенных \textit{ситуаций} и \textit{событий}.
\end{textitemize}

Учитывая рассмотренные выше принципы реализации \textit{многоагентного подхода} и \textit{ситуационного управления} в рамках \textit{Технологии OSTIS}, сформулируем более детально основные принципы, лежащие в основе подхода к обработке информации, предлагаемого в \textit{Технологии OSTIS}:

\begin{textitemize}
	\item В основе \textit{решателя задач} каждой \textit{ostis-системы} лежит многоагентная система, агенты которой взаимодействуют между собой \uline{только}(!) через общую для них \textit{sc-память} посредством спецификации в этой памяти выполняемых ими \textit{действий в sc-памяти}. При этом пользователи \textit{ostis-системы} также считаются \textit{агентами} этой системы. Кроме того, \textbf{\textit{sc-агенты}} делятся на внутренние, рецепторные и эффекторные. Взаимодействие между \textit{агентами} через общую \textbf{\textit{sc-память}} сводится к следующим видам действий:
	\begin{textitemize}
		\item К использованию общедоступной для соответствующей группы \textit{sc-агентов} части хранимой \textit{базы знаний};
		\item К формированию (генерации) новых фрагментов \textit{базы знаний} и/или к корректировке (редактированию) каких-либо фрагментов доступной части \textit{базы знаний};
		\item К интеграции (погружению) новых (обновленных) фрагментов в состав доступной части \textit{базы знаний};
	\end{textitemize}
	\vspace{-2\parskip}
	Подчеркнем, что \textit{sc-агенты} не общаются между собой напрямую путем отправки сообщений, как это делается в большинстве современных подходов к построению \textit{многоагентных систем}. Кроме того, \textit{sc-агенты} имеют доступ к общей для них базе знаний за счет чего гарантируется семантическая совместимость (взаимопонимание) между агентами, включая и пользователей \textit{ostis-систем}.
	\vspace{\parskip}
	\item Пользователь \textit{ostis-системы} не может сам непосредственно выполнить какое-либо \textit{действие} в \mbox{sc-памяти}, но он может средствами \textit{пользовательского интерфейса} инициировать построение (генерацию, формирование в \textit{sc-памяти}) \textit{sc-текста}, являющегося спецификацией \textit{действия в \mbox{sc-памяти}}, выполняемого либо одним \textit{атомарным sc-агентом} за один акт, либо одним \textit{атомарным sc-агентом} за несколько актов, либо коллективом \textit{sc-агентов} (\textit{неатомарным sc-агентом}). В спецификации каждого такого \textit{действия в sc-памяти}, инициированного пользователем, этот пользователь указывается как заказчик этого действия. Таким образом, пользователь \textit{ostis-системы} дает поручения (задания, команды) \textit{sc-агентам} этой системы на выполнение различных специфицируемых им действий в \textit{sc-памяти}.
	
	\item Каждый \textit{sc-агент}, выполняя некоторое \textit{действие в sc-памяти}, должен "помнить"{}, что \textit{sc-память}, над которой он работает, является общим ресурсом не только для него, но и для всех остальных \textit{\mbox{sc-агентов}}, работающих над этой же \textit{sc-памятью}. Поэтому \textit{sc-агент} должен соблюдать определенную этику поведения в коллективе таких \textit{sc-агентов}, которая должна минимизировать помехи, которые он создает другим \textit{sc-агентам}.
	
	\item Деятельность каждого агента \textit{ostis-системы} дискретна и представляет собой множество элементарных действий (актов). При этом при выполнении каждого акта агент может устанавливать блокировки нескольких типов на фрагменты базы знаний. Указанные блокировки позволяют запретить другим агентам изменять указанный фрагмент базы знаний или вообще сделать его "невидимым"{} для других агентов. Блокировки устанавливаются самим агентом при выполнении соответствующего акта и снимаются им же на последнем этапе выполнения этого акта или раньше, если это возможно.
	\item Если некий \textit{sc-агент} выполняет некоторое \textit{действие в sc-памяти}, то он на время выполнения этого действия может:
	\begin{textitemize}
		\item Запретить другим \textit{sc-агентам} изменять состояние некоторых sc-элементов, хранимых в \textit{sc-памяти} -- удалять их, изменять тип;
		\item Запретить другим \textit{sc-агентам} добавлять или удалять элементы некоторых множеств, обозначаемых соответствующими \textit{sc-узлами};
		\item Запретить другим \textit{sc-агентам} доступ на просмотр некоторых \textit{sc-элементов}, то есть эти \textit{\mbox{sc-элементы}} становятся полностью "невидимыми"{} (полностью заблокированными) для других \textit{sc-агентов} но только на время выполнения соответствующего \textit{действия}.
	\end{textitemize}
	\vspace{-2\parskip}
	Указанные блокировки должны быть полностью сняты до завершения выполнения соответствующего \textit{действия}. Подчеркнем, что число \textit{sc-элементов}, блокируемых на время выполнения некоторого действия, в основном входят атомарные и неатомарные связки, и не должны входить \textit{sc-узлы}, обозначающие бесконечные классы каких-либо сущностей, и, тем более, \textit{sc-узлы}, обозначающие различные \textit{понятия} (ключевые классы различных предметных областей).
	\vspace{\parskip}
	Этичное (неэгоистичное) поведение \textit{sc-агента}, касающееся блокировки \textit{sc-элементов} (то есть ограничения к ним доступа другим \textit{sc-агентам}) предполагает соблюдение следующих правил:
	\begin{textitemize}
		\item Не следует блокировать больше \textit{sc-элементов}, чем это необходимо для решения задачи;
		\item Как только для какого-либо \textit{sc-элемента} необходимость его блокировки отпадает до завершения выполнения соответствующего действия, этот \textit{sc-элемент} желательно сразу деблокировать;
	\end{textitemize}
	\vspace{-2\parskip}
	Для того, чтобы \textit{sc-агент} имел возможность работы с каким-либо произвольным \textit{sc-элементом}, он должен либо убедиться в том, что этот \textit{sc-элемент} не входит во фрагмент базы знаний, входящий в \textit{полную блокировку}, либо убедиться в том, что эта блокировка не установлена самим этим агентом. Особой группой полностью заблокированных \textit{sc-элементов} (на время выполнения действия \textit{\mbox{sc-агентом}}) являются вспомогательные \textit{sc-элементы} ("леса"{}), создаваемые только на время выполнения этого действия. Эти sc-элементы в конце выполнения действия должны не деблокироваться, а удаляться.
	\vspace{\parskip}
	
	\item Если \textit{действие в sc-памяти}, выполняемое \textit{sc-агентом}, завершилось (то есть стало прошлой сущностью), то \textit{sc-агент} оформляет результат этого \textit{действия}, указывая (1) удаленные \textit{sc-элементы} и (2) сгенерированные sc-элементы. Это необходимо, если по каким-либо причинам придется сделать откат этого \textit{действия}, т.е возвратиться к состоянию базы знаний до выполнения указанного \textit{действия}.
\end{textitemize}

Перечислим некоторые достоинства предлагаемого подхода к организации обработки знаний в \textit{ostis-системах}:
\begin{textitemize}
	\item поскольку обработка осуществляется \textit{агентами}, которые обмениваются сообщениями только через общую память, добавление нового агента или исключение (деактивация) одного или нескольких существующих \textit{агентов}, как правило, не приводит к изменениям в других \textit{агентах}, поскольку агенты не обмениваются сообщениями напрямую;
	\item инициирование \textit{агентов} осуществляется децентрализованно и чаще всего независимо друг от друга, таким образом, даже существенное расширение числа агентов в рамках одной системы не приводит к ухудшению ее производительности;
	\item спецификации \textit{агентов} и, как будет показано ниже, их программы могут быть записаны на том же языке, что и обрабатываемые знания, что существенно сокращает перечень специализированных средств, предназначенных для проектирования таких \textit{агентов} и их коллективов, а также их анализа, верификации и оптимизации, и упрощает разработку системы за счет использования более универсальных компонентов.
\end{textitemize}



\section*{Внутренние агенты, выполняющие действия в sc-памяти -- sc-агенты}
\label{sec_ps_agents}

\begin{SCn}
	\scnheader{класс действий}
	\scnsuperset{класс действий в sc-памяти}
	\begin{scnindent}
		\scnrelto{семейство подмножеств}{действие в sc-памяти}
	\end{scnindent}
	
	\begin{scnrelfromset}{разбиение}
		
		\scnitem{класс логически атомарных действий}
		\begin{scnindent}
			\scnidtf{класс автономных действий}
			\scnsuperset{класс логически атомарных действий в sc-памяти}
		\end{scnindent}
		\scnitem{класс логически неатомарных действий}
		\begin{scnindent}
			\scnidtf{класс неавтономных действий}
		\end{scnindent}
	\end{scnrelfromset}
\end{SCn}

Каждое \textit{действие}, принадлежащее некоторому конкретному \textit{классу логически атомарных действий}, обладает двумя необходимыми свойствами:
\begin{textitemize}
	\item выполнение действия не зависит от того, является ли указанное действие частью декомпозиции более общего действия. При выполнении данного действия также не должен учитываться тот факт, что данное действие предшествует каким-либо другим действиям или следует за ними (что явно указывается при помощи отношения \textit{последовательность действий*});
	\item указанное действие должно представлять собой логически целостный акт преобразования, например, в семантической памяти. Такое действие по сути является транзакцией, то есть результатом такого преобразования становится новое состояние преобразуемой системы, а выполняемое действие должно быть либо выполнено полностью, либо не выполнено совсем, частичное выполнение не допускается. 
\end{textitemize}

В то же время логическая атомарность не запрещает декомпозировать выполняемое действие на более частные, каждое из которых, в свою очередь, также будет являться логически атомарным.

На логически \textit{атомарные действия} предлагается делить всю деятельность, направленную на решение каких-либо задач \textit{ostis-системой}. Соответственно \textit{решатель задач ostis-системы} предлагается делить на компоненты, соответствующие таким \textit{классам логически атомарных действий в sc-памяти}, что является основой для обеспечения его \textit{модифицируемости}. Такие компоненты решателя названы \textit{sc-агентами}.

В свою очередь под \textit{методом} понимается описание того, как может быть выполнено любое или почти любое (с явным указанием исключений) действие, принадлежащее соответствующему \textit{классу действий}. Поскольку конкретному \textit{классу действий} ставится в соответствие некоторый конкретный \textit{класс задач}, то можно сказать, что метод описывает способ решения любых задач принадлежащих заданному классу. Понятие метода можно считать обобщением понятия "программа"{}, в связи с чем в рамках \textit{Технологии OSTIS} термины "метод"{} и "программа"{} являются синонимичными.

Примером конкретного метода может быть \textit{процедурная программа} на конкретном \textit{языке программирования}, или множество логических высказываний, составляющих \textit{формальную теорию} заданной \textit{предметной области} (аналог \textit{логической программы}). 

Частным случаем метода является программа атомарного компонента \textit{решателя задач ostis-системы} (\textit{атомарного sc-агента}), в этом случае в качестве \textit{операционной семантики метода} выступает коллектив агентов более низкого уровня, интерпретирующий соответствующую \textit{программу} (в предельном случае это будут агенты, являющиеся частью \textit{ostis-платформы}, в том числе аппаратной реализации).

В свою очередь, навык трактуется как объединение некоторого \textit{метода} и его операционной семантики, то есть информации о том, каким образом должен интерпретироваться данный \textit{метод}.

Таким образом, можно говорить об \myuline{иерархии \textit{методов}} и о \textit{методах} интерпретации других \textit{методов}, а также, соответственно, об \myuline{иерархии \textit{навыков}}, которыми обладает \textit{ostis-система} на данный момент времени.

\begin{SCn}
\scnheader{sc-агент}
\scnidtf{единственный вид \textit{субъектов}, выполняющих преобразования в \textit{\textit{sc-памяти}}}
\scnidtf{\textit{субъект}, способный выполнять \textit{действия в sc-памяти}, принадлежащие некоторому определенному \textit{классу логически атомарных действий}}
\end{SCn}

Логическая атомарность выполняемых \textit{sc-агентом} \textit{действий} предполагает, что каждый \textit{sc-агент} реагирует на соответствующий ему класс \textit{ситуаций} и/или \textit{событий}, происходящих в sc-памяти, и осуществляет определенное преобразование \textit{sc-текста}, находящегося в семантической окрестности обрабатываемой \textit{ситуации} и/или \textit{события}. При этом каждый sc-агент в общем случае не имеет информацию о том, какие еще \textit{sc-агенты} в данный момент присутствуют в системе и осуществляет взаимодействие в другими \textit{sc-агентами} исключительно посредством формирования некоторых конструкций (как правило --- спецификаций действий) в общей \textit{sc-памяти}. Таким сообщением может быть, например, вопрос, адресованный другим \textit{sc-агентам} в системе (заранее не известно, каким конкретно), или ответ на поставленный другими \textit{sc-агентами} вопрос (заранее не известно, каким конкретно). Таким образом, каждый \textit{sc-агент} в каждый момент времени контролирует только фрагмент \textit{базы знаний} в контексте решаемой данным агентом \textit{задачи}, состояние всей остальной \textit{базы знаний} в общем случае непредсказуемо для \textit{sc-агента}.

Поскольку предполагается, что копии одного и того же \textit{sc-агента} или функционально эквивалентные \textit{sc-агенты} могут работать в разных \textit{ostis-системах}, будучи при этом физически разными \textit{sc-агентами}, то целесообразно рассматривать свойства и классификацию не \textit{sc-агентов}, а классов функционально эквивалентных \textit{sc-агентов}, которые будем называть \textbf{\textit{абстрактными sc-агентами}}.
Под \textbf{\textit{абстрактным sc-агентом}} понимается некоторый класс функционально эквивалентных \textit{sc-агентов}, разные экземпляры (то есть представители) которого могут быть реализованы по-разному.
	
Каждый \textbf{\textit{абстрактный sc-агент}} имеет соответствующую ему спецификацию. В спецификацию каждого \textbf{\textit{абстрактного sc-агента}} входит:
\begin{textitemize}
	\item указание ключевых \textit{sc-элементов} этого \textit{sc-агента}, то есть тех \textit{sc-элементов}, хранимых в \textit{sc-памяти}, которые для данного \textit{sc-агента} являются «точками опоры»;
	\item формальное описание условий инициирования данного \textit{sc-агента}, то есть тех \textit{ситуаций} в \textit{sc-памяти}, которые инициируют деятельность данного \textit{sc-агента};
	\item формальное описание первичного условия инициирования данного \textit{sc-агента}, то есть такой \textit{ситуации в sc-памяти}, которая побуждает \textit{sc-агента} перейти в активное состояние и начать проверку наличия своего полного условия инициирования (для \textit{внутренних абстрактных sc-агентов});
	\item строгое, полное, однозначно понимаемое описание деятельности данного \textit{sc-агента}, оформленное при помощи каких-либо понятных, общепринятых средств, не требующих специального изучения, например на \textit{естественном языке}.
	\item описание результатов выполнения данного \textit{sc-агента}.
\end{textitemize}

\textit{sc-агенты} можно классифицировать по различным признакам. Поскольку можно говорить об иерархии \textit{методов} (методах интерпретации других методов) и, соответственно, иерархии навыков, то есть необходимость говорить и об иерархии \textit{sc-агентов}, обеспечивающих интерпретацию того или иного метода. В данном контексте можно говорить об иерархии \textit{sc-агентов} в двух аспектах:
\begin{textitemize}
	\item \textit{абстрактному sc-агенту} (и соответственно, \textit{sc-агенту}) может однозначно соответствовать \textit{метод} (\textit{программа sc-агента}), описывающий деятельность данного \textit{sc-агента}. Такие агенты будем называть \textit{атомарными абстрактными sc-агентами};
	\item \textit{абстрактные sc-агенты} иногда целесообразно объединять в коллективы таких агентов, которые можно рассматривать как один целостный \textit{абстрактный sc-агент}, с логической точки зрения работающий по тем же принципам, что и \textit{атомарные абстрактные sc-агенты}, то есть реагирующий на события в \textit{sc-памяти} и описывающий свою деятельность в рамках этой памяти. Такому \textit{абстрактному sc-агенту} не будет соответствовать какой-то конкретный \textit{метод}, хранимый в \textit{sc-памяти}, но остальная часть спецификации \textit{абстрактного sc-агента} (условие инициирования, описание начальной ситуации и результата работы \textit{sc-агента} и так далее) остается такой же, как у \textit{атомарного абстрактного sc-агента}. Таким образом, можно сказать, что понятие атомарности/неатомарности \textit{абстрактного sc-агента} указывает на то, каким образом уточняется реализация данного \textit{абстрактного sc-агента} -- посредством указания конкретного метода (программы \textit{sc-агента}) или посредством декомпозиции \textit{абстрактного sc-агента} на более простые. Важно отметить, что \textit{неатомарные абстрактные sc-агенты} тоже могут входить в состав других, более сложных \textit{неатомарных абстрактных sc-агентов}. Таким образом формируется иерархическая система \textit{абстрактных sc-агентов}, в общем случае имеющая произвольное количество уровней. 
	\item В свою очередь, соответствующий \textit{sc-агенту} метод должен интерпретироваться каким-либо другим \textit{sc-агентом} более низкого уровня, а чаще всего -- коллективом таких агентов, каждому из которых ставится в соответствие свой \textit{метод}, описывающий поведение данного агента, но уже на более низком уровне. Таким образом, можно сказать, что понятие атомарности/неатомарности \textit{абстрактных sc-агентов} применимо в рамках одного \textit{языка описания методов}. В свою очередь можно говорить об иерархии \textit{абстрактных sc-агентов} с точки зрения уровня языка описания соответствующих таким агентам методов. В общем случае такая иерархия тоже может иметь неограниченное число уровней, однако очевидно, что при понижении уровня языка описания методов мы рано или поздно должны подойти к языку описания методов, который будет интерпретироваться агентами, реализуемыми на уровне \textit{ostis-платформы}, а спускаясь еще ниже -- на уровень языка описания методов, интерпретируемых на аппаратном уровне. Таким образом, для обеспечения платформенной независимости \textit{ostis-систем} целесообразно выделить такой язык описания методов, который бы интерпретировался на уровне \textit{ostis-платформы} и являлся основой для разработки интерпретаторов более высокоуровневых языков. В качестве такого языка предлагается \textit{Язык SCP} (Semantic Code Programming), который рассматривается в качестве ассемблера для \textit{ассоциативного семантического компьютера}.
\end{textitemize}

На рисунке \textit{\nameref{fig:agents-hierarchy}} проиллюстрирована иерархия \textit{абстрактных sc-агентов} и соответствующим \textit{атомарным абстрактным sc-агентам} \textit{методов}. Буквой ``М'' на рисунке условно обозначены \textit{методы}, буквами ``АА'' и ``НА'' -- \textit{атомарные абстрактные sc-агенты} и \textit{неатомарные абстрактные sc-агенты} соответственно, сплошными стрелками показана декомпозиция \textit{неатомарных sc-агентов} на более простые, а пунктирными стрелками -- связь между \textit{методами} и их операционной семантикой, то есть \textit{абстрактными sc-агентами}, обеспечивающими интерпретацию этих \textit{методов}. Как показано на приведенной иллюстрации, должна существовать четкая граница между методами, которые описываются на уровне \textit{ostis-платформы}, и методами, которые могут быть описаны и на платформенно-независимом уровне.

\begin{figure}[H]
	\caption*{Рисунок. Иерархия sc-агентов}
	\includegraphics[scale=0.7]{images/part3/chapter_situation_management/agents-hierarchy.png}
	\label{fig:agents-hierarchy}
\end{figure}

Иерархический подход к описанию систем sc-агентов, определяющих операционную семантику \textit{решателей задач ostis-систем}, и соответственно, самих \textit{решателей задач ostis-систем} обладает рядом важных преимуществ, таких как обеспечение модифицируемости решателей и удобство их проектирования и отладки на разных уровнях.

Сказанное выше позволяет описать классификацию \textit{абстрактных sc-агентов} по признаку атомарности:

\begin{SCn}
	\scnheader{абстрактный sc-агент}
	\begin{scnrelfromset}{разбиение}
		\scnitem{неатомарный абстрактный sc-агент}
		\scnitem{атомарный абстрактный sc-агент}
	\end{scnrelfromset}
\end{SCn}

Под \textbf{\textit{неатомарным абстрактным sc-агентом}} понимается \textit{абстрактный sc-агент}, который декомпозируется на коллектив более простых \textit{абстрактных sc-агентов}, каждый из которых в свою очередь может быть как \textit{атомарным абстрактным sc-агентом}, так и \textbf{\textit{неатомарным абстрактным sc-агентом}}. При этом в каком либо варианте \textit{декомпозиции абстрактного sc-агента*} дочерний \textbf{\textit{неатомарный абстрактный sc-агент}} может стать \textit{атомарным абстрактным sc-агентом}, и реализовываться соответствующим образом.

Под \textbf{\textit{атомарным абстрактным sc-агентом}} понимается \textit{абстрактный sc-агент}, для которого уточняется способ его реализации, то есть существует соответствующая связка отношения \textit{программа sc-агента*}. Подчеркнем при этом, что в рамках конкретной \textit{ostis-системы} для каждого \textit{языка представления методов} может существовать своя иерархия \textit{абстрактных sc-агентов}.

В свою очередь, более подробно рассматриваемый ниже Базовый язык программирования ostis-систем (\textit{Язык SCP}) позволяет установить границу между логико-семантической моделью \textit{ostis-системы} и \textit{ostis-платформой}. В связи с этим будем считать платформенно-независимыми \textit{абстрактные sc-агенты}, реализованные на \textit{Языке SCP} или более высокоуровневых языках на его основе, а платформенно-зависимыми \textit{абстрактные sc-агенты}, которые реализованы на уровне \textit{ostis-платформы} (например, с целью повышения их производительности). В то же время существует ряд \textit{абстрактных sc-агентов}, которые принципиально не могут быть реализованы на \textit{Языке SCP}. Сказанное отражено в следующей иерархии:

\begin{SCn}
\scnheader{абстрактный sc-агент}
\begin{scnrelfromset}{разбиение}
	\scnitem{внутренний абстрактный sc-агент}
	\scnitem{эффекторный абстрактный sc-агент}
	\scnitem{рецепторный абстрактный sc-агент}
\end{scnrelfromset}
\begin{scnrelfromset}{разбиение}
	\scnitem{абстрактный sc-агент, не реализуемый на Языке SCP}
	\scnitem{абстрактный sc-агент, реализуемый на Языке SCP}
\end{scnrelfromset}
\begin{scnrelfromset}{разбиение}
	\scnitem{абстрактный sc-агент интерпретации scp-программ}
	\scnitem{абстрактный программный sc-агент}
\end{scnrelfromset}

\begin{scnrelfromset}{разбиение}	
	\scnitem{платформенно-зависимый абстрактный sc-агент}
	\begin{scnindent}
		\scnsuperset{абстрактный sc-агент, не реализуемый на Языке SCP}
	\end{scnindent}
	\scnitem{платформенно-независимый абстрактный sc-агент}
\end{scnrelfromset}

\scnheader{абстрактный sc-агент}
\begin{scnrelfromset}{разбиение}
	\scnitem{абстрактный sc-агент, не реализуемый на Языке SCP}
	\scnitem{абстрактный sc-агент, реализуемый на Языке SCP}
\end{scnrelfromset}
\begin{scnrelfromset}{разбиение}	
	\scnitem{платформенно-зависимый абстрактный sc-агент}
	\begin{scnindent}
		\scnsuperset{абстрактный sc-агент, не реализуемый на Языке SCP}
	\end{scnindent}
	\scnitem{платформенно-независимый абстрактный sc-агент}
\end{scnrelfromset}

\scnheader{абстрактный sc-агент, не реализуемый на Языке SCP}
\scnidtf{абстрактный sc-агент, который не может быть реализован на платформенно-независимом уровне}
\begin{scnrelfromset}{разбиение}
	\scnitem{эффекторный абстрактный sc-агент}
	\scnitem{рецепторный абстрактный sc-агент}
	\scnitem{абстрактный sc-агент интерпретации scp-программ}
\end{scnrelfromset}

\scnheader{абстрактный программный sc-агент}
\begin{scnrelfromset}{разбиение}
	\scnitem{эффекторный абстрактный sc-агент}
	\scnitem{рецепторный абстрактный sc-агент}
	\scnitem{абстрактный программный sc-агент, реализуемый на Языке SCP}
\end{scnrelfromset}	

\end{SCn}

К \textbf{\textit{платформенно-независимым абстрактным \mbox{sc-агентам}}} относят \textit{атомарные абстрактные sc-агенты}, реализованные на базовом языке программирования \textit{Технологии OSTIS}, то есть на \textit{Языке SCP}.

При описании \textbf{\textit{платформенно-независимых абстрактных sc-агентов}} под \textit{платформенной независимостью} понимается платформенная независимость с точки зрения \textit{Технологии OSTIS}, то есть реализация на специализированном \textit{языке программирования}, ориентированном на обработку семантических сетей (\textit{Языке SCP}), поскольку \textit{атомарные sc-агенты}, реализованные на указанном языке могут свободно переноситься с одной \textit{ostis-платформы} на другую. При этом языки программирования, традиционно считающиеся платформенно-независимыми, в данном случае не могут считаться таковыми.

Существуют \textit{sc-агенты}, которые принципиально не могут быть реализованы на платформенно-независимом уровне, например, собственно \textit{sc-агенты} интерпретации \textit{sc-моделей} или рецепторные и эффекторные \textit{sc-агенты}, обеспечивающие взаимодействие с внешней средой.

К \textbf{\textit{платформенно-зависимым абстрактным sc-агентам}} относят \textit{атомарные абстрактные sc-агенты}, реализованные ниже уровня sc-моделей, то есть не на \textit{Языке SCP}, а на каком-либо другом языке описания \textit{программ}.

Каждый \textbf{\textit{внутренний абстрактный sc-агент}} обозначает класс \textit{sc-агентов}, которые реагируют на события в \textit{sc-памяти} и осуществляют преобразования исключительно в рамках этой же \textit{sc-памяти}.

Каждый \textbf{\textit{эффекторный абстрактный sc-агент}} обозначает класс \textit{sc-агентов}, которые реагируют на события в \textit{sc-памяти} и осуществляют преобразования во внешней относительно данной \textit{ostis-системы} среде.

Каждый \textbf{\textit{рецепторный абстрактный sc-агент}} обозначает класс \textit{sc-агентов}, которые реагируют на события во внешней относительно данной \textit{ostis-системы} среде и осуществляют преобразования в памяти данной системы.

Каждый \textbf{\textit{абстрактный sc-агент, не реализуемый на Языке SCP}} должен быть реализован на уровне \textit{ostis-платформы}, в том числе, аппаратной. К таким \textit{абстрактным sc-агентам} относятся \textit{абстрактные sc-агенты интерпретации scp-программ}, а также \textit{эффекторные} и \textit{рецепторные абстрактные sc-агенты}.

Каждый \textbf{\textit{абстрактный sc-агент, реализуемый на Языке SCP}} может быть реализован на \textit{Языке SCP}, то есть платформенно-независимом уровне, но при необходимости, может реализовываться и на уровне \textit{ostis-платформы}, например, с целью повышения производительности.

К \textbf{\textit{абстрактным sc-агентам интерпретации scp-программ}} относятся не реализуемые на платформенно-независимом уровне \textit{абстрактные sc-агенты}, обеспечивающие интерпретацию \textit{scp-программ} и \textit{\mbox{scp-метапрограмм}}, в том числе создание \textit{scp-процессов}, собственно интерпретацию \textit{scp-операторов}, а также другие вспомогательные действия. По сути, агенты данного класса обеспечивают работу sc-агентов более высоких уровней (\textit{программных sc-агентов} и \textit{sc-метаагентов}), реализованных\textit{ на Языке SCP}, в частности, обеспечивают соблюдение указанными \textit{агентами} общих принципов синхронизации.

К \textbf{\textit{абстрактным программным sc-агентам}} относятся все \textit{абстрактные sc-агенты}, обеспечивающие основной функционал системы, то есть ее возможность решать те или иные задачи. Агенты данного класса должны работать в соответствии с общими принципами синхронизации деятельности субъектов в sc-памяти.

\begin{SCn}
\scnheader{декомпозиция абстрактного sc-агента*}
\scniselement{отношение декомпозиции}
\scnrelfrom{первый домен}{неатомарный абстрактный sc-агент}
\end{SCn}

Отношение \textbf{\textit{декомпозиции абстрактного sc-агента*}} трактует \textit{неатомарные абстрактные sc-агенты} как коллективы более простых \textit{абстрактных sc-агентов}, взаимодействующих через \textit{sc-память}.
	
Другими словами, \textbf{\textit{декомпозиция абстрактного sc-агента*}} на \textit{абстрактные sc-агенты} более низкого уровня уточняет один из возможных подходов к реализации этого \textit{абстрактного sc-агента} путем построения коллектива более простых \textit{абстрактных sc-агентов}.

\begin{SCn}
\scnheader{sc-агент}
\scnidtf{агент над sc-памятью}
\scnsubset{субъект}
\scnrelfrom{семейство подмножеств}{абстрактный sc-агент}
\end{SCn}

Под \textbf{\textit{sc-агентом}} понимается конкретный экземпляр (с теоретико-множественной точки зрения - элемент) некоторого \textit{атомарного абстрактного sc-агента}, работающий в какой-либо конкретной интеллектуальной системе.
	
Таким образом, каждый \textit{sc-агент} - это субъект, способный выполнять некоторый класс однотипных действий либо только над \textit{sc-памятью}, либо над sc-памятью и внешней средой (для эффекторных \textit{sc-агентов}). Каждое такое действие инициируется либо состоянием или ситуацией в sc-памяти, либо состоянием или ситуацией во внешней среде (для рецепторных sc-агентов-датчиков),  соответствующей условию инициирования \textit{атомарного абстрактного sc-агента}, экземпляром которого является заданный \textit{sc-агент}. В данном случае можно провести аналогию между принципами объектно-ориентированного программирования, рассматривая \textit{атомарный абстрактный sc-агент} как класс, а конкретный \textit{sc-агент} --- как экземпляр, конкретную имплементацию этого класса.
	
Взаимодействие \textit{sc-агентов} осуществляется только через \textit{sc-память}. Как следствие, результатом работы любого \textit{sc-агента} является некоторое изменение состояния \textit{sc-памяти}, то есть удаление либо генерация каких-либо \textit{sc-элементов}.
	
В общем случае один \textit{sc-агент} может явно передать управление другому \textit{sc-агенту}, если этот \textit{sc-агент} априори известен. Для этого каждый \textit{sc-агент} в \textit{sc-памяти} имеет обозначающий его \textit{sc-узел}, с которым можно связать конкретную ситуацию в текущем состоянии \textit{базы знаний}, которую инициируемый \textit{sc-агент} должен обработать.

В процессе работы \textit{sc-агент} может сам для себя порождать вспомогательные \textit{sc-элементы}, которые сам же удаляет после завершения акта своей деятельности (это вспомогательные \textit{структуры}, которые используются в качестве "информационных лесов"{} только в ходе выполнения соответствующего акта деятельности и после завершения этого акта удаляются).

\section*{Базовый язык программирования ostis-систем}

\bigskip

Выделение Базового языка программирования для ostis-систем позволяет обеспечить четкое разделение уровня методов и соответственно, навыков ostis-системы, которые могут быть полностью описаны на уровне базы знаний и более низкоуровневых навыков, обеспечивающих интерпретацию указанных навыков более высокого уровня. Другими словами, выделение такого языка позволяет обеспечить \uline{платформенную независимость} ostis-систем, как в случае программной реализации \textit{ostis-платформы}, так и в случае \textit{ассоциативного семантического компьютера}.

В качестве базового языка для описания программ обработки текстов \textit{SC-кода} предлагается \textit{Язык SCP}. \textbf{\textit{Язык SCP}} -- это графовый язык процедурного программирования, предназначенный для эффективной обработки \textit{sc-текстов}. \textit{Язык SCP} является языком параллельного асинхронного программирования.

\bigskip
\bigskip

\begin{SCn}
	\scnheader{Язык SCP}
	\scnidtftext{часто используемый sc-идентификатор}{\textbf{\textit{scp-программа}}}
\end{SCn}

Языком представления данных для текстов \textit{Языка SCP} (\textit{scp-программ}) является \textit{SC-код} и, соответственно, любые варианты его внешнего представления. \textit{Язык SCP} сам построен на основе \textit{SC-кода}, вследствие чего \textit{scp-программы} сами по себе могут входить в состав обрабатываемых данных для \textit{scp-программ}, в том числе по отношению к самим себе. Таким образом, \textit{Язык SCP} предоставляет возможность построения реконфигурируемых программ. Однако для обеспечения возможности реконфигурирования программы непосредственно в процессе ее интерпретации необходимо на уровне интерпретатора \textit{Языка SCP (Aбстрактной scp-машины)} обеспечить уникальность каждой исполняемой копии исходной \textit{программы}. Такую исполняемую копию, сгенерированную на основе \textit{scp-программы}, будем называть \textit{scp-процессом}.
Включение знака некоторого \textit{действия в sc-памяти} во множество \textit{scp-процессов} гарантирует тот факт, что в декомпозиции данного действия будут присутствовать только знаки элементарных действий (\textit{scp-операторов}), которые может интерпретировать реализация \textit{Aбстрактной scp-машины} (интерпретатора scp-программ).

\textit{Язык SCP} рассматривается как ассемблер для \textit{ассоциативного семантического компьютера}.

\begin{SCn}
	\scnheader{Абстрактная scp-машина}
	\scniselement{scp-машина}
	\begin{scnindent}
		\scnrelto{обобщенная модель}{scp-интерпретатор}
	\end{scnindent}
\end{SCn}

\textit{Базовая модель обработки sc-текстов} включает в себя \textit{Предметную область Базового языка программирования ostis-систем}, то есть описание \textit{Синтаксиса} и \textit{Денотационной семантики Языка SCP}, а также описание \textit{Абстрактной scp-машины}, которая является моделью \textit{scp-интерпретатора}, который должен являться частью \textit{ostis-платформы} (хотя в общем случае могут существовать варианты платформы, не содержащие такого интерпретатора, что, однако, не позволит использовать достоинства предлагаемой базовой модели.

Рассмотрим ключевые особенности и достоинства \textit{Базовой модели обработки sc-текстов}:
\begin{textitemize}
	\item Тексты программ \textit{Языка SCP} записываются при помощи тех же унифицированных семантических сетей, что и обрабатываемая информация, таким образом, можно сказать, что \textit{Синтаксис Языка SCP} на базовом уровне совпадает с \textit{Синтаксисом SC-кода}.\item Подход к интерпретации \textit{scp-программ} предполагает создание при каждом вызове \textit{scp-программы} уникального \textit{scp-процесса}.
	\item Одновременно в общей памяти могут выполняться несколько независимых \textit{sc-агентов}, при этом разные копии \textit{sc-агентов} могут выполняться на разных серверах, за счет распределенной реализации \textit{ostis-платформы}. Более того, \textit{Язык SCP} позволяет осуществлять параллельные асинхронные вызовы подпрограмм с последующей синхронизацией, и даже параллельно	выполнять операторы в рамках одной \textit{scp-программы}.
	\item Перенос \textit{sc-агента} из одной системы в другую заключается в простом переносе фрагмента \textit{базы знаний}, без каких-либо дополнительных операций, зависящих от \textit{ostis-платформы}.
	\item Тот факт, что спецификации \textit{sc-агентов} и их программы могут быть записаны на том же языке, что и обрабатываемые знания, существенно сокращает перечень специализированных средств, предназначенных для проектирования машин обработки знаний, и упрощает их разработку за счет использования более универсальных компонентов.
	\item Тот факт, что для интерпретации \textit{scp-программы} создается соответствующий ей уникальный \textit{\mbox{scp-процесс}}, позволяет по возможности оптимизировать план выполнения перед его реализацией и даже непосредственно в процессе выполнения без потенциальной опасности испортить общий универсальный алгоритм всей программы. Более того, такой подход к проектированию и интерпретации программ позволяет говорить о возможности создания самореконфигурируемых программ.
\end{textitemize}

\begin{SCn}
\scnheader{scp-программа}
\scnsubset{программа в sc-памяти}
\scnsuperset{агентная scp-программа}
\end{SCn}

Каждая \textbf{\textit{scp-программа}} представляет собой обобщенную \textit{sc-структуру}, описывающую один из вариантов декомпозиции действий некоторого класса, выполняемых в sc-памяти. Знак \textit{sc-переменной}, соответствующей конкретному декомпозируемому действию является в рамках \textbf{\textit{scp-программы}} \textit{ключевым sc-элементом\scnrolesign}. Также явно указывается принадлежность данного знака множеству \textit{scp-процессов}.
	
Принадлежность некоторого действия множеству \textit{scp-процессов} гарантирует тот факт, что в декомпозиции данного действия будут присутствовать только знаки элементарных действий (\textit{scp-операторов}), которые может интерпретировать реализация \textit{Абстрактной scp-машины}.

Таким образом, каждая \textbf{\textit{scp-программа}} описывает в обобщенном виде декомпозицию некоторого \textit{\mbox{scp-процесса}} на взаимосвязанные \textit{scp-операторы}, с указанием, при их наличии, аргументов для данного \textit{scp-процесса}.

По сути каждая \textbf{\textit{scp-программа}} представляет собой описание последовательности элементарных операций, которые необходимо выполнить над семантической сетью, чтобы выполнить более сложное действие некоторого класса.

На рисунке \textit{\nameref{fig:program_example}} приведен пример простой \textit{scp-программы}. В приведенном примере показана \textit{scp-программа}, состоящая из трех \textit{scp-операторов}. Данная программа проверяет, содержится ли в заданном множестве (первый параметр) заданный элемент (второй параметр), и, если нет, то добавляет его в это множество.
	
\begin{figure}[H]
	\caption*{SCg-текст. Пример scp-программы}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/program_example.png}
	\label{fig:program_example}
\end{figure}

\textbf{\textit{агентные scp-программы}} представляют собой частный случай \textit{scp-программ} вообще, однако заслуживают отдельного рассмотрения, поскольку используются наиболее часто. \textit{scp-программы} данного класса представляют собой реализации программ агентов обработки знаний, и имеют жестко фиксированный набор параметров. Каждая такая программа имеет ровно два \textit{in-параметра\scnrolesign}. Значение первого параметра является знаком бинарной ориентированной пары, являющейся вторым компонентом связки отношения \textit{первичное условие инициирования*} для абстрактного \textit{sc-агента}, в множество \textit{программ sc-агента*} которого входит рассматриваемая \textbf{\textit{агентная scp-программа}}, и, по сути, описывает класс событий, на которые реагирует указанный sc-агент.
	
Значением второго параметра является \textit{sc-элемент}, с которым непосредственно связано событие, в результате возникновения которого был инициирован соответствующий \textit{sc-агент}, то есть, например, сгенерированная либо удаляемая \textit{sc-дуга} или \textit{sc-ребро}.

Под \textbf{\textit{scp-процессом}} понимается некоторое \textit{действие в sc-памяти}, однозначно описывающее конкретный акт выполнения некоторой \textit{scp-программы} для заданных исходных данных. Если \textit{scp-программа} описывает алгоритм решения какой-либо задачи в общем виде, то \textit{scp-процесс} обозначает конкретное действие, реализующее данный алгоритм для заданных входных параметров.

По сути, \textbf{\textit{scp-процесс}} представляет собой уникальную копию, созданную на основе \textit{scp-программы}, в которой каждой \textit{sc-переменной}, за исключением \textit{scp-переменных\scnrolesign}, соответствует сгенерированная \textit{sc-константа}.

Принадлежность некоторого действия множеству \textit{scp-процессов} гарантирует тот факт, что в декомпозиции данного действия будут присутствовать только знаки элементарных действий (\textit{scp-операторов}), которые может интерпретировать реализация \textit{Абстрактной scp-машины}.

Рассмотрим пример поэтапного выполнения scp-процесса (\textit{\nameref{fig:process_example}} -- \textit{\nameref{fig:process_example4}}), соответствующего ранее рассмотренному примеру scp-программы. В приведенном примере последовательно показаны состояния \textit{scp-процесса}, соответствующего \textit{\mbox{scp-программе}}, добавляющей заданный элемент в заданное множество, если он там ранее не содержался. В примере предполагается, что рассматриваемый элемент (\textit{Element1}) изначально не содержится во множестве (\textit{Set1}).

\begin{figure}[H]
	\caption*{SCg-текст. Пример scp-процесса на начальной стадии выполнения}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/process_example.png}
	\label{fig:process_example}
\end{figure}

Осуществляется вызов \textit{scp-программы}. Генерируется соответствующий \textit{scp-процесс}. Происходит инициирование начального оператора scp-процесса \textit{Operator1}.

\begin{figure}[H]
	\caption*{SCg-текст. Пример scp-процесса: безуспешно выполнен оператор поиска}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/process_example2.png}
	\label{fig:process_example2}
\end{figure}

Оператор \textit{Operator1} оказался безуспешно выполненным. Производится инициирование \textit{\mbox{scp-оператора} генерации трехэлементной конструкции} ~~~ \textit{Operator2}.

\begin{figure}[H]
	\caption*{SCg-текст. Пример scp-процесса: выполнен оператор генерации, элемент добавлен во множество}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/process_example3.png}
	\label{fig:process_example3}
\end{figure}

Оператор \textit{Operator2} выполнился. Производится инициирование \textit{scp-оператора завершения выполнения программы} ~~~ \textit{Operator3}.

\begin{figure}[H]
	\caption*{SCg-текст. Пример scp-процесса: выполнение завершено}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/process_example4.png}
	\label{fig:process_example4}
\end{figure}

Оператор \textit{Operator3} выполнился. Выполнение \textit{scp-процесса} завершается.

\begin{SCn}
\scnheader{scp-оператор}
\scnsubset{действие в sc-памяти}
\scnrelto{семейство подмножеств}{атомарный тип scp-оператора}
\end{SCn}

Каждый \textbf{\textit{scp-оператор}} представляет собой некоторое элементарное \textit{действие в sc-памяти}. Аргументы \textit{scp-оператора} будем называть операндами. Порядок операндов указывается при помощи соответствующих ролевых отношений (\textit{1\scnrolesign}, \textit{2\scnrolesign}, \textit{3\scnrolesign} и так далее). Операнд, помеченный ролевым отношением \textit{1\scnrolesign}, будем называть первым операндом, помеченный ролевым отношением \textit{2\scnrolesign} --- вторым операндом, и т.д. Тип и смысл каждого операнда также уточняется при помощи различных подклассов отношения \textit{scp-операнд\scnrolesign}. В общем случае операндом может быть любой \textit{sc-элемент}, в том числе, знак какой-либо \textit{scp-программы}, в том числе самой программы, содержащей данный оператор.

Каждый \textbf{\textit{scp-оператор}} должен иметь один и более операнд, а также указание того \textbf{\textit{scp-оператора}} (или нескольких), который должен быть выполнен следующим. Исключение их данного правила составляет \textit{scp-оператор завершения выполнения программы}, который не содержит ни одного операнда и после выполнения которого никакие \textit{scp-операторы} в рамках данной программы выполняться не могут.

Каждый \textbf{\textit{атомарный тип scp-оператора}} представляет собой класс \textit{scp-операторов}, который не разбивается на более частные, и, соответственно, интерпретируется реализацией \textit{Aбстрактной scp-машины}.

\begin{SCn}
\scnheader{начальный оператор\scnrolesign}
\scnsubset{1\scnrolesign}
\end{SCn}

Ролевое отношение \textbf{\textit{начальный оператор\scnrolesign}} указывает в рамках декомпозиции соответствующего \textit{\mbox{scp-программе}} \textit{scp-процесса} те \textit{scp-операторы}, которые должны быть выполнены в первую очередь, то есть те, с которых собственно начинается выполнение \textit{scp-процесса}.

\begin{SCn}
\scnheader{параметр scp-программы\scnrolesign}
\scnsubset{аргумент действия\scnrolesign}
\begin{scnrelfromset}{разбиение}
	\scnitem{in-параметр\scnrolesign}
	\scnitem{out-параметр\scnrolesign}
\end{scnrelfromset}
\end{SCn}

Ролевое отношение \textbf{\textit{параметр scp-программы\scnrolesign}} связывает знак соответствующего \textit{scp-программе} \textit{\mbox{scp-процесса}} с его аргументами.

Параметры типа \textbf{\textit{in-параметр\scnrolesign}} хоть и соответствуют \textit{переменным scp-программы\scnrolesign}, не могут менять значение в процессе ее интерпретации. Фиксированное значение переменной устанавливается при создании уникальной копии \textit{scp-программы} (\textit{scp-процесса}) для ее интерпретации, и, таким образом, соответствующая \textit{scp-переменная\scnrolesign} на момент начала ее интерпретации становится \textit{scp-константой\scnrolesign} в рамках каждого \textit{scp-оператора}, в котором встречалась данная \textit{scp-переменная\scnrolesign}. Использование \textit{in-параметров} можно рассматривать по аналогии с использованием варианта механизма передачи по значению в традиционных языках программирования, с тем условием, что значение локальной переменной в рамках дочерней программы не может быть изменено.

Параметры типа \textbf{\textit{out-параметр\scnrolesign}} соответствуют \textit{переменным scp-программы\scnrolesign} и обладают всеми теми же соответствующими свойствами. Чаще всего предполагается, что значение данного параметра необходимо родительской \textit{scp-программе}, содержащей оператор вызова текущей \textit{scp-программы}. При этом на момент начала интерпретации в качестве параметра дочернему процессу передается непосредственно узел, обозначающий переменную (а точнее, ее уникальную копию в рамках процесса) родительского процесса. Указанная переменная может при необходимости иметь значение, либо не иметь. После завершения и во время интерпретации дочернего процесса родительский процесс по-прежнему может работать с переменной, переданной в качестве \textit{out-параметра\scnrolesign}, при необходимости просматривая или изменяя ее значение. Использование out-параметра можно рассматривать по аналогии с использованием механизма передачи по ссылке в традиционных \textit{языках программирования}.

Рассмотрим классификацию \textit{sc-конструкций} с точки зрения \textit{Базовой модели обработки sc-текстов}.

\begin{SCn}
\scnheader{sc-конструкция}
\scnrelfrom{разбиение}{Классификация sc-конструкций с точки зрения Базовой модели обработки sc-текстов}
\begin{scnindent}
	\begin{scneqtoset}
		\scnitem{sc-конструкция нестандартного вида}
		\scnitem{sc-конструкция стандартного вида}
	\end{scneqtoset}
\begin{scnindent}
\begin{scnrelfromset}{разбиение}
	\scnitem{одноэлементная sc-конструкция}
	\scnitem{трехэлементная sc-конструкция}
	\scnitem{пятиэлементная sc-конструкция}	
\end{scnrelfromset}
\end{scnindent}
\end{scnindent}
\end{SCn}

Каждая \textit{sc-конструкция нестандартного вида} состоит из произвольного количества \textit{sc-элементов} произвольного типа (\textit{\nameref{fig:pic_ps4}}).

\begin{figure}[H]
	\caption*{SCg-текст. Пример sc-конструкции нестандартного вида}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/pic_ps1.png}
	\label{fig:pic_ps1}
\end{figure}

В свою очередь, каждый элемент \textit{\mbox{sc-конструкции} стандартного вида} имеет свою условную строго фиксированную позицию в рамках этой \mbox{sc-конструкции} (первый элемент, второй элемент и так далее). В зависимости от указанной позиции вводятся дополнительные ограничения на тип соответствующего \textit{sc-элемента}.

Каждая \textit{одноэлементная sc-конструкция} состоит из одного \textit{sc-элемента} произвольного типа (Рис. \textit{\nameref{fig:pic_ps2}}).

\begin{figure}[H]
	\caption*{SCg-текст. Пример одноэлементных sc-конструкций в SCg-коде}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/pic_ps2.png}
	\label{fig:pic_ps2}
\end{figure}

Каждая \textit{трехэлементная sc-конструкция} состоит из трех \textit{sc-элементов} (Рис. \textit{\nameref{fig:pic_ps3}}). Второй элемент всегда является \textit{sc-коннектором}, остальные элементы могут быть произвольного типа.

\begin{figure}[H]
	\caption*{SCg-текст. Пример трехэлементной sc-конструкции в SCg-коде}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/pic_ps3.png}
	\label{fig:pic_ps3}
\end{figure}

Каждая \textit{пятиэлементная sc-конструкция} состоит из пяти \textit{sc-элементов} (Рис. \textit{\nameref{fig:pic_ps4}}). Второй и четвертый элементы обязательно являются \textit{sc-коннекторами}, остальные элементы могут быть произвольного типа.

\begin{figure}[H]
	\caption*{SCg-текст. Пример пятиэлементной sc-конструкции в SCg-коде}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/pic_ps4.png}
	\label{fig:pic_ps4}
\end{figure}

\subsection*{Денотационная семантика Базового языка программирования ostis-систем}
\label{subsec_scp_denot}

\begin{SCn}
\scnheader{scp-оператор}
\scnsubset{действие в sc-памяти}
\scnrelto{семейство подмножеств}{атомарный тип scp-оператора}
\begin{scnrelfromset}{разбиение}
	\scnitem{scp-оператор генерации конструкций}
	\begin{scnindent}
		\begin{scnrelfromset}{разбиение}
			\scnitem{scp-оператор генерации конструкции по произвольному образцу}
			\scnitem{scp-оператор генерации пятиэлементной конструкции}
			\scnitem{scp-оператор генерации трехэлементной конструкции}
			\scnitem{scp-оператор генерации одноэлементной конструкции}
		\end{scnrelfromset}
	\end{scnindent}
	\scnitem{scp-оператор ассоциативного поиска конструкций}
	\begin{scnindent}
		\begin{scnrelfromset}{разбиение}
			\scnitem{scp-оператор поиска конструкции по произвольному образцу}
			\scnitem{scp-оператор поиска пятиэлементной конструкции с формированием множеств}
			\scnitem{scp-оператор поиска трехэлементной конструкции с формированием множеств}
			\scnitem{scp-оператор поиска пятиэлементной конструкции}
			\scnitem{scp-оператор поиска трехэлементной конструкции}
		\end{scnrelfromset}
	\end{scnindent}
	\scnitem{scp-оператор удаления конструкций}
	\begin{scnindent}
		\begin{scnrelfromset}{разбиение}
			\scnitem{scp-оператор удаления множества элементов трехэлементной конструкции}
			\scnitem{scp-оператор удаления одноэлементной конструкции}
			\scnitem{scp-оператор удаления пятиэлементной конструкции}
			\scnitem{scp-оператор удаления трехэлементной конструкции}
		\end{scnrelfromset}
	\end{scnindent}
	\scnitem{scp-оператор проверки условий}
	\begin{scnindent}
		\begin{scnrelfromset}{разбиение}
			\scnitem{scp-оператор сравнения числовых содержимых файлов}
			\scnitem{scp-оператор проверки равенства числовых содержимых файлов}
			\scnitem{scp-оператор проверки совпадения значений операндов}
			\scnitem{scp-оператор проверки наличия содержимого у файла}
			\scnitem{scp-оператор проверки наличия значения у переменной}
			\scnitem{scp-оператор проверки типа sc-элемента}
		\end{scnrelfromset}
	\end{scnindent}
	\scnitem{scp-оператор управления значениями операндов}
	\begin{scnindent}
		\begin{scnrelfromset}{разбиение}
			\scnitem{scp-оператор удаления значения переменной}
			\scnitem{scp-оператор присваивания значения переменной}
		\end{scnrelfromset}
	\end{scnindent}
	\scnitem{scp-оператор управления scp-процессами}
	\begin{scnindent}
		\begin{scnrelfromset}{разбиение}
			\scnitem{scp-оператор удаления значения переменной}
			\scnitem{scp-оператор завершения выполнения программы}
			\scnitem{конъюнкция предшествующих scp-операторов}
			\scnitem{scp-оператор ожидания завершения выполнения множества scp-программ}
			\scnitem{scp-оператор ожидания завершения выполнения scp-программы}
			\scnitem{scp-оператор асинхронного вызова подпрограммы}
		\end{scnrelfromset}
	\end{scnindent}
	\scnitem{scp-оператор управления событиями}
	\begin{scnindent}
		\scnsuperset{scp-оператор ожидания события}
	\end{scnindent}
	\scnitem{scp-оператор обработки содержимых файлов}
	\begin{scnindent}
		\begin{scnrelfromset}{разбиение}
			\scnitem{scp-оператор вычисления арксинуса числового содержимого файла}
			\scnitem{scp-оператор вычисления арккосинуса числового содержимого файла}
			\scnitem{scp-оператор деления числовых содержимых файлов}
			\scnitem{scp-оператор умножения числовых содержимых файлов}
			\scnitem{scp-оператор вычитания числовых содержимых файлов}
			\scnitem{scp-оператор сложения числовых содержимых файлов}
			\scnitem{scp-оператор вычисления тангенса числового содержимого файла}
			\scnitem{scp-оператор вычисления косинуса числового содержимого файла}
			\scnitem{scp-оператор вычисления синуса числового содержимого файла}
			\scnitem{scp-оператор вычисления логарифма числового содержимого файла}
			\scnitem{scp-оператор возведения числового содержимого файла в степень}
			\scnitem{scp-оператор удаления содержимого файла}
			\scnitem{scp-оператор копирования содержимого файла}
			\scnitem{scp-оператор нахождения остатка от деления числовых содержимых файлов}
			\scnitem{scp-оператор нахождения целой части от деления числовых содержимых файлов}
			\scnitem{scp-оператор вычисления арктангенса числового содержимого файла}
			\scnitem{scp-оператор перевода в верхний регистр строкового содержимого файла}
			\scnitem{scp-оператор перевода в верхний регистр строкового содержимого файла}
			\scnitem{scp-оператор замены определенной части строкового содержимого файла на содержимое указанной файла}
			\scnitem{scp-оператор проверки совпадения конца строкового содержимого файла со строковом содержимым другого файла}
			\scnitem{scp-оператор проверки совпадения начальной части строкового содержимого файла со строковом содержимым другого файла}
			\scnitem{scp-оператор получения части строкового содержимого файла по индексам}
			\scnitem{scp-оператор поиска строкового содержимого файла в строковом содержимом другого файла}
			\scnitem{scp-оператор вычисления длины строкового содержимого файла}
			\scnitem{scp-оператор разбиения строки на подстроки}
			\scnitem{scp-оператор лексикографического сравнения строковых содержимых файлов}
			\scnitem{scp-оператор проверки равенства строковых содержимых файлов}
		\end{scnrelfromset}
	\end{scnindent}
	\scnitem{scp-оператор управления блокировками}
	\begin{scnindent}
		\begin{scnrelfromset}{разбиение}
			\scnitem{scp-оператор снятия всех блокировок данного scp-процесса}
			\scnitem{scp-оператор снятия блокировки с sc-элемента}
			\scnitem{scp-оператор установки полной блокировки на sc-элемент}
			\scnitem{scp-оператор установки блокировки на изменение sc-элемента}
			\scnitem{scp-оператор установки блокировки на удаление sc-элемента}
			\scnitem{scp-оператор снятия блокировки со структуры}
			\scnitem{scp-оператор установки полной блокировки на структуру}
			\scnitem{scp-оператор установки блокировки на изменение структуры}
			\scnitem{scp-оператор установки блокировки на удаление структуры}
		\end{scnrelfromset}
	\end{scnindent}
\end{scnrelfromset}

\scnheader{scp-операнд\scnrolesign}
\scnsubset{аргумент действия\scnrolesign}
\scniselement{неосновное понятие}
\scniselement{ролевое отношение}
\begin{scnrelfromset}{разбиение}
	\scnitem{scp-константа\scnrolesign}
	\scnitem{scp-переменная\scnrolesign}
\end{scnrelfromset}	
\begin{scnrelfromset}{разбиение}
	\scnitem{scp-операнд с заданным значением\scnrolesign}
	\scnitem{scp-операнд со свободным значением\scnrolesign}
\end{scnrelfromset}	
\begin{scnrelfromset}{разбиение}
	\scnitem{константный sc-элемент\scnrolesign}
	\scnitem{переменный sc-элемент\scnrolesign}
\end{scnrelfromset}	
\begin{scnrelfromlist}{включение}
	\scnitem{формируемое множество\scnrolesign}
	\begin{scnindent}
		\begin{scnrelfromset}{разбиение}
			\scnitem{формируемое множество 1\scnrolesign}
			\scnitem{формируемое множество 2\scnrolesign}
			\scnitem{формируемое множество 3\scnrolesign}
			\scnitem{формируемое множество 4\scnrolesign}
			\scnitem{формируемое множество 5\scnrolesign}
		\end{scnrelfromset}	
	\end{scnindent}
	\scnitem{удаляемый sc-элемент\scnrolesign}
	\scnitem{тип sc-элемента\scnrolesign}
	\begin{scnindent}
	\begin{scnrelfromset}{разбиение}
		\scnitem{sc-узел\scnrolesign}
		\begin{scnindent}
			\begin{scnrelfromset}{разбиение}
				\scnitem{структура\scnrolesign}
				\scnitem{отношение\scnrolesign}
				\begin{scnindent}
					\scnsuperset{ролевое отношение\scnrolesign}
				\end{scnindent}
			\scnitem{класс\scnrolesign}
			\end{scnrelfromset}	
		\end{scnindent}
		\scnitem{sc-дуга\scnrolesign}
		\begin{scnindent}
			\begin{scnrelfromset}{разбиение}
				\scnitem{sc-дуга общего вида\scnrolesign}
				\scnitem{sc-дуга принадлежности\scnrolesign}
				\begin{scnindent}
					\scnsuperset{sc-дуга основного вида\scnrolesign}
					\begin{scnindent}
					\scneq{(константный sc-элемент\scnrolesign $\cap$ позитивная sc-дуга принадлежности\scnrolesign $\cap$ постоянная sc-дуга принадлежности\scnrolesign)}
					\end{scnindent}					
					\begin{scnrelfromset}{разбиение}
						\scnitem{позитивная sc-дуга принадлежности\scnrolesign}
						\scnitem{негативная sc-дуга принадлежности\scnrolesign}
						\scnitem{нечеткая sc-дуга принадлежности\scnrolesign}
					\end{scnrelfromset}
					\begin{scnrelfromset}{разбиение}
						\scnitem{временная sc-дуга принадлежности\scnrolesign}
						\scnitem{постоянная sc-дуга принадлежности\scnrolesign}
					\end{scnrelfromset}
				\end{scnindent}
			\end{scnrelfromset}
		\end{scnindent}
		\scnitem{sc-ребро\scnrolesign}
		\scnitem{файл\scnrolesign}
	\end{scnrelfromset}
	\end{scnindent}
\end{scnrelfromlist}
\end{SCn}

Ролевое отношение \textit{scp-операнд\scnrolesign} является неосновным понятием и указывает на принадлежность аргументов \textit{scp-оператору}. Помимо указания какого-либо класса \textit{scp-операндов\scnrolesign} порядок аргументов \textit{scp-оператора} дополнительно уточняется \textit{ролевыми отношениями 1\scnrolesign}, \textit{2\scnrolesign} и так далее

В рамках \textit{scp-программы} \textbf{\textit{scp-константы\scnrolesign}} явно участвуют в \textit{\mbox{scp-операторах}} в качестве элементов (в теоретико-множественном смысле) и напрямую обрабатываются при интерпретации \textit{scp-программы}. Константами в рамках \textit{scp-программы} могут быть \textit{sc-элементы} любого типа, как \textit{\mbox{sc-константы}}, так и \textit{\mbox{sc-переменные}}. Константа в рамках \textit{scp-программы} остается неизменной в течение всего срока интерпретации. Константа \textit{\mbox{scp-программы}} может быть рассмотрена как переменная, значение которой совпадает с самой переменной в каждый момент времени, и изменено быть не может. Таким образом, далее будем считать, что \textit{scp-константа\scnrolesign} и ее значение это одно и то же. Каждый \textit{in-параметр\scnrolesign} при интерпретации каждой конкретной копии \textit{scp-программы} становится \textit{scp-константой\scnrolesign} в рамках всех ее операторов, хотя в исходном теле данной программы в каждом из этих операторов он является \textit{scp-переменной\scnrolesign}.

В рамках \textit{scp-программы} \textbf{\textit{scp-переменные\scnrolesign}} не обрабатываются явно при интерпретации, обрабатываются значения переменных. Каждая переменная \textit{scp-программы} может иметь одно значение в каждый момент времени, то есть представляет собой ситуативный \textit{синглетон}, элементом которого является текущее значение \textit{scp-переменной\scnrolesign}. Значение каждой \textit{scp-переменной\scnrolesign} может меняться в ходе интерпретации \textit{scp-программы}. При этом интерпретатор при обработке \textit{scp-оператора} работает непосредственно со значениями \textit{\mbox{scp-переменных\scnrolesign}}, а не самими \textit{scp-переменными\scnrolesign} (которые также являются узлами той же семантической сети).

Значение операндов, помеченных ролевым отношением \textbf{\textit{scp-операнд с заданным значением\scnrolesign}}, считается заданным в рамках текущего \textit{scp-оператора}. Данное значение учитывается при выполнении \textit{scp-оператора} и остается неизменным после окончания выполнения \textit{scp-оператора}. Каждая \textit{scp-константа\scnrolesign} по умолчанию рассматривается как \textit{scp-операнд с заданным значением\scnrolesign}, в связи с чем явное использование данного ролевого отношения в таком случае является избыточным. В таком случае в качестве значения рассматривается непосредственно сам операнд. В случае если отношением \textit{\mbox{scp-операнд} с заданным значением\scnrolesign} помечена \textit{scp-переменная\scnrolesign}, то осуществляется попытка поиска значения для данной \textit{scp-переменной\scnrolesign} (ее элемента). Если попытка оказалась безуспешной, то возникает ошибка времени выполнения, которая должна быть обработана соответствующим образом.
	
Любой \textit{scp-операнд с заданным значением\scnrolesign} независимо от конкретного типа \textit{scp-оператора} может быть \textit{scp-переменной\scnrolesign}.

Значение операндов, помеченных ролевым отношением \textit{scp-операнд со свободным значением\scnrolesign}, считается свободным (не заданным заранее) в рамках текущего \textit{scp-оператора}. В начале выполнения \textit{scp-оператора} связь между \textit{scp-переменной\scnrolesign}, помеченной данным ролевым отношением, и ее элементом (значением) всегда удаляется. В результате выполнения данного оператора может быть либо сгенерировано новое значение \textit{scp-переменной\scnrolesign}, либо не сгенерировано, тогда \textit{scp-переменная\scnrolesign} будет считаться не имеющей значения. Ни одна \textit{scp-константа\scnrolesign} не может быть помечена как \textit{scp-операнд со свободным значением\scnrolesign}, поскольку константа не может изменять свое значение в ходе интерпретации \textit{scp-программы}.

Ролевое отношение \textit{тип \mbox{sc-элемента\scnrolesign}} используется для уточнения типа \textit{sc-элемента}, выступающего в роли значения некоторого операнда. \textit{тип \mbox{sc-элемента\scnrolesign}} имеет смысл указывать только для операндов, помеченных как \textit{scp-операнд со свободным значением\scnrolesign}, тогда данное уточнение типа \textit{\mbox{sc-элемента}} будет использовано для сужения области поиска либо уточнения параметров генерации каких-либо конструкций. Значением \textit{scp-операндов с заданным значением\scnrolesign} является конкретный, известный на момент начала выполнения \textit{scp-оператора sc-элемент} с конкретным типом, не зависящим от указания \textit{типа sc-элемента\scnrolesign}, в связи с чем использование ролевого отношения \textit{тип sc-элемента\scnrolesign} в данном случае является некорректным.

Допускается использование комбинаций семантически непротиворечащих друг другу подмножеств указанного отношения. Например, допускается комбинация \textit{константный sc-элемент\scnrolesign} и \textit{sc-дуга общего вида\scnrolesign}, но не допускается комбинация \textit{sc-узел\scnrolesign} и \textit{sc-дуга\scnrolesign}.

Ролевое отношение \textbf{\textit{формируемое множество\scnrolesign}} используется для указания того факта, что в результате выполнения \textit{scp-оператора} должно быть сформировано либо дополнено некоторое множество \textit{sc-элементов}, являющееся значением одного из операндов данного \textit{scp-оператора}. При этом если данный операнд помечен как \textit{scp-операнд со свободным значением\scnrolesign}, то множество будет сформировано с нуля (сгенерирован новый \textit{sc-элемент}, обозначающий данное множество), в противном случае уже существующее множество может быть дополнено. Использование данного ролевого отношения предполагает, что при его отсутствии множество бы не формировалось, а значением указанного операнда стал бы произвольный \textit{sc-элемент} из данного множества. 

Ролевое отношение \textit{формируемое множество\scnrolesign} без уточнения порядкового номера используется только в \textit{scp-операторах обработки произвольных конструкций}. Для явного указания номера операнда, которому соответствует \textit{формируемое множество\scnrolesign}, используются подмножества данного ролевого отношения, аналогичные ролевым отношениям, задающим порядок элементов в кортеже (\textit{1\scnrolesign, 2\scnrolesign, 3\scnrolesign} и так далее), например \textit{формируемое множество 1\scnrolesign}, \textit{формируемое множество 2\scnrolesign} и так далее. Указанные ролевые отношения используются только в \textit{scp-операторах поиска конструкций с формированием множеств}.

Ролевое отношение \textbf{\textit{удаляемый sc-элемент\scnrolesign}} используется для указания тех операндов, значение которых должно быть удалено в процессе выполнения \textit{scp-операторов удаления}. Данным ролевым отношением может быть помечен как \textit{scp-операнд с заданным значением\scnrolesign}, так и \textit{scp-операнд со свободным значением\scnrolesign}. При этом удаляемым \textit{sc-элементом} может быть как \textit{scp-константа\scnrolesign}, так и \textit{scp-переменная\scnrolesign} (в случае \textit{scp-переменной\scnrolesign} удаляется не только связка принадлежности между этой \textit{scp-переменной\scnrolesign} и ее значением, но и непосредственно сам \textit{sc-элемент}, являющийся значением).

\begin{SCn}
\scnheader{следует отличать*}
\begin{scnhaselementset}
	\scnitem{scp-переменная\scnrolesign}
	\scnitem{sc-переменная}	
\end{scnhaselementset}
\begin{scnhaselementset}
	\scnitem{scp-константа\scnrolesign}
	\scnitem{sc-константа}	
\end{scnhaselementset}
\end{SCn}

На рисунках \textit{\nameref{fig:genElStr5_fafaa}} -- \textit{\nameref{fig:genElStr5_fafaa_2}} показан пример работы scp-оператора генерации пятиэлементной конструкции. В приведенном примере выполняется генерация пятиэлементной конструкции, которая имеет два scp-операнда с заданным значением. В примере предполагается, что рассматриваемые элементы (some\_node1 и some\_node2) изначально никак не связаны между собой.

\begin{figure}[H]
	\caption*{SCg-текст. Пример выполнения scp-оператора генерации пятиэлементной конструкции (вызов scp-оператора)}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/genElStr5_fafaa.png}
	\label{fig:genElStr5_fafaa}
\end{figure}

\begin{figure}[H]
	\caption*{SCg-текст. Пример выполнения scp-оператора генерации пятиэлементной конструкции (результат выполнения scp-оператора)}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/genElStr5_fafaa_2.png}
	\label{fig:genElStr5_fafaa_2}
\end{figure}

На рисунках \textit{\nameref{fig:searchElStr3_faf}} -- \textit{\nameref{fig:searchElStr3_faf_2}} приведен пример scp-оператора поиска трехэлементной конструкции, которая имеет два scp-операнда с заданным значением. В примере предполагается, что рассматриваемые элементы (some\_node1 и some\_node2) изначально связаны между собой константной постоянной sc-дугой.

\begin{figure}[H]
	\caption*{SCg-текст. Пример выполнения scp-оператора поиска трехэлементной конструкции (вызов scp-оператора)}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/searchElStr3_faf.png}
	\label{fig:searchElStr3_faf}
\end{figure}

\begin{figure}[H]
	\caption*{SCg-текст. Пример выполнения scp-оператора поиска трехэлементной конструкции (результат выполнения scp-оператора)}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/searchElStr3_faf_2.png}
	\label{fig:searchElStr3_faf_2}
\end{figure}

На рисунках \textit{\nameref{fig:erase_edge}} -- \textit{\nameref{fig:erase_edge_2}} показан пример scp-оператора удаления одноэлементной конструкции. В примере предполагается, что рассматриваемые элементы (\textbf{\textit{node1}} и \textbf{\textit{node2}}) изначально связаны между собой базовой sc-дугой принадлежности.

\begin{figure}[H]
	\caption*{SCg-текст. Пример выполнения scp-оператора удаления одноэлементной конструкции (вызов scp-оператора)}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/searchElStr3_faf.png}
	\label{fig:erase_edge}
\end{figure}

\begin{figure}[H]
	\caption*{SCg-текст. Пример выполнения scp-оператора удаления одноэлементной конструкции (результат выполнения scp-оператора)}
	\includegraphics[scale=0.8]{images/part3/chapter_situation_management/searchElStr3_faf_2.png}
	\label{fig:erase_edge_2}
\end{figure}

\subsection*{Операционная семантика Базового языка программирования ostis-систем}
\label{subsec_scp_oper}

Преимущества предложенного многоагентного подхода к обработке информации могут работать не только на платформенно-независимом уровне, но и на более низких уровнях. Так, в частности, интерпретатор \textit{Базового языка программирования ostis-систем} также предлагается строить как \textit{неатомарный абстрактный sc-агент}, обеспечивающий интерпретацию методов, описанных на \textit{Языке SCP}. Таким образом, такой интерпретатор входит в общую иерархию агентов \textit{ostis-системы} и является \textit{абстрактным sc-агентом, не реализуемым на Языке SCP}.

В общем случае вариантов реализации таких интерпретаторов может быть много. В рамках \textit{Стандарта OSTIS} один из них предлагается в качестве стандартного и называется \textit{Абстрактной scp-машиной}.

\begin{SCn}
\scnheader{Абстрактная scp-машина}
\begin{scnrelfromset}{декомпозиция абстрактного sc-агента}
	\scnitem{Абстрактный sc-агент создания scp-процессов}
	\scnitem{Абстрактный sc-агент интерпретации scp-операторов}
	\scnitem{Абстрактный sc-агент синхронизации процесса интерпретации scp-программ}
	\scnitem{Абстрактный sc-агент уничтожения scp-процессов}
	\scnitem{Абстрактный sc-агент синхронизации событий в sc-памяти и ее реализации}
	\begin{scnindent}
	\begin{scnrelfromset}{декомпозиция абстрактного sc-агента}		
		\scnitem{Абстрактный sc-агент трансляции сформированной спецификации события в sc-памяти во внутреннее представление}
		\scnitem{Абстрактный sc-агент обработки события в sc-памяти, инициирующего агентную scp-программу}
	\end{scnrelfromset}
	\end{scnindent}
\end{scnrelfromset}
\end{SCn}

Задачей \textit{Абстрактного sc-агента создания scp-процессов} является создание \textit{scp-процессов}, соответствующих заданной \textit{scp-программе}. Данный \textit{\mbox{sc-агент}} активируется при появлении в \textit{sc-памяти} \textit{инициированного действия}, принадлежащего классу \textit{действие интерпретации scp-программы}.  После проверки \textit{sc-агентом} условия инициирования выполняется создание \textit{scp-процесса} с учетов конкретных параметров интерпретации \textit{\mbox{scp-программы}}, после чего осуществляется поиск \textit{начального оператора\scnrolesign \mbox{scp-процесса}} и добавление его во множество \textit{настоящих сущностей}.

Задачей \textit{Абстрактного sc-агента интерпретации scp-операторов} является собственно интерпретация операторов \textit{scp-программы}, то есть выполнение в \textit{sc-памяти} действий, описываемых конкретным \textit{\mbox{scp-оператором}}. Данный \textit{sc-агент} активируется при появлении в \textit{sc-памяти} \textit{scp-оператора}, принадлежащего классу \textit{настоящих сущностей}. После выполнения действия, описываемого \textit{scp-оператором}, \textit{scp-оператор} добавляется во множество \textit{прошлых сущностей}. В случае когда семантика действия, описываемого \textit{\mbox{scp-оператором}}, предполагает возможность ветвления \textit{scp-программы} после выполнения данного \textit{\mbox{scp-оператора}}, то используется одно из подмножеств класса \textit{выполненных действий -- безуспешно выполненное действие} или \textit{успешно выполненное действие}.

Задачей \textit{Абстрактного sc-агента синхронизации процесса интерпретации scp-программ} является обеспечение переходов между \textit{scp-операторами} в рамках одного \textit{scp-процесса}. Данный \textit{sc-агент} активизируется при добавлении некоторого \textit{scp-оператора} во множество \textit{прошлых сущностей}. Далее осуществляется переход по \textit{sc-дуге}, принадлежащей отношению \textit{последовательность действий*} (или более частным отношениям, в случае, если \textit{\mbox{scp-оператор}} был добавлен во множество \textit{успешно выполненных действий} или \textit{безуспешно выполненных действий}). При этом очередной \textit{scp-оператор} становится \textit{настоящей сущностью} (активным \textit{scp-оператором}) в том случае, если хотя бы один \textit{scp-оператор}, связанный с ним входящими \textit{sc-дугами}, принадлежащими отношению \textit{последовательность действий*} (или более частным отношениям), стал \textit{прошлой сущностью} (или, соответственно, подмножеством прошлых сущностей). В случае, когда необходимо дождаться завершения выполнения всех предыдущих операторов, для синхронизации используется оператор класса \textit{конъюнкция предшествующих операторов}.

Задачей \textit{Абстрактного sc-агента уничтожения scp-процессов} является уничтожение \textit{scp-процесса}, то есть удаление из \textit{sc-памяти} всех \textit{sc-элементов}, его составляющих. Данный \textit{sc-агент} активируется при появлении в \textit{sc-памяти} \textit{scp-процесса}, принадлежащего множеству \textit{прошлых сущностей}.
При этом уничтожаемый \textit{scp-процесс} необязательно должен быть полностью сформирован. Необходимость уничтожения не до конца сформированного \textit{scp-процесса} может возникнуть в случае, если при создании \textit{scp-процесса} возникли проблемы, не позволяющие продолжить создание \textit{scp-процесса} и его выполнение.

Задачей \textit{Абстрактного sc-агента синхронизации событий в sc-памяти и ее реализации} является обеспечение работы \textit{неатомарных sc-агентов}, реализованных на \textit{Языке SCP}.

Задачей \textit{\textbf{Абстрактного sc-агента трансляции сформированной спецификации события в sc-памяти во внутреннее представление}} является трансляция ориентированных пар, описывающих \textit{первичное условие инициирования*} некоторого \textit{\mbox{sc-агента}} во внутреннее представление элементарных событий на уровне \textit{\mbox{sc-хранилища}}, при условии, что этот \textit{sc-агент} реализован на платформенно-независимом уровне (с использованием \textit{Языка SCP}). Условием инициирования данного \textit{sc-агента} является появление в \textit{\mbox{sc-памяти}} нового элемента множества \textit{активных sc-агентов}, для которого будет найдена и протранслирована соответствующая ориентированная пара.

Задачей \textit{Абстрактного sc-агента обработки события в sc-памяти, инициирующего агентную \mbox{scp-программу}}, является поиск \textit{агентной scp-программы}, входящей во множество \textit{программ sc-агента*} для каждого \textit{sc-агента}, первичное условие инициирования которого соответствует событию, произошедшему в \textit{sc-памяти}, а также генерация и инициирование действия, направленного на интерпретацию этой программы. В результате работы данного \textit{sc-агента} в \textit{sc-памяти} появляется \textit{инициированное действие}, принадлежащее классу \textit{действие} \textit{интерпретации scp-программы}.

\section*{Решатели задач ostis-систем}
\label{sec_ps_ps}



С учетом того тезиса, что существуют \textit{методы} интепретации других \textit{методов} и, следовательно, иерархия \textit{методов}, а также, соответственно, иерархия \textit{навыков}, можно уточнить и понятие решателя задач, как \uline{иерархической системы навыков}. Таким образом, определим \textit{решатель задач ostis-системы} определяется как совокупность всех \textit{навыков}, которыми обладает ostis-система на текущий момент времени. 

Такой подход к уточнению архитектуры \textit{решателей задач ostis-систем} позволяет обеспечить их модифицируемость, что, в свою очередь, позволяет \textit{ostis-системе} при необходимости легко приобретать новые \textit{навыки}, модифицировать (совершенствовать) уже имеющиеся, и даже избавляться от некоторых навыков с целью повышения производительности системы. Таким образом, имеет смысл говорить не о жестко фиксированном решателе задач, который разрабатывается один раз при создании первой версии системы и далее не меняется, а о совокупности навыков, фиксированной в каждый текущий момент времени, но постоянно эволюционирующей.

\begin{SCn}
	\scnheader{решатель задач ostis-системы}
	\scnrelto{семейство подмножеств}{навык}
	\scnidtf{иерархическая система навыков, которыми обладает ostis-система}
	\scnsuperset{гибридный решатель задач ostis-системы}
	\begin{scnindent}
		\scnidtf{решатель задач ostis-системы, реализующий две и более модели решения задач}
	\end{scnindent}
	\scnsuperset{объединенный решатель задач ostis-системы}
	\begin{scnindent}
		\scnidtf{полный решатель задач ostis-системы}
		\scnidtf{интегрированный решатель задач ostis-системы}
		\scnidtf{решатель задач ostis-системы, реализующий все ее функциональные возможности, как основные, так и вспомогательные}
	\end{scnindent}
\end{SCn}

В общем случае \textit{объединенный решатель задач ostis-системы}, решает задачи, связанные с:
\begin{textitemize}
	\item обеспечением основных функциональных возможностей системы (например, решение явно сформулированных задач по требованию пользователя);
	\item обеспечением корректности и оптимизацией работы самой ostis-системы (перманентно на протяжении всего жизненного цикла ostis-системы);
	\item обеспечением повышения квалификации конечных пользователей и разработчиков ostis-системы;
	\item обеспечением автоматизации развития и управления развитием ostis-системы.
\end{textitemize}

В свою очередь, под \textit{машиной обработки знаний} будем понимать совокупность интерпретаторов всех \textit{навыков}, составляющих некоторый \textit{решатель задач}. С учетом многоагентного подхода к обработке информации, используемого в рамках \textit{Технологии OSTIS}, \textit{машина обработки знаний} представляет собой \textit{sc-агент} (чаще всего -- \textit{неатомарный sc-агент}), в состав которого входят более простые sc-агенты, обеспечивающие интерпретацию соответствующего множества \textit{методов}. Таким образом, \textit{машина обработки знаний} в общем случае представляет собой иерархическую систему \textit{sc-агентов}.

\begin{SCn}
	\scnheader{машина обработки знаний}
	\scnsubset{sc-агент}
\end{SCn}

Рассмотрим классификацию \textit{решателей задач} \textit{ostis-систем} по различным признакам.

Классификация \textit{решателей задач} \textit{ostis-систем} по типу соответствующей \textit{ostis-системы}:

\begin{SCn}
\scnheader{решатель задач ostis-системы}
\scnhaselement{Решатель задач Метасистемы OSTIS}
\scnsuperset{решатель задач вспомогательной ostis-системы}
\begin{scnindent}
	\scnsuperset{решатель задач интерфейса компьютерной системы}
	\begin{scnindent}
		\begin{scnrelfromset}{разбиение}
			\scnitem{решатель задач пользовательского интерфейса компьютерной системы}
			\scnitem{решатель задач интерфейса компьютерной системы с другими компьютерными системами}
			\scnitem{решатель задач интерфейса компьютерной системы с окружающей средой}
		\end{scnrelfromset}
	\end{scnindent}
	\scnsuperset{решатель задач ostis-подсистемы поддержки проектирования компонентов определенного класса}
	\begin{scnindent}
		\scnsuperset{решатель задач ostis-подсистемы поддержки проектирования баз знаний}
		\begin{scnindent}
			\scnsuperset{решатель задач повышения качества базы знаний}
			\begin{scnindent}
				\scnsuperset{решатель задач верификации базы знаний}
				\begin{scnindent}
					\scnsuperset{решатель задач поиска и устранения некорректностей в базе знаний}
					\scnsuperset{решатель задач поиска и устранения неполноты}
				\end{scnindent}
				\scnsuperset{решатель задач оптимизации структуры базы знаний}
				\scnsuperset{решатель задач выявления и устранения информационного мусора}
			\end{scnindent}
		\end{scnindent}
		\scnsuperset{решатель задач ostis-подсистемы поддержки проектирования решателей задач ostis-систем}
		\begin{scnindent}
			\begin{scnrelfromset}{разбиение}
				\scnitem{решатель задач ostis-подсистемы поддержки проектирования программ обработки знаний}
				\scnitem{решатель задач ostis-подсистемы поддержки проектирования агентов обработки знаний}
			\end{scnrelfromset}
		\end{scnindent}
	\end{scnindent}
	\scnsuperset{решатель задач подсистемы управления проектирования компьютерных систем и их компонентов}
\end{scnindent}
\scnsuperset{решатель задач самостоятельной ostis-системы}
\end{SCn}

Классификация \textit{решателей задач} \textit{ostis-систем} по типу интерпретируемой \textit{модели решения задач}:

\begin{SCn}
\scnheader{решатель задач ostis-системы}
\scnsuperset{решатель задач с использованием хранимых методов}
\begin{scnindent}
	\scnidtf{решатель, способный решать задачи тех классов, для которых на данный момент времени известен соответствующий метод решения}
	\scnsuperset{решатель задач на основе нейросетевых моделей}
	\scnsuperset{решатель задач на основе генетических алгоритмов}
	\scnsuperset{решатель задач на основе императивных программ}
	\begin{scnindent}
		\scnsuperset{решатель задач на основе процедурных программ}
		\scnsuperset{решатель задач на основе объектно-ориентированных программ}
	\end{scnindent}
	\scnsuperset{решатель задач на основе декларативных программ}
	\begin{scnindent}
		\scnsuperset{решатель задач на основе логических программ}
		\scnsuperset{решатель задач на основе функциональных программ}
	\end{scnindent}
\end{scnindent}
\scnsuperset{решатель задач в условиях, когда метод решения задач данного класса в текущий момент времени не известен}
\begin{scnindent}
	\scnidtf{решатель, реализующий стратегии решения задач, позволяющие породить метод решения задачи, который в текущий момент времени не известен ostis-системе}
	\scnidtf{решатель, использующий для решения задач метаметоды, соответствующие более общим классам задач по отношению к заданной}
	\scnidtf{решатель задач, позволяющий породить метод, который является частным по отношению какому-либо известному ostis-системе методу и интерпретируется соответствующей машиной обработки знаний}
	\scnsuperset{решатель, реализующий стратегию поиска путей решения задачи в глубину}
	\scnsuperset{решатель, реализующий стратегию поиска путей решения задачи в ширину}
	\scnsuperset{решатель, реализующий стратегию проб и ошибок}
	\scnsuperset{решатель, реализующий стратегию разбиения задачи на подзадачи}
	\scnsuperset{решатель, реализующий стратегию решения задач по аналогии}
	\scnsuperset{решатель, реализующий концепцию интеллектуального пакета программ}
\end{scnindent}
\end{SCn}

Отдельно выделим классификацию машин обработки знаний, которые в общем случае могут соответствовать одним и тем же фрагментам базы знаний, но при этом в совокупности с ними образовывать разные навыки и соответственно разные решатели задач:

\begin{SCn}
\scnheader{машина обработки знаний}
\scnsuperset{машина логического вывода}
\begin{scnindent}
	\scnsuperset{машина дедуктивного вывода}
	\begin{scnindent}
		\scnsuperset{машина прямого дедуктивного вывода}
		\scnsuperset{машина обратного дедуктивного вывода}
	\end{scnindent}
	\scnsuperset{машина индуктивного вывода}
	\scnsuperset{машина абдуктивного вывода}
	\scnsuperset{машина нечеткого вывода}
	\scnsuperset{машина вывода на основе логики умолчаний}
	\scnsuperset{машина логического вывода с учетом фактора времени}
\end{scnindent}
\end{SCn}

Классификация \textit{решателей задач} \textit{ostis-систем} по типу решаемой \textit{задачи} (цели решения задачи):

\begin{SCn}
\scnheader{решатель задач ostis-системы}
\scnsuperset{решатель задач информационного поиска}
\begin{scnindent}
	\begin{scnrelfromset}{разбиение}
		\scnitem{решатель задач поиска информации, удовлетворяющей заданным критериям}
		\scnitem{решатель задач поиска информации, не удовлетворяющей заданным критериям}
	\end{scnrelfromset}
\end{scnindent}
\scnsuperset{решатель явно сформулированных задач}
\begin{scnindent}
	\scnidtf{решатель задач, для которых явно сформулирована цель}
	\scnsuperset{решатель задач поиска или вычисления значений заданного множества величин}
	\scnsuperset{решатель задач установления истинности заданного логического высказывания в рамках заданной формальной теории}
	\scnsuperset{решатель задач формирования доказательства заданного высказывания в рамках заданной формальной теории}
	\scnsuperset{машина верификации ответа на указанную задачу}
	\scnsuperset{машина верификации решения указанной задачи}
	\begin{scnindent}
		\scnsuperset{машина верификации доказательства заданного высказывания в рамках заданной формальной теории}
	\end{scnindent}
\end{scnindent}
\scnsuperset{решатель задач классификации сущностей}
\begin{scnindent}
	\scnsuperset{машина соотнесения сущности с одним из заданного множества классов}
	\scnsuperset{машина разделения множества сущностей на классы по заданному множеству признаков}
\end{scnindent}
\scnsuperset{решатель задач синтеза информационных конструкций}
\begin{scnindent}
	\scnsuperset{решатель задач синтеза естественно-языковых текстов}
	\scnsuperset{решатель задач синтеза изображений}
	\scnsuperset{решатель задач синтеза сигналов}
	\begin{scnindent}
		\scnsuperset{решатель задач синтеза речи}
	\end{scnindent}
\end{scnindent}
\scnsuperset{решатель задач анализа информационных конструкций}
\begin{scnindent}
	\scnsuperset{решатель задач анализа естественно-языковых текстов}
	\begin{scnindent}
		\scnsuperset{решатель задач понимания естественно-языковых текстов}
		\scnsuperset{решатель задач верификации естественно-языковых текстов}
	\end{scnindent}
	\scnsuperset{решатель задач анализа изображений}
	\begin{scnindent}
		\scnsuperset{решатель задач сегментации изображений}
		\scnsuperset{решатель задач понимания изображений}
	\end{scnindent}
	\scnsuperset{решатель задач анализа сигналов}
	\begin{scnindent}
		\scnsuperset{решатель задач анализа речи}
		\begin{scnindent}
			\scnsuperset{решатель задач понимания речи}
		\end{scnindent}
	\end{scnindent}
\end{scnindent}
\end{SCn}

%\input{author/references}

\section*{Библиография}

%Убрать те, на которые нет ссылок

\begin{enumerate}
	\item \fullcite{Kolesnikov2001}
	\item \fullcite{Pratt2002}
	\item \fullcite{Gladkov2006}
	\item \fullcite{Emelyanov2003}
	\item \fullcite{Berkinblit1993}
	\item \fullcite{Golovko2001}
	\item \fullcite{Gorban1996}
	\item \fullcite{Vagin2008}
	\item \fullcite{Khulick2001}
	\item \fullcite{Polya1975}
	\item \fullcite{Batyrshin2001}
	\item \fullcite{Demenkov2005}
	\item \fullcite{Pospelov1989}
	\item \fullcite{Reiter1980}
	\item \fullcite{Eremeev1997}
	\item \fullcite{Kachro1988}
	\item \fullcite{Ephymov1982}
	\item \fullcite{Raghovsky2011}
	\item \fullcite{Podkholzyn2008}
	\item \fullcite{Khurbatov2016}
	\item \fullcite{Vladimirov2010}
	\item \fullcite{AIRefBookP11990}
	\item \fullcite{Jackson1998}
	\item \fullcite{W3C}
	\item \fullcite{RDF}
	\item \fullcite{OWL}
	\item \fullcite{SPARQL}
	\item \fullcite{Neo4j}
	\item \fullcite{OWLImplementations}
	\item \fullcite{Gribova2015a}
	\item \fullcite{Gribova2011}
	\item \fullcite{Phylyppov2016}
	\item \fullcite{Borisov2014}
	\item \fullcite{Dutta1993}
	\item \fullcite{Pau1990}
	\item \fullcite{Wooldridge2009}
	\item \fullcite{Weyns2007}
	\item \fullcite{ACL}
	\item \fullcite{Finin1994}
	\item \fullcite{KIF}
	\item \fullcite{Hartung2008}
	\item \fullcite{Sims2008}
	\item \fullcite{Excelente-Toledo2004}
	\item \fullcite{NagendraPrasad1999}
	\item \fullcite{Vasconcelos2009}
	\item \fullcite{Rumbell2012}
	\item \fullcite{Gorodetsky2015}
	\item \fullcite{Bordini2007}
	\item \fullcite{Castillo2014}
	\item \fullcite{EVE}
	\item \fullcite{GAMA}
	\item \fullcite{GOAL}
	\item \fullcite{Evertsz2004}
	\item \fullcite{JADE}
	\item \fullcite{Boissier2013}
	\item \fullcite{Omicini1999}
	\item \fullcite{Jagannathan1989}
	\item \fullcite{Pospelov1986}
	\item \fullcite{Dijkstra2002}
	\item \fullcite{Hoare1983}
	\item \fullcite{Chatterjee2022}
	\item \fullcite{Narinjani2004}
	\item \fullcite{Cao2010}
	\item \fullcite{Cao2014}
	\item \fullcite{Pavel2015}
	\item \fullcite{Altshuller2010}
	\item \fullcite{Shhedrovickij1995}
	\item \fullcite{Sapatyj1986}
	\item \fullcite{Moldovan1985}
	\item \fullcite{Letichevskij2003}
	\item \fullcite{Letichevskij2012}
\end{enumerate}