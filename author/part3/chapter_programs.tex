\chapauthor{Сердюков Р.Е.\\Зотов Н.В.\\Шункевич Д.В.}
\chapter{Семантическая теория программ в интеллектуальных компьютерных системах нового поколения}
\chapauthortoc{Зотов Н.В.\\Шункевич Д.В.}
\label{chapter_programs}

\abstract{}

Современный персональный компьютер теперь имеет производительность большой электронной вычислительной машины 80-х годов
прошлого века. За долгий период развития компьютерных систем практически сняты аппаратные ограничения на решение ими
задач. Оставшиеся ограничения отводятся на долю программного обеспечения.
Прежде всего эти ограничения связаны с текущими проблемами развития программного обеспечения:
\begin{itemize}
    \item аппаратная сложность опережает умение человечества строить программные системы, использующее потенциальные
    возможности аппаратуры;
    \item навыки и технологии разработки программ отстают от требований, предъявлемых к разработке программ нового
    поколения;
    \item возможностям эксплуатировать существующие программы угрожает низкое качество их разработки.
\end{itemize}
Ключом к решению этих проблем является глубокое понимание и грамотное использование существующих языков программирования 
как основного инструмента для массового создания программных систем нового поколения, в том числе разумная организация 
процесса разработки и реинжиниринга таких систем.

Авторы данной главы стремятся достичь следующих результатов:
\begin{itemize}
    \item изложить классические основы, отражающие накопленный мировой опыт в области языков программирования;
    \item показать научные и практические достижения, характеризующие динамику развития языков программирования;
    \item систематизировать все основные результаты в этой области и представить их в виде единой универсальной
    семантической теории программ.
\end{itemize}

В первом параграфе данной главы подробно описывается текущее состояние в области программ и языков программирования,
которые могут и должны быть использования для разработки интеллектуальных компьютерных систем нового поколения. Он
посвящен базовым понятиям языков программирования, дается обзорная характеристика пяти типовых областей применения
языков программирования, достаточно востребованных современным человеческим обществом, подробно описываются формы и
содержание критериев для оценки эффективности языков и рассматриваются способы построения этих критериев.

% добавить параграф для компьютерных языков

\section{Программы и языки программирования для ostis-систем}

В современную эру развития информационных технологий существует огромное количество языков программирования, каждый из
который имеет своё важное назначение в области проектирования программных систем. Каждый язык демонстрирует не только
свою специфику, но имеет свои достоинства и недостатки. Многообразие языков программирования и решений, созданных
на них, настолько велико, что очень легко потеряться в море информации о всех аспектах применения и проектирования
языках программирования.

Зачем необходима общая теория программ и языков программирования?
\begin{enumerate}
    \item Ключом к легкому и глубокому освоению конкретного языка как основного профессионального инструмента
    программиста является понимание общих принципов построения и применения языков программирования, описываемых их
    общей теорией.
    \item Достижение максимума услуг и средств при минимуме затрат возможно только путём глубокого понимания принципов
    построения языков программирования.
\end{enumerate}

Каждая теория должна быть согласована понятийно. Не смотря на то, что в литературе сложилась разное трактование понятия
языка программирования, должно быть одно универсальное. Для этого вместо языков программирования далее будем говорить о
языках представления методов, а вместо программ этих языков программирования - о методах как знаковых конструкций языков
представления методов. Такое решение обосновывается тем, что обычно язык выступает инструмента в роли инструмента
какого-то знания определенного вида, а термин языка программирования является вырожденным, поскольку стоит говорить не
языках, на которых что-то можно программировать, а языках, на которых можно представлять знания определённого вида.
Сами термины языка программирования и программы будем считать неосновными идентификаторами понятий языка представления
методов и метода, соответственно.

\begin{SCn}
\scnheader{метод}
\scnidtf{программа}
\scnidtf{описание того, как может быть выполнено любое или почти любое действие, принадлежащее соответствующему классу действий}
\scnidtf{метод решения соответствующего класса задач, обеспечивающий решение любой или большинства задач
указанного класса}
\scnidtf{обобщенная спецификация решения задач соответствующего класса}
\scnidtf{программа решения задач соответствующего класса, которая может быть как процедурной, так и декларативной (непроцедурной)}
\scnidtf{знание о том, как можно решать задачи соответствующего класса}
\scnsubset{знание}
\scniselement{вид знаний}
\scnidtf{способ}
\scnidtf{программа}
\scnsuperset{модель решения задач}
\end{SCn}

Формально, метод - это спецификация решения задачи какого-то класса. В состав спецификации каждого класса задач входит
описание способа \scnqq{привязки} метода к исходным данным конкретной задачи, решаемой с помощью этого метода. Описание
такого способа \scnqq{привязки} включает в себя:
\begin{itemize}
    \item набор переменных, которые входят как в состав метода, так и в состав обобщенной формулировки задач
    соответствующего класса, и значениями которых являются соответствующие элементы исходных данных каждой конкретной
    решаемой задачи;
    \item часть обобщенной формулировки задач того класса, которому соответствует рассматриваемый метод, являющихся
    описанием условия применения этого метода.
\end{itemize}

Сама рассматриваемая "привязка" метода к конкретной задаче, решаемой с помощью этого метода осуществляется путем поиска
в базе знаний такого фрагмента, который удовлетворяет условиям применения указанного метода. Одним из результатов такого
поиска и является установление соответствия между указанными выше переменными используемого метода и значениями этих
переменных в рамках конкретной решаемой задачи.
Другим вариантом установления рассматриваемого соответствия является явное обращение (вызов, call) соответствующего
метода (программы) с явной передачей соответствующих параметров. Но такое не всегда возможно, т.к. при выполнении
процесса решения конкретной задачи на основе декларативной спецификации выполнения этого действия нет возможности
установить:
\begin{itemize}
    \item когда необходимо инициировать вызов (использование) требуемого метода;
    \item какой конкретно метод необходимо использовать;
    \item какие параметры, соответствующие конкретной инициируемой задаче, необходимо передать для "привязки" используемого
    метода к этой задаче.
\end{itemize}
Процесс "привязки" метода решения задач к конкретной задаче, решаемой с помощью этого метода, можно также представить
как процесс, состоящий из следующих этапов:
\begin{itemize}
    \item построение копии используемого метода;
    \item склеивание основных (ключевых) переменных используемого метода с основными параметрами конкретной решаемой задачи.
\end{itemize}
В результате этого на основе рассматриваемого метода используемого в качестве образца (шаблона) строится спецификация
процесса решения конкретной задачи.

\begin{SCn}
\scnheader{отношение, заданное на множестве (метод)\scnsupergroupsign}
\scnidtf{отношение, область определения которого включает в себя множество всевозможных методов}
\scnhaselement{подметод*}
\begin{scnindent}
    \scnidtf{подпрограмма*}
\end{scnindent}
\end{SCn}

В методе любой оператор представляет собой некоторую математическую функцию. Для композиции этих функций в более
крупные фрагменты используются выражения и операторы. В свою очередь, линейные последовательности операторов
и условные ветвления также могут быть представлены функциями, составленными из функций отдельных компонентов этих
конструкций. Цикл легко описывается рекурсивной функцией, составленной из компонентов, входящих в его тело. В конечном
счете образуется описание всего метода, то есть \textit{денотационная семантика этого метода}. Полная
\textit{спецификация метода*} кроме \textit{денотационной семантики этого метода*} должна включать \textit{операционную
семантику этого метода*}, то есть формальное описание интерпретатора заданного метода. Операционная семаентика языка
представления методов описывает выполнение метода, составленного на данном языке, средствами виртуального компьютера.
Виртуальный компьютер определяется как абстрактный автомат. Внутренние состояния этого автомата моделируют состояния
вычислительного процесса при выполнении метода. Автомат транслирует исходный текст метода в набор формально определенных
операций. Этот набор задает переходы автомата из исходного состояния в последовательность промежуточных состояний,
изменяя значения переменных метода. Автомат завершает свою работу, переходя в некоторое конечное состояние.
Таким образом, здесь идет речь о достаточно прямой абстракции возможного использования языка представления методов.
Операционная семантика описывает смысл метода путем выполнения его операторов на простой машине-автомате.
Изменения, происходящие в состоянии машины при выполнении данного оператора, определяют смысл этого оператора.

\begin{SCn}
\scnheader{спецификация метода*}
\begin{scnrelfromset}{разбиение}
    \scnitem{денотационная семантика метода*}
    \begin{scnindent}
        \scnidtf{обобщенная формулировка класса задач, решаемых с помощью данного метода*}
        \scnrelboth{семантически близкий знак}{обобщенная формулировка задач соответствующего класса методов*}
    \end{scnindent}
    \scnitem{операционная семантика метода*}
    \begin{scnindent}
        \scnidtf{перечень обобщенных агентов, обеспечивающих интерпретацию метода*}
        \scnidtf{семейство методов интерпретации данного метода*}
        \scnidtf{формальное описание интерпретатора заданного метода*}
    \end{scnindent}
\end{scnrelfromset}
\end{SCn}

\begin{SCn}
\scnheader{класс методов}
\scnrelto{семейство подклассов}{метод}
\scnidtf{множество методов, для которых можно унифицировать представление (спецификацию) этих методов}
\scnidtf{множество всевозможных методов решения задач, имеющих общий язык представления этих методов}
\scnidtf{множество методов, для которых задан язык представления этих методов}
\scnhaselement{процедурный метод решения задач}
\begin{scnindent}
    \scnsuperset{алгоритмический метод решения задач}
\end{scnindent}
\scnhaselement{логический метод решения задач}
\begin{scnindent}
    \scnsuperset{продукционный метод решения задач}
    \scnsuperset{функциональный метод решения задач}
\end{scnindent}
\scnhaselement{искусственная нейронная сеть}
\scnhaselement{генетический "алгоритм"}
\scnidtf{множество методов, которому ставится в соответствие отдельная модель решения задач}
\end{SCn}

Поскольку каждому методу соответствует обобщенная формулировка задач, решаемых с помощью этого метода, то каждому классу
методов должен соответствовать не только определенный язык представления методов, принадлежащих указанному классу
методов, но и определенный язык представления обобщенных формулировок задач для различных классов задач, решаемых с
помощью методов, принадлежащих указанному классу методов.

Каждому конкретному классу методов взаимно однозначно соответствует язык представления методов, принадлежащих этому
(специфицируемому) классу методов. Таким образом, спецификация каждого класса методов сводится к спецификации
соответствующего языка представления методов, т.е. к описанию его синтаксической, денотационной семантики и операционной
семантики. Примерами языков представления методов являются все языки программирования, которые в основном относятся к
подклассу языков представления методов – к языкам представления методов обработки информации. Но сейчас все большую
актуальность приобретает необходимость создания эффективных формальных языков представления методов выполнения действий
во внешней среде кибернетических систем. Без этого комплексная автоматизация, в частности, в промышленной сфере
невозможна.

Под \textit{языком представления методов} будем подразумевать формальный язык, (1) знаковыми конструкциями которого
являются соответствующие методы, для которых существуют общие правила построения и (2) общие правила соотнесения с теми
сущностями и связями между ними, которые описываются этими методами. Понятие синтакиса, денотационной и операционной
семантики языков представления методов сводятся к понятию синтаксиса, денотационной и операционной семантики вообще
любого языка.

С помощью языка представления методов формируются сообщения (методы) для компьютера. Эти сообщения должны быть понятны
(семантически корректны и целостны) компьютеру.

\begin{SCn}
\scnheader{язык представления методов}
\scnsubset{формальный язык}
\scnidtf{язык программирования}
\scnidtf{компьютерный язык}
\scnidtf{формальный язык, (1) знаковыми конструкциями которого являются соответствующие методы, для которых
существуют общие правила построения и (2) общие правила соотнесения с теми сущностями и связями между ними, которые
описываются этими методами}
\scnidtf{средство общения между человеком (пользователем) и компьютером (исполнителем)}
\scnidtf{инструмент для производства программных услуг}
\end{SCn}

\begin{SCn}
\scnheader{отношение, заданное на множестве языков представления методов\scnsupergroupsign}
\scnidtf{отношение, область определения которого включает в себя множество всевозможных языков представления методов}
\scnhaselement{метод заданного языка представления методов*}
\begin{scnindent}
    \scnidtf{метод, принадлежащий заданному языку программирования*}
    \scnsubset{текст заданного языка*}
    \scnrelfrom{второй домен}{метод}
    \begin{scnreltoset}{объединение}
        \scnitem{\scnnonamednode}
        \begin{scnindent}
            \begin{scnreltoset}{объединение}
                \scnitem{синтаксически корректный метод для заданного языка представления методов*}
                \scnitem{синтаксически целостный метод для заданного языка представления методов*}
            \end{scnreltoset}
        \end{scnindent}
        \scnitem{\scnnonamednode}
        \begin{scnindent}
            \begin{scnreltoset}{объединение}
                \scnitem{семантически корректный метод для заданного языка представления методов*}
                \scnitem{синтаксически целостный метод для заданного языка представления методов*}
            \end{scnreltoset}
        \end{scnindent}
    \end{scnreltoset}
\end{scnindent}
\scnhaselement{синтаксически корректный метод для заданного языка представления методов*}
\begin{scnindent}
    \scnidtf{метод, не содержащий синтаксических ошибок для заданного языка представления методов*}
    \scnsubset{синтаксически корректная знаковая конструкция для заданного языка*}
\end{scnindent}
\scnhaselement{синтаксически целостный метод для заданного языка представления методов*}
\begin{scnindent}
    \scnsubset{синтаксически целостная знаковая конструкция для заданного языка*}
\end{scnindent}
\scnhaselement{семантически корректный метод для заданного языка представления методов*}
\begin{scnindent}
    \scnidtf{метод, не содержащий семантических ошибок для заданного языка представления методов*}
    \scnsubset{семантически корректная знаковая конструкция для заданного языка*}
\end{scnindent}
\scnhaselement{семантически целостный метод для заданного языка представления методов*}
\begin{scnindent}
    \scnsubset{семантически целостная знаковая конструкция для заданного языка*}
    \scnidtf{метод заданного языка представления методов, содержащий достаточную информацию для установления его
    истинности*}
\end{scnindent}
\end{SCn}

Применительно к языкам представления методов различают различные парадигмы: процедурные, функциональные, логические,
объектно-ориентированные и другие языки представления методов. Таким, например, в методах процедурного языка
представления методов решение задачи компьютером формируется в виде последовательности операторов, в методах
функционального языка представления методов — указанием других методов. В логическом языках представления методов
применяются высказывания, а в объектно-ориентированном — объекты.

\begin{SCn}
\scnheader{язык представления методов}
\scnsuperset{язык представления методов общего назначения}
\begin{scnindent}
    \scnidtf{язык программирования общего назначения}
\end{scnindent}
\scnsuperset{предметно-ориентированный язык представления методов}
\begin{scnindent}
    \scnidtf{предметно-ориентированный язык программирования}
\end{scnindent}
\scnrelfrom{покрытие}{парадигма языка представления методов\scnsupergroupsign}
\begin{scnindent}
    \begin{scneqtoset}
        \scnitem{процедурный язык представления методов}
        \scnitem{логический язык представления методов}
        \begin{scnindent}
            \begin{scnrelfromset}{разбиение}
                \scnitem{продукционный язык представления методов}
                \scnitem{функциональный язык представления методов}
            \end{scnrelfromset}
        \end{scnindent}
        \scnitem{объектно-ориентированный язык представления методов}
        \begin{scnindent}
            \scnidtf{фреймовый язык представления методов}
            \begin{scnhaselementrolelist}{пример}
                \scnitem{Smalltalk}
                \scnitem{HTML}
            \end{scnhaselementrolelist}
        \end{scnindent}
    \end{scneqtoset}
\end{scnindent}
\scnrelfrom{покрытие}{типология языков представления методов по цели использования\scnsupergroupsign}
\begin{scnindent}
    \begin{scneqtoset}
        \scnitem{традиционный язык представления методов}
        \begin{scnindent}
            \begin{scnhaselementrolelist}{пример}
                \scnitem{C++}
                \scnitem{Fortran}
                \scnitem{Java}
            \end{scnhaselementrolelist}
        \end{scnindent}
        \scnitem{скриптовой язык представления методов}
        \begin{scnindent}
            \scnidtf{склеивающий язык представления методов}
            \begin{scnhaselementrolelist}{пример}
                \scnitem{Python}
                \scnitem{Perl}
                \scnitem{JavaScript}
                \scnitem{PHP}
                \scnitem{Ruby}
                \scnitem{Lua}
            \end{scnhaselementrolelist}
        \end{scnindent}
        \scnitem{гибридный язык представления методов}
        \begin{scnindent}
            \begin{scnhaselementrolelist}{пример}
                \scnitem{XSLT}
                \scnitem{JSP}
            \end{scnhaselementrolelist}
        \end{scnindent}
    \end{scneqtoset}
\end{scnindent}
\end{SCn}

Процедурные (императивные) языки представления методов задают вычисления как последовательность операторов (команд).
Они ориентированы на компьютеры с архитектурой фон Неймана. Основные понятия процедурных языков представления методов
тесно связаны с компонентами компьютера:
\begin{itemize}
    \item переменными различных типов, которые моделируют ячейки памяти компьютера;
    \item операторами присваивания, которые моделируют пересылки данных между участками памяти;
    \item повторений действий в форме итерации, которые моделируют хранение информации в смежных ячейках памяти;
    \item и другое.
\end{itemize}

\begin{SCn}
\scnheader{процедурный язык представления методов}
\scnidtf{императивный язык представления методов}
\begin{scnhaselementrolelist}{пример}
    \scnitem{Fortran}
    \scnitem{Си}
    \scnitem{Pascal}
\end{scnhaselementrolelist}
\end{SCn}

Вычисления основываются на понятии состояния компьютера. Состояние компьютера — это множество всех значений всех ячеек
его памяти. Программа состоит из последовательности операторов, выполнение каждого из которых влечет за собой изменение
значения в одной или нескольких ячейках памяти, то есть переход компьютера в новое состояние.
Чаще всего операторы выполняются в порядке их следования в программе, друг за другом, и приводят к последовательной
смене состояний компьютера. Конечное состояние обеспечивает требуемый результат. Словом, процедурные методы (программы)
гармонизированы с принципами работы традиционного компьютера, реализуются быстро и эффективно.

\begin{SCn}
\scnheader{логический язык представления методов}
\begin{scnhaselementrolelist}{пример}
    \scnitem{Prolog}
\end{scnhaselementrolelist}
\end{SCn}

\begin{SCn}
\scnheader{продукционный язык представления методов}
\begin{scnhaselementrolelist}{пример}
    \scnitem{}
\end{scnhaselementrolelist}
\end{SCn}

\begin{SCn}
\scnheader{функциональный язык представления методов}
\scnidtf{аппликативный язык представления методов}
\begin{scnhaselementrolelist}{пример}
    \scnitem{LISP}
\end{scnhaselementrolelist}
\end{SCn}

Понятно, что для использования языка представления методов следует описать каждую конструкцию языка в отдельности, а
также ее применение в совокупности с другими конструкциями. В языке существует множество различных конструкций, точное
определение которых необходимо как программисту, применяющему язык, так и разработчику компилятора для этого
языка. Программисту эти знания позволяют прогнозировать вычисления, производимые операторами метода. Разработчику
описания конструкций необходимы для создания правильной реализации компилятора.

\begin{SCn}
\scnheader{спецификация языка представления методов*}
\begin{scnrelfromset}{разбиение}
    \scnitem{денотационная семантика языка представления методов*}
    \begin{scnindent}
        \scnidtf{обобщенная формулировка множество классов задач, решаемых с помощью данного языка представления
        методов*}
    \end{scnindent}
    \scnitem{операционная семантика языка представления методов*}
    \begin{scnindent}
        \scnidtf{перечень обобщенных агентов, обеспечивающих интерпретацию методов заданного языка представления
        методов*}
        \scnidtf{семейство методов интерпретации текстов данного языка представления методов*}
        \scnidtf{формальное описание интерпретатора заданного языка представления методов*}
    \end{scnindent}
\end{scnrelfromset}
\end{SCn}

Внешний вид элементов языка представления методв задают с помощью конкретного синтаксиса. Он описывает такие лексические
детали, как размещение ключевых слов и знаков пунктуации. Для спецификации конкретного синтаксиса применяют грамматики.
Грамматика языка вводит иерархическую структуру, называемую деревом разбора над методами языка.

Синтаксис языков представления методов, как и синтаксис языков представления знаний в ostis-системах может быть
формально описан различными способами. Так, например, можно использовать метаязык Бэкуса-Наура для описания синтаксиса
какого-то конкретного языка представления методов. Однако значительно более логично и целесообразно описывать синтаксис
других языков на универсальном языке представления знаний - SC-коде. Такой подход позволит ostis-системам самостоятельно
понимать, анализировать и генерировать тексты указанных языков на основе принципов, общих для любых форм внешнего
представления информации, в том числе нелинейных.

%\begin{SCn}
%\scnheader{эффективность языка представления методов\scnsupergroupsign}
%\end{SCn}

\section{Принципы интерпретации современных языков программирования в ostis-системах}

%\input{author/references}
