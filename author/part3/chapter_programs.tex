\chapter{Семантическая теория программ для ostis-систем}
\chapauthortoc{Зотов Н.В.\\Шункевич Д.В.}
\label{chapter_programs}

\vspace{-7\baselineskip}

\begin{SCn}
\begin{scnrelfromlist}{автор}
	\scnitem{Зотов Н.В.}
	\scnitem{Шункевич Д.В.}
\end{scnrelfromlist}

\bigskip

\scntext{аннотация}{Несмотря на активное развитие и использование современных технологий и языков программирования, общей семантической теории программ, на основе которой можно было бы проектировать и разрабатывать прикладные системы, на данный момент не существует. В данной главе предлагается семантическая теория программ для ostis-систем. Глава показывает особенности представления и ключевые моменты процесса интерпретации программ в ostis-системах.}

\bigskip

\begin{scnrelfromlist}{подраздел}
	\scnitem{\ref{sec_programs_problems_and_tasks}~\nameref{sec_programs_problems_and_tasks}}
	\scnitem{\ref{sec_programs_ontologies}~\nameref{sec_programs_ontologies}}
	\scnitem{\ref{sec_programs_solution}~\nameref{sec_programs_solution}}
	\scnitem{\ref{sec_programs_method_syntax_and_semantic}~\nameref{sec_programs_method_syntax_and_semantic}}
	\scnitem{\ref{sec_programs_help_system}~\nameref{sec_programs_help_system}}
	\scnitem{\ref{sec_programs_method_kriteria}~\nameref{sec_programs_method_kriteria}}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{ключевое понятие}
	\scnitem{метод}
	\begin{scnindent}
		\scnidtf{программа}
	\end{scnindent}
	\scnitem{язык представления методов}
	\begin{scnindent}
		\scnidtf{язык программирования}
	\end{scnindent}
	\scnitem{эффективность метода}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевое отношение}
	\scnitem{спецификация метода*}
	\scnitem{синтаксис метода*}
	\scnitem{денотационная семантика метода*}
	\scnitem{операционная семантика метода*}
	\scnitem{спецификация языка представления методов*}
	\scnitem{синтаксис языка представления методов*}
	\scnitem{денотационная семантика языка представления методов*}
	\scnitem{операционная семантика языка представления методов*}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Семантическая теория программ для ostis-систем}
		\begin{scnindent}
		\scnidtf{Предлагаемый нами вариант теории для проектирования языков программирования и программ для интеллектуальных компьютерных систем нового поколения}
	\end{scnindent}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{библиографическая ссылка}
	\scnitem{\scncite{Sebesta2012}}
	\scnitem{\scncite{Zapata2010}}
	\scnitem{\scncite{Golenkov2019a}}
	\scnitem{\scncite{Penta2020}}
	\scnitem{\scncite{Scalabrino2016}}
	\scnitem{\scncite{Golenkov2012}}
	\scnitem{\scncite{Brooks2021}}
	\scnitem{\scncite{Sellitto2022}}
	\scnitem{\scncite{Turner2007}}
	\scnitem{\scncite{Chaparro2014}}
	\scnitem{\scncite{Golenkov2022a}}
	\scnitem{\scncite{Golenkov2019}}
	\scnitem{\scncite{Eden2007}}
	\scnitem{\scncite{Lando2007}}
	\scnitem{\scncite{Lando2007a}}
	\scnitem{\scncite{Turner2014}}
	\scnitem{\scncite{Deikstra1978}}
	\scnitem{\scncite{Standart2021}}
	\scnitem{\scncite{Kasyanov2003}}
	\scnitem{\scncite{Petrov1978}}
	\scnitem{\scncite{Scott2006}}
	\scnitem{\scncite{Scott1972}}
	\scnitem{\scncite{Orlov2021}}
	\scnitem{\scncite{Lu2022}}
	\scnitem{\scncite{Gulykina2012}}
	\scnitem{\scncite{Pivovarchik2016}}
	\scnitem{\scncite{Ford2019}}
	\scnitem{\scncite{IMS}}
	\scnitem{\scncite{Pivovarchik2013}}
	\scnitem{\scncite{Tin1995}}
	\scnitem{\scncite{Schiitze1991}}
	\scnitem{\scncite{Black1993}}
\end{scnrelfromlist}

\end{SCn}

\section*{Введение в Главу \ref{chapter_programs}}

За долгий период развития компьютерных систем практически сняты аппаратные ограничения на решение различных задач. Оставшиеся ограничения отводятся на долю программного обеспечения. Прежде всего эти ограничения связаны с текущими проблемами развития программного обеспечения:
\begin{textitemize}
    \item \myuline{аппаратная сложность опережает} умение человечества строить \myuline{программные компьютерные системы}, использующее потенциальные возможности аппаратуры;
    \item навыки и \myuline{технологии} разработки программ \myuline{отстают от требований}, предъявляемых к разработке программ нового поколения;
    \item возможностям эксплуатировать существующие программы угрожает \myuline{низкое качество их разработки}.
\end{textitemize}

Ключом к решению этих проблем является глубокое понимание и грамотное использование существующих \textit{языков программирования} как основного инструмента для массового создания \textit{программных компьютерных систем нового поколения}.

В данной главе акцент делается на достижение следующих результатов:
\begin{textitemize}
    \item (1) изложение классических основ, отражающих накопленный мировой опыт в области разработки и применения современных \textit{языков программирования};
    \item и (2) систематизация основных результатов в этой области в виде единой унифицированной \textit{Семантической теории программ для интеллектуальных компьютерных систем нового поколения}, построенных по принципам \textit{Технологии OSTIS}.
\end{textitemize}

В данной главе подробно описываются проблемы текущего состояния в области \textit{технологий} и \textit{языков программирования}. Она посвящена базовым понятиям \textit{теории языков программирования}, дается обзорная характеристика областей применения \textit{языков программирования}, достаточно востребованных современным человеческим обществом, рассматриваются способы представления и интерпретации \textit{программ} различных \textit{языков программирования}, подробно описываются формы и содержание критериев для оценки \textit{эффективности языков}.

\section{Проблемы текущего состояния в области разработки и применения языков программирования}
\label{sec_programs_problems_and_tasks}

В современную эру развития информационных технологий существует огромное количество \textit{языков программирования}, каждый из которых имеет свое важное назначение в области проектирования \textit{программных компьютерных систем}. Многообразие \textit{языков программирования} (см. \scncite{Sebesta2012}) и решений, созданных на них, настолько велико, что очень легко потеряться в море информации о всех аспектах применения и проектирования \textit{языков программирования}. Кроме этого, основная проблема заключается не в количестве существующих решений в области разработки и применения современных \textit{языков программирования}, а количестве форм (!), на которых представляются конкретные \textit{языки программирования}. Так, \textit{декларативные знания}, то есть знания, являющиеся, например, спецификацией какой-то программы, и \textit{процедурные знания}, то есть знания, которые являются программами, принадлежащими какому-то \textit{языку программирования}, представляются совершенно различными способами, методами и средствами.

В связи со сказанным можно выделить следующие ключевые проблемы в области разработки и применения современных \textit{языков программирования}:
\begin{textitemize}
    \item Поскольку количество \textit{языков программирования} растет с увеличением потребности в них, то растут и потребности в описании этих \textit{языков программирования} для дальнейшего использования и проектирования прикладных систем. Это в свою очередь требует высокого уровня качества спецификации конкретного языка: и описания \textit{синтаксиса} и семантики конструкций этого языка, и описания средств и методов реновации инструментальных средств, обеспечивающих интерпретацию или трансляцию этого языка. То есть, с увеличением количества \textit{языков программирования} растет не только многообразие форм представления знаний (\textit{языков программирования}), но и количество \textit{программных компьютерных систем} на различных формах представления знаний (см. \scncite{Zapata2010}).
    \item Большое многообразие форм представления знаний, как говорилось выше, предоставляет большой спектр возможностей проектирования \textit{программных компьютерных систем} на каждой из них. Получается, чтобы произвести интеграцию нескольких \textit{программных компьютерных систем}, реализованных на разных \textit{языках программирования}, необходимо сделать так, чтобы системы могли коммуницировать между собой на каждом из тех языков, на котором они реализованы (см. \scncite{Golenkov2019a}). Так, стремление к использованию существующих программных компонентов затрудняется реализацией самих компонентов, поскольку чтобы объединить эти компоненты необходимо изменить их программный код (см. \scncite{Penta2020}, \scncite{Scalabrino2016}). Наличие многообразия форм затрудняет реализацию \textit{совместимых интероперабельных программных компьютерных систем} (см. \scncite{Golenkov2012}).
    \item С ростом сложности программного кода, уменьшается количество способных понять его смысл. Современные разработчики создают \textit{программные компьютерные системы}, не учитывая полный ее жизненный цикл (см. \scncite{Brooks2021}). Системы должны постоянно обновляться и совершенствоваться с развитием технологий, на которых она основана (см. \scncite{Sellitto2022}). Это должно обеспечиваться хорошей документацией реализации компонентов этих систем --- это снижает не только потребности в привлечении новых ресурсов и кадров, но и способствует снижению реинжиниринга \textit{программных компьютерных систем} (см. \scncite{Penta2020}, \scncite{Scalabrino2016}).
    \item Полная автоматизация проектирования \textit{программных компьютерных систем} невозможна, поскольку современные языки, на которых они проектируются не имеют свойства рефлексивности --- системы не могут познавать и понимать себя и развиваться в полной мере самостоятельно. Таким образом, существующие \textit{программные компьютерные системы} не являются как таковыми интеллектуальными, потому что не имеют необходимых им свойств (см. \textit{\ref{sec_cyb_syst_overall_quality}~\nameref{sec_cyb_syst_overall_quality}}).
    \item Ключом к легкому и глубокому освоению конкретного языка как основного профессионального инструмента программиста является понимание общих принципов построения и применения языков программирования (см. \scncite{Turner2007}), описываемых их общей теорией. До сегодняшнего дня, общей \textit{Семантической теории языков программирования} до сих пор не существует, что затрудняет разработку, верификацию и использование новых и существующих \textit{языков программирования}. Без общей теории каждый может разрабатывать принципиально общие методы и средства так, как хочется, а не так, как требуется (см. \scncite{Golenkov2012}).
    \item Достижение максимума услуг и средств при минимуме затрат возможно только путем глубокого понимания принципов построения \textit{языков программирования} за счет простоты средств и методов представления знаний. Сложное нужно сводить к простому и изъяснять простыми понятиями, не создавая дополнительной иллюзии важности (см. \scncite{Sellitto2022}, \scncite{Chaparro2014}).
\end{textitemize}

Все эти проблемы связаны и являются проблемами текущего состояния направлений развития в области \textit{Искусственного интеллекта} (см. \scncite{Golenkov2022a}).

Итак, для решения перечисленных проблем необходимо создавать комфортные условия для реализации \textit{программных компьютерных систем}, семантически совместимых и интероперабельных между собой. В контексте \textit{языков программирования} необходима общая \textit{Семантическая теория программ для интеллектуальных компьютерных систем нового поколения}, которая:
\begin{textitemize}
    \item \myuline{позволит} без больших усилий и затрат \myuline{интегрировать имеющиеся решения} в области проектирования программ компьютерных систем (см. \scncite{Golenkov2019});
    \item \myuline{объединит формы представления знаний} декларативного и процедурного вида;
    \item \myuline{будет иметь широкий спектр средств} не только для описания синтаксиса и семантики существующих языков программирования, но и для проектирования новых аналогов;
    \item \myuline{будет понятна} не только человеку, но и машине (см. \scncite{Zapata2010});
    \item \myuline{обозначит принципы}, по которым необходимо проектировать \textit{языки программирования нового поколения}.
\end{textitemize}

К проектированию таких общих теорий, строго говоря, нужно подходить с высокой степенью важности. Проектируемые \textit{компьютерные системы} должны всегда иметь возможности использовать те свойства, которые им начертаны. Для того, чтобы и эта теория могла быть использована как некоторая система знаний о том, как надо проектировать и использовать \textit{языки программирования} и программы в \textit{программных компьютерных системах}, и том, как интерпретировать их \textit{программы}, необходимо, чтобы эта теория была описана средствами и методами, которыми проектируются эти \textit{программные компьютерные системы}. Речь идет о том, что принципиально важным подходом к проектированию общей теории программ является \textit{онтологический подход} (см. \scncite{Zapata2010}, \scncite{Golenkov2019}).

Для воплощения данных идей необходимо изучить и интегрировать опыт, накопленный в области разработки и применения \textit{современных языков программирования}. Поэтому далее будут рассмотрены результаты других исследований в области проектирования общей теории языков программирования и программ.

\section{Существующие онтологии языков программирования}
\label{sec_programs_ontologies}

\begin{SCn}

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Недостатки современных технологий программирования и языков программирования}
\end{scnrelfromlist}
	
\end{SCn}

В большинстве, идеи, предлагаемые в научных работах по исследованию языков программирования, безусловно являются востребованными и полезными для проектирования \textit{программных компьютерных систем}. Так, идея о том, что языки программирования и программы, реализуемые на них, должны быть организованы в общую таксономию понятий, является основополагающей, поскольку обеспечивает наиболее качественную среду для проектирования и реализации \textit{программных компьютерных систем}. Общая теория программ нужна не только для того чтобы описывать термины и понятия как некоторую спецификацию, используемую для проектирования \textit{программных компьютерных систем} (что тоже немаловажно), но и для того, чтобы определять качество языков программирования и программ по таким вопросам, как: \scnqq{Является ли данный язык языком программирования}, \scnqq{Является ли данное знание программой}, \scnqq{Насколько эффективна данная программа}, \scnqq{Какова степень интеллекта данной программной системы} и так далее. Данные идеи предложены и рассмотрены в работах Raymond Turner \scncite{Eden2007}, \scncite{Turner2007}.

До сегодняшнего дня существует большое количество аналогов онтологий языков программирования и программ. Примеры можно найти в работах (см. \scncite{Lando2007}, \scncite{Lando2007a}). Также стоит отметить разработанные онтологии программ в работах \scncite{Turner2014}, \scncite{Turner2007}, система понятий в которых определяется строго и однозначно на формальных языках: языках логики и языках описания грамматик формальных языков. Однако ни одна из них не является таким результатом, который можно было бы использовать при проектировании \textit{программных компьютерных систем} без существенных проблем. Разработанные онтологии сосредотачивают в себе лишь краткое описание связанных между собой понятий, но общей картины того, как данные онтологии можно использовать в конкретных задачах, почти не видно.

Сегодня встречаются и вовсе протовоположные суждения о назначении программ и языков программирования, противоречащие формальным основам Искусственного интеллекта. \textit{Программные компьютерные системы} должны быть не только понятны человеку, но и сами должны понимать себя, свои возможности, намерения, действия и цели, и понимать себе подобные кибернетические системы. Только таким образом человечество и результаты его деятельности в виде каких-то конкретных систем смогут работать сообща, дополняя друг друга и преумножая свои результаты \scncite{Golenkov2012}.

В результате анализа приведенных работ можно сделать вывод о том, что:
\begin{textitemize}
    \item \textit{общей теории программ и языков программирования}, которая могла быть задействована при решении любой прикладной задачи и представлении и реализации средств проектирования компьютерных систем, до сих пор не существует;
    \item унификация представления средств описания и реализации по этим описании как главный аргумент к оперированию смысловому представлению знаний, к полному взаимопониманию между \textit{программными компьютерными системами} вовсе не рассматривается;
    \item \textit{программы} и совокупности этих \textit{программ} в виде \textit{программных компьютерных систем} реализуются в большинстве случаев в индивидуальном порядке и плохо документируются, что усложняет их использование, интеграцию с другими программами и \textit{программными компьютерными системами}, тестирование и совершенствование.
\end{textitemize}

\section{Предлагаемый подход к разработке технологий программирования для ostis-систем}
\label{sec_programs_solution}

\begin{SCn}

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Принципы программирования в интеллектуальных компьютерных системах нового поколения}
\end{scnrelfromlist}

\end{SCn}

Поскольку количество \textit{языков программирования} растет с увеличением потребности в них, то растут и потребности в описании этих \textit{языков программирования} для проектирования и разработки \textit{программных компьютерных систем} на этих языках. То есть, с увеличением количества \textit{языков программирования} растет не только многообразие форм представления знаний, но и количество \textit{программных компьютерных систем} на различных формах представления знаний. Это в свою очередь требует не только качественной спецификации конкретного \textit{языка программирования} для разработки \textit{программ} на этом языке, но и новых требований к существующим разработчикам. В итоге, это влечет за собой появление барьеров и для создания семантически совместимых и интероперабельных \textit{программных компьютерных систем}, и для обеспечения благоприятной среды для взаимодействия их разработчиков.

Для преодоления данных проблем нет необходимости пересматривать уже существующие решения в области разработки программного обеспечения. Необходимо создавать принципиально новые \textit{языки программирования}, а также реализовывать \textit{программные компьютерные системы} на них, в которых будут учтены и решены существующие проблемы. Для этого следует учитывать следующие \textit{принципы программирования} этих систем:
\begin{textitemize}
	\item Расширение многообразия форм представления знаний происходит за счет появления новых синтаксических конструкций в \textit{языках программирования}. Поэтому разработка \textit{языков программирования} должна сводиться к уточнению \textit{синтаксиса} и \textit{семантики} уже существующих \textit{языков программирования}. При этом все \textit{языки программирования} должны являться подъязыками некоторого базового \textit{языка программирования}.
	\item Нет необходимости в создании дополнительных языков, с помощью которых можно описывать семантику программ на \textit{языках программирования}. Наоборот, \textit{язык программирования}, на котором разрабатываются программы, должен позволять своими же средствами описывать \textit{семантику} \textit{программ} на этом же языке.
	\item Документирование \textit{программ}, в том числе \textit{программных компьютерных систем}, должно минимизироваться за счет этапов их качественного проектирования и разработки. Смысл конструкций \textit{программ} \textit{языков программирования} должен быть настолько ясным и понятным, чтобы использование \textit{программ} на этом \textit{языке программирования} не требовало дополнительных ресурсов и инструментов как и у разработчиков этих программ и систем, таких и у новых разработчиков.
	\item Появление новых программ должно влечь за собой к расширению \textit{Библиотеки многократно используемых программ} и к уменьшению количества семантически эквивалетных программ. Таким образом, программы должны быть не только максимальным образом совместимыми между собой, но и открытыми для переиспользования в других \textit{программных компьютерных системах нового поколения}.
	\item Полный жизненный цикл разработки новых программ должен обеспечиваться теми же средствами и \textit{языками программирования}, на которых разрабатываются эти программы.
	\item Сложность программ и \textit{программных компьютерных систем} должна сводиться к минимуму. То, что выглядит сложно, должно и может быть сделано максимально просто. 
	\item Построение качественного коллектива \textit{программных компьютерных систем} может быть обеспечено только совместимостью и интероперабельностью самих систем, и коллективов тех разработчиков, которые их создают.
\end{textitemize}

Ключом к решению всех этих проблем является общая \textit{Технология проектирования компьютерных систем нового поколения}, на базе которой можно построить общую \textit{Семантическую теорию программ} (дисциплину программирования) для \textit{интеллектуальных компьютерных систем нового поколения}, построенных по принципам \textit{Технологии OSTIS} (см. \scncite{Deikstra1978}).

Почему \textit{Технология OSTIS} является ключом к решению описанных проблем в области проектирования и применения \textit{языков программирования}?
\begin{textitemize}
    \item Стандарт Технологии OSTIS \scncite{Standart2021} уже реализует базовые средства, необходимые для проектирования и разработки интероперабельных \textit{программных компьютерных систем}, в основе которых лежит смысловое представление знаний. Это устраняет не только необходимость создания \textit{онтологий верхнего уровня}, которые должны быть использованы в общей теории программ как базовые для описания понятий этой теории, но и помогает проектировать решения согласованно с другими онтологиями. В результате формируется общая слаженная картина мира, которая (1) непротиворечива, то есть согласована, (2) однозначно трактуема, (3) универсальна и, (4) самое главное, понятна для каждого.
    \item \textit{Технология OSTIS} проектируется одним языком унифицированного представления знаний, называемым \textit{SC-кодом}. Смысл \textit{программ} и \textit{языков программирования} понятен и однозначен тогда и только тогда, когда этот смысл описывается на одном общем языке, понятному любой \textit{кибернетической системе}.
    \item \textit{SC-код} синтаксически минимален. Для описания объектов и связей между ними используется минимальное количество знаков. В то же время многообразие этих связей сводится к многобразию знаковых конструкций. Все это обеспечивается за счет представления информации в виде графовых структур (см. \scncite{Kasyanov2003}, \scncite{Petrov1978}).
    \item SC-код не просто удобен для описания и проектирования каких-то сложных объектов --- с его помощью можно проектировать и реализовывать любые \textit{языки представления знаний}, в том числе программ, компьютерные системы и, вообще, описывать реальный мир.
    \item Онтологический и компонентный подходы к проектированию любых сложных объектов обеспечивают выполнение главных принципов, по которым должны проектироваться современные системы. То, что реализовано и можно использовать, нужно переиспользовать везде.
\end{textitemize}

Проектирование и реализация \textit{программы} на каком-либо \textit{языке программирования} должна сводиться к описанию ее \textit{синтаксиса} и \textit{денотационной семантики} в базе знаний ostis-системы с помощью некоторой библиотеки предметных областей и онтологий программ, описываемой в рамках этой базы знаний. Для этого нужна онтология программ, которые позволили бы в достаточном объеме описывать программы на любых языках программирования в ostis-системах. Такой подход позволяет не только описывать сложноструктурированные объекты простым и понятным языком, но и позволяет унифицировать представление различных видов знаний. Тем самым, информация о программах и сами программы представляются на одном и том же языке (имеют один синтаксис), но содержательно описываются при помощи разных онтологий. Таким образом, \uline{решением всех проблем будет являться общая теория программ}, однозначно соответствующей некоторой онтологии программ, c помощью которых можно было бы описывать синтаксис и денотационную семантику любых программ в ostis-системах.

Таким образом, результатом данной главы является \textit{Предметная область и онтология программ} (далее --- Предметная область и онтология методов), с помощью которой можно описывать синтаксис, денотационную и операционную семантику различных методов в ostis-системах. \textit{Предметная область и онтология методов} является дочерней предметной областью по отношению к \textit{Предметной области и онтологии информационных конструкций и языков}. Это означает, что она наследует все свойства исследуемых в ней понятий и отношений.

\begin{SCn}
\scnheader{Предметная область и онтология информационных конструкций и языков}
\begin{scnrelfromlist}{дочерняя предметная область}
    \scnitem{Предметная область и онтология языков}
    \begin{scnindent}
        \begin{scnrelfromlist}{дочерняя предметная область}
            \scnitem{Предметная область и онтология естественных языков}
            \scnitem{Предметная область и онтология формальных языков}
        \end{scnrelfromlist}
    \end{scnindent}
\end{scnrelfromlist}
\end{SCn}

\begin{SCn}
\scnheader{Предметная область и онтология формальных языков}
\begin{scnrelfromlist}{дочерняя предметная область}
    \scnitem{Предметная область и онтология языков представления знаний}
    \begin{scnindent}
        \begin{scnrelfromlist}{дочерняя предметная область}
            \scnitem{\scnkeyword{Предметная область и онтология методов}}
        \end{scnrelfromlist}
    \end{scnindent}
\end{scnrelfromlist}
\end{SCn}

\begin{SCn}
\scnheader{Предметная область и онтология методов}
\begin{scnrelfromlist}{дочерняя предметная область}
    \scnitem{Предметная область и онтология методов ostis-систем}
    \begin{scnindent}
        \begin{scnrelfromlist}{дочерняя предметная область}
            \scnitem{Предметная область и онтология процедурных методов ostis-систем}
        \end{scnrelfromlist}
    \end{scnindent}
\end{scnrelfromlist}
\end{SCn}

Каждая теория должна быть согласована понятийно. Несмотря на то, что в литературе сложилась разное трактование понятия \textit{языка программирования}, должно быть одно универсальное. Для этого вместо языков программирования далее \myuline{будем говорить о языках представления методов}, а вместо программ этих языков программирования --- о методах как знаковых конструкциях языков представления методов. Такое решение обосновывается тем, что обычно язык выступает в роли инструмента какого-то знания определенного вида, а термин \textit{языка программирования} является вырожденным, поскольку стоит говорить не о языках, на которых что-то можно программировать, а о языках, на которых можно представлять знания определенного вида, в данном случае --- знания процедурного типа. Сами термины \scnqqi{языка программирования} и \scnqqi{программы} будем считать неосновными идентификаторами понятий \scnqqi{языка представления методов} и \scnqqi{метода}, соответственно. Также это правило применяется на все понятия, используемые в данной главе и содержащие термин "метод".

Следует отметить, что общая \textit{Семантическая теория программ в ostis-системах} не отрицает весь накопленный опыт в сфере разработки современных \textit{технологий программирования}. Наоборот, предлагаемая в данной главе идея позволяет переиспользовать те проверенные инструменты и методы для наиболее быстрой и качественной реализации программ в сложных \textit{программных компьютерных системах}.

\section{Синтаксис и семантика программ в ostis-системах}
\label{sec_programs_method_syntax_and_semantic}

\begin{SCn}
	
\begin{scnrelfromlist}{подраздел}
	\scnitem{\ref{sec_programs_method_syntax}~\nameref{sec_programs_method_syntax}}
	\scnitem{\ref{sec_programs_method_den_semantic}~\nameref{sec_programs_method_den_semantic}}
	\scnitem{\ref{sec_programs_method_op_semantic}~\nameref{sec_programs_method_op_semantic}}
	\scnitem{\ref{sec_programs_method_representation_language_syntax_and_semantic}~\nameref{sec_programs_method_representation_language_syntax_and_semantic}}
\end{scnrelfromlist}

\bigskip

\begin{scnrelfromlist}{ключевое понятие}
	\scnitem{спецификация метода*}
	\scnitem{синтаксис метода*}
	\scnitem{денотационная семантика метода*}
	\scnitem{операционная семантика метода*}
	\scnitem{спецификация языка представления методов*}
	\scnitem{синтаксис языка представления методов*}
	\scnitem{денотационная семантика языка представления методов*}
	\scnitem{операционная семантика языка представления методов*}
\end{scnrelfromlist}

\begin{scnrelfromlist}{ключевой знак}
	\scnitem{Принципы описания синтаксиса и семантики программ в ostis-системах}
	\scnitem{Язык SCP}
\end{scnrelfromlist}
	
\end{SCn}

\textit{синтаксис} и \textit{семантика метода} составляют \textit{спецификацию*} этого \textit{метода}. \textit{Семантику метода} можно рассматривать в двух аспектах: как множество знаний, связанных между собой (то есть \textit{денотационную семантику} данного \textit{метода}), и как знание, которое может быть интерпретировано другим методом (то есть \textit{операционную семантику} данного \textit{метода}).

\subsection{Синтаксис программ в ostis-системах}
\label{sec_programs_method_syntax}

Любый \textit{метод} состоит из \textit{информационных конструкций}, которые задают порядок действий в базе знаний, с помощью которых нужно перейти от исходного состояния к \myuline{целевому}, решив таким образом какую-то конкретную задачу. Так, например, в процедурном методе любой такой оператор представляет собой некоторую математическую функцию. Для композиции этих функций в более крупные фрагменты используются выражения и операторы. В свою очередь, линейные последовательности операторов и условные ветвления также могут быть представлены функциями, составленными из функций отдельных компонентов этих конструкций. Цикл легко описывается рекурсивной функцией, составленной из компонентов, входящих в его тело.

\textit{Синтаксис языков представления методов} в ostis-системах может быть формально описан различными способами. Так, например, можно использовать метаязык Бэкуса-Наура для описания синтаксиса любых \textit{языков представления методов}. Другими не менее известными формами представления методов являются контекстно-свободные грамматики, расширенная форма Бэкуса-Наура, синтаксические графы (см. \scncite{Sebesta2012}, \scncite{Scott2006}, \scncite{Scott1972}).

Однако значительно более логично и целесообразно описывать \textit{синтаксис} других языков на универсальном \textit{языке представления знаний} --- \textit{SC-коде}. Такой подход позволит ostis-системам самостоятельно понимать, анализировать и генерировать тексты указанных языков на основе принципов, общих для любых форм внешнего представления информации, в том числе нелинейных (см. \scncite{Petrov1978}). Таким образом, языки, написанные на \textit{SC-коде}, имеют такой же синтаксис как и сам \textit{SC-код}.

\subsection{Денотационная семантика программ в ostis-системах}
\label{sec_programs_method_den_semantic}

\textit{Семантика метода} разъясняет смысл \textit{синтаксических конструкций метода}. Наиболее распространенными методами описания семантики \textit{языков программирования} являются: денотационной, операционный, аксиоматический, алгебраический (см. \scncite{Orlov2021}). На базе принципов Технологии OSTIS, под семантикой метода будем подразумевать объединение \textit{денотационной} и \textit{операционной семантики метода}.

С помощью \textit{SC-кода} можно представлять и те языки, которые не написаны на нем. Проблема будет в том, что форма и смысл языка и его методов будут разделены, то есть будут представлены по-разному. В данном случае \textit{SC-код} выступает мощным инструментом для интеграции спецификаций различных языков внешнего представления знаний. Однако стоит отметить, что в представлении различных форм методов, принадлежащих разным \textit{языкам представления методов}, в рамках \textit{Технологии OSTIS} нет необходимости. Это объясняется тем, что:
\begin{textitemize}
    \item \textit{SC-код} является достаточно универсальным языком для представления любых видов знаний. Это означает, что различные формы алгоритма решения одной и той же задачи можно свести к минимуму. В \textit{SC-коде} фундаментом является формальная теория, что обеспечивает универсальное представление различных видов декларативных и процедурных знаний. Так, \textit{логические программы} можно представлять в виде \textit{процедурных программ}, в которых в качестве операндов операторов будут не только \textit{логические формулы} и \textit{правила вывода}, но и другие методы, обеспечивающее интерпретацию этих \textit{логических формул} при помощи правил вывода. Таким образом, \textit{SC-код} можно называть не только языком унифицированного представления знания, но и языком, на котором можно решать различные классы задачи одним и тем же способом.
    \item Различные виды знаний в \textit{ostis-системах}, проектируемые по принципам \textit{Технологии OSTIS}, глубоко интегрированы между собой. Это дает не только простоту для создания этих систем на базе имеющихся языков, которые могут быть описаны на \textit{SC-коде}, но большие возможности для создания базовых \textit{языков программирования} для \textit{программных компьютерных систем нового поколения} таких, как, например, \textit{базового языка представления процедурных методов SCP}, \textit{базового языка представления продукционных методов} и других. Современные \textit{языки представления методов} создаются с целью упрощения описания какого-то алгоритма для быстрого и качественного решения определенного класса задач. В свою очередь, предлагаемые методики и модели позволяют проектировать \textit{языки представления методов} для \textit{компьютерных систем нового поколения} с помощью базовых \textit{языков представления знаний} таким образом, чтобы сама форма представления знаний не менялась. Методы разных \textit{языков представления методов} должны иметь одну универсальную форму представления, то есть один и тот же синтаксис, но могут давать возможности описывать и представлять разными способами \textit{денотационную} и \textit{операционную семантику} своих \textit{методов} с помощью одного и того же синтаксиса.
    \item Проектирование новых \textit{языков представления методов} должно сводится к их полному описанию на минимальном семействе \textit{языков SC-кода}: \textit{SCP}, \textit{SCL} и других. Речь идет о том, что чтобы спроектировать новый \textit{язык представления методов} достаточно разработать (неатомарный) метаметод на языках \textit{SCP} и \textit{SCL}, который будет интерпретировать методы проектируемых языков, а также описать \textit{денотационную семантику} этих методов. \textit{Метаметод интерпретации методов языков представления методов} можно называть интерпретатором этих языков, то есть некоторой абстрактной sc-машиной, на которой возможно выполнение методов определенного \textit{языка представления} этих \textit{методов}.
\end{textitemize}

\subsection{Операционная семантика программ в ostis-системах}
\label{sec_programs_method_op_semantic}

Полная \textit{спецификация метода*} кроме \textit{денотационной семантики этого метода*} должна включать \textit{операционную семантику этого метода*}, то есть формальное описание интерпретатора заданного метода. \textit{Операционная семантика языка представления методов} описывает выполнение \textit{метода}, составленного на данном языке, средствами виртуального компьютера. Виртуальный компьютер определяется как абстрактный автомат. Внутренние состояния этого автомата моделируют состояния вычислительного процесса при выполнении метода. Автомат транслирует исходный текст метода в набор формально определенных операций. Этот набор задает переходы автомата из исходного состояния в последовательность промежуточных состояний, изменяя значения переменных метода. Автомат завершает свою работу, переходя в некоторое конечное состояние. Таким образом, здесь идет речь о достаточно прямой абстракции возможного использования языка представления методов. \textit{Операционная семантика} описывает смысл метода путем выполнения его операторов на простой машине-автомате. Изменения, происходящие в состоянии машины при выполнении данного оператора, определяют смысл этого оператора.

\textit{Операционная семантика} конкретного \textit{метода} сводится к описанию \textit{метаметода}, который его интерпретирует, верифицирует и так далее.

\begin{SCn}
\scnheader{метаметод}
\scnsubset{метод}
\scnidtf{метод, значениями параметров которого являются другие методы}
\end{SCn}

\begin{SCn}
\scnheader{операционная семантика метода}
\scnhaselement{метаметод интерпретации*}
\scnhaselement{метаметод верификации и оценки качества*}
\end{SCn}

Отношение \textit{метаметод интерпретации*} представляет собой \textit{класс sc-связок} между \textit{sc-связкой}, обозначающей множество \textit{методов}, и sc-узлом, обозначающим \textit{метод}, который способен произвести интерпретацию заданного множества \textit{методов}.
Отношение \textit{метаметод верификации и оценки качества*} представляет собой класс sc-связок между \textit{sc-связкой}, обозначающей множество \textit{методов}, и sc-узлом, обозначающим метод, который способен произвести верификацию и оценку качества заданного множества \textit{методов}.

В рамках \textit{Технологии OSTIS} таких метаметодов может быть большое разнообразие. Каждый из них может состоять из множества атомарных и неатомарных подметодов. Это могут быть как метаметоды, интерпретирующие методы определенных \textit{языков представления методов}, так и метаметоды, верифицирующие и анализирующие качество этих методов. В том числе метаметоды могут производить операции над другими метаметодами.

\begin{SCn}
\scnheader{метаметод интерпретации методов базовых языков представления методов}
\begin{scnrelfromlist}{класс подметодов}
    \scnitem{метаметод интерпретации методов Языка SCP}
    \scnitem{метаметод интерпретации методов Языка SCL}
    \scnitem{метаметод интерпретации методов языка представления продукционных методов}
    \scnitem{метаметод интерпретации методов языка представления функциональных методов}
    \scnitem{метаметод интерпретации методов языка представления нейросетей}
    \scnitem{метаметод интерпретации методов языка представления генетических алгоритмов}
\end{scnrelfromlist}
\end{SCn}

\begin{SCn}
\scnheader{метаметод верификации и оценки качества методов базовых языков представления методов}
\begin{scnrelfromlist}{класс подметодов}
    \scnitem{метаметод верификации и оценки качества методов Языка SCP}
    \scnitem{метаметод верификации и оценки качества методов Языка SCL}
    \scnitem{метаметод верификации и оценки качества методов языка представления продукционных методов}
    \scnitem{метаметод верификации и оценки качества методов языка представления функциональных методов}
    \scnitem{метаметод верификации и оценки качества методов языка представления нейросетей}
    \scnitem{метаметод верификации и оценки качества методов языка представления генетических алгоритмов}
\end{scnrelfromlist}
\end{SCn}

Так, например, при реализации методов в оstis-системах метаметодами будут являться \textit{интепретатор Языка SCP}, а также интепретаторы, реализованные непосредственно на \textit{Языке SCP}.

Понятие \textit{синтакиса}, \textit{денотационной} и операционной \textit{семантики языков представления методов} сводятся к понятию синтаксиса, денотационной и операционной семантики вообще любого языка.

\subsection{Синтаксис и семантика языков программирования в ostis-системах}
\label{sec_programs_method_representation_language_syntax_and_semantic}

Понятно, что для использования \textit{языка представления методов} следует описать каждую конструкцию языка в отдельности, а также ее применение в совокупности с другими конструкциями. В языке существует множество различных конструкций, точное определение которых необходимо как программисту, применяющему язык, так и разработчику компилятора для этого языка. Программисту эти знания позволяют прогнозировать вычисления, производимые операторами метода. Разработчику описания конструкций необходимы для создания правильной реализации компилятора.

Описание формальной модели \textit{языка представления методов} можно задать его \textit{спецификацией}. \textit{Спецификация языка представления методов*} содержит описание \textit{синтаксиса}, \textit{денотационной}, \textit{операционной} \textit{семантики языка представления методов}.

\begin{SCn}
\scnheader{спецификация языка представления методов*}
\scnsuperset{отношение, заданное на множестве (язык представления методов)*}
\begin{scnrelfromset}{разбиение}
    \scnitem{синтаксис языка представления методов*}
    \begin{scnindent}
        \scnsubset{синтаксис языка*}
        \scnidtf{теория правильно построенных информационных конструкций, принадлежащих заданному языку представления методов}
    \end{scnindent}
    \scnitem{денотационная семантика языка представления методов*}
    \begin{scnindent}
        \scnsubset{денотационная семантика языка*}
        \scnidtf{обобщенная формулировка классов задач, решаемых с помощью данного языка представления методов*}
    \end{scnindent}
    \scnitem{операционная семантика языка представления методов*}
    \begin{scnindent}
        \scnsubset{операционная семантика языка*}
        \scnidtf{перечень обобщенных агентов, обеспечивающих интерпретацию методов заданного языка представления методов*}
        \scnidtf{семейство методов интерпретации текстов данного языка представления методов*}
        \scnidtf{формальное описание интерпретатора заданного языка представления методов*}
    \end{scnindent}
\end{scnrelfromset}
\end{SCn}

\section{Методы и средства поддержки проектирования и разработки программ в ostis-системах}
\label{sec_programs_help_system}

Текущее состояние в области проектирования и разработки программного обеспечения говорит о том, что разработчики больше стремятся автоматизировать разработку методов на конкретных языках представления методов, чем обеспечить себя инструментальными обучающими средствами их проектирования, в том числе проектирования новых \textit{языков представления методов}. Это приводит к следующим проблемам:
\begin{textitemize}
	\item В то время, как количество разработчиков, понимающих код какой-то сложной программной системы, уменьшается, требования к этой системе растут все быстрее и быстрее. Зачастую, разработчики сложных программных систем сами не в состоянии объяснить логику работы этих систем. По этой причине необходимо создавать инструментальные средства, которые будут позволять автоматизировать документирование программных систем (см. \scncite{Lu2022}).
	\item Для обучения новых разработчиков навыкам работы с программными системы и их разработки необходимо привлекать ресурсы экспертов, понимающих принципы работы этих программных систем. Проблема решается разработкой справочной системы, которая будет позволять не только обучать пользователя тому, как проектировать методы решения задачи и программные системы на основе этих методов, но и указывать на пробелы в смежных дисциплинах, необходимых для достижения качественных результатов всей своей деятельности.
	\item В инженерии часто разработчики проектируют и разрабатывают решения, которые уже когда-то были созданы другими специалистами. Таким образом, получаются функционально эквивалентные методы решения задач, а то, и вовсе, программные системы, решающие схожие проблемы. Ключом к решению данной проблемы является проектирование семантически мощной \textit{библиотеки многократно используемых методов решения различных задач}.
\end{textitemize}

Таким образом, одной \textit{Cемантической теории программ} недостаточно. Кроме нее, для перманетного и беспрепятственного проектирования и разработки \textit{методов} различного класса необходимо разрабатывать:
\begin{textitemize}
	\item интеллектуальную систему поддержки проектирования и разработки методов, упомянутую в работах (см. \scncite{Gulykina2012}, \scncite{Pivovarchik2016}), которая будет не только помогать разработчику верифицировать разрабатываемый метод, но и подсказывать способы его разработки;
	\item семантически мощную библиотеку многократно используемых компонентов (см. \scncite{Ford2019}) для быстрого поиска существующих методов решения задач и их применения для решения других более комплексных задач.
\end{textitemize}

Потенциальная система должна быть частью общего инструментального средства разработки интеллектуальны компьютерных систем нового поколения --- \textit{Метасистемы OSTIS} (см. \scncite{IMS}) --- и может состоять из следующих компонентов:
\begin{textitemize}
	\item интеллектуальной help-системы по семантической теории программ;
	\item интеллектуальной help-системы по библиотеке многократно используемых методов решения задач,
	\item интеллектуальной help-системы по комплексу инструментальных средств проектирования  методов решения задач,
	\item интеллектуальной help-системы по методике обучения проектированию различных методов решения задач.
\end{textitemize}

Каждый компонент должен содержать:
\begin{textitemize}
	\item справочную подсистему,
	\item подсистему мониторинга и анализа деятельности разработчика методов решения задач,
	\item подсистему управления обучением.
\end{textitemize}

Каждая из подсистем взаимодействует с другими подсистемами, а также может функционировать автономно.

Справочная подсистема является консультантом-экспертом в области \textit{Семантической теории программ}, который может ответить на любой вопрос новичка или опытного пользователя. Каждая из таких систем может становиться индивидуальным помощников в обучении новых специалистов --- персональным ostis-ассистентом.

\section{Комплекс свойств, определяющих эффективность программ в ostis-системах}
\label{sec_programs_method_kriteria}

\textit{Язык представления методов} можно определить множеством показателей, характеризующих отдельные его свойства. Возникает задача введения меры для оценки степени приспособленности языка представления методов к выполнению возложенных на него функций --- \textit{критериев эффективности} (см. \scncite{Orlov2021}). Критерии эффективности методов приводятся на основе частных показателей эффективности этих методов (показателей качества). Способ связи между частными показателями определяет вид критерия эффективности.

\begin{SCn}
\scnheader{эффективность метода}
\begin{scnrelfromlist}{свойство-предпосылка}
    \scnitem{легкость чтения и понимания метода}
    \scnitem{легкость представления метода}
    \scnitem{стоимость метода}
    \scnitem{общий объем задач, решаемых при помощи данного класса методов}
    \scnitem{многообразие видов задач, решаемых при помощи данного класса методов}
    \scnitem{надежность метода}
\end{scnrelfromlist}
\end{SCn}

\textit{легкость чтения метода} должна способствовать легкому выделению основных понятий каждой части метода без обращения к его спецификации.

\begin{SCn}
\scnheader{легкость чтения и понимания метода}
\begin{scnrelfromlist}{свойство-предпосылка}
    \scnitem{простота синтаксиса языка представления методов}
    \scnitem{ортогональность информационных конструкций языка представления методов}
    \scnitem{структурированность потока управления в методе}
\end{scnrelfromlist}
\end{SCn}

\textit{Язык представления методов} должен предоставить \textit{простой} набор \textit{информационных конструкций}, которые могут быть использованы в качестве базисных элементов при создании методов.
Сильное воздействие на простоту оказывает \textit{синтаксис языка}: он должен прозрачно отражать семантику конструкций, исключать двусмысленность и неоднозначность толкования.

\textit{Ортогональность} означает, что любые возможные комбинации различных информационных конструкций будут осмысленными, без неожиданного поведения, возникающего в результате взаимодействия конструкций или контекста использования.

Порядок передач управления между операторами метода, то есть \textit{поток управления}, должен быть удобен для чтения и понимания человеком.

\textit{Легкость создания метода} отражает удобство языка для представления этого метода в конкретной предметной области.

\begin{SCn}
\scnheader{легкость представления метода}
\begin{scnrelfromlist}{свойство-предпосылка}
    \scnitem{простота синтаксиса языка представления методов}
    \scnitem{естественность синтаксиса языка представления методов}
    \scnitem{ортогональность информационных конструкций языка представления методов}
    \scnitem{полнота и точность спецификации языка представления методов}
    \scnitem{согласованность и целостность спецификации языка представления методов}
\end{scnrelfromlist}
\end{SCn}

\textit{синтаксис метода} должен способствовать легкому и прозрачному отображению в нем алгоритмических структур предметной области. \textit{Синтаксис языка представления методов} должен быть не только \textit{простым}, но и \textit{естественным}, и поддерживать \textit{ортогональность} информационных конструкций языка.

\textit{легкость представления нового метода} обеспечивается \textit{полной и точной, согласованной и целостной спецификацией} соответствующего языка. То есть необходимо достаточное количество \textit{информационных конструкций} в этом языке для того чтобы представить конкретный \textit{метод}. При этом \textit{спецификация языка} должна быть согласованной и целостной чтобы представлять на ней непротиворечивые \textit{методы}.

\textit{Стоимость метода языка представления методов} складывается из нескольких составляющих:

\begin{SCn}
\scnheader{общая стоимость метода}
\begin{scnrelfromlist}{свойство-предпосылка}
    \scnitem{стоимость применения метода}
    \scnitem{стоимость интерпретации метода}
    \scnitem{стоимость создания, тестирования и использования метода}
    \scnitem{стоимость сопровождения метода}
    \scnitem{согласованность и целостность спецификации языка представления методов}
\end{scnrelfromlist}
\end{SCn}

\textit{Стоимость применения метода} во многом зависит от структуры \textit{языка представления методов}. Язык, требующий многочисленных проверок синтаксических типов во время применения метода, будет препятствовать быстрой работе программы.

\textit{Размер стоимости интерпретации метода} зависит от возможностей используемого метаметода интерпретации. Чем совершеннее методы оптимизации, тем дороже стоит интерпретация.
Размер стоимости создания, тестирования и использования метода зависит от используемого метаметода верификации и оценки качества этого метода.

Многочисленные исследования показывают, что значительную часть стоимости используемого метода составляет не стоимость его разработки, а \textit{стоимость его сопровождения} (см. \scncite{Brooks2021}). Связывая сопровождение методов с другими их характеристиками, следует выделить, прежде всего, зависимость от читабельности, поскольку сопровождение обычно происходит следующим поколением разработчиков.

\textit{Общий объем задач и многообразие видов задач, решаемых при помощи данного класса методов}, являются не менее важными характеристиками и показывают степень универсальности соответствующего языка представления методов. Чем больше задач можно решить на я.п.м., тем он универсальнее.

\textit{надежность методов языка представления методов} должна обеспечиваться минимумом ошибок при работе конкретного метода.

Все эти критерии можно применить и касательно самих \textit{языков представления методов}.

\section*{Заключение к Главе \ref{chapter_programs}}

Данная глава является началом \textit{Семантической теории программ для компьютерных систем нового поколения}. Логичным развитием данной главы будут:

\begin{textitemize}
    \item уточнение и дополнение понятий \textit{Предметной области и онтологии методов} для достижения полноты теории;
    \item описание дочерних предметных областей \textit{Предметной области и онтологии методов} для конкретных видов методов, а также уточнение денотационной и операционной семантики спецификации этих методов;
    \item описание возможных путей реализации метаметодов интерпретации методов различных я.п.м.;
    \item формализация математических моделей для подсчета оценок эффективности методов.
\end{textitemize}
